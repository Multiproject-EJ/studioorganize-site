<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Screenplay Writing ‚Äî StudioOrganize</title>
  <link rel="stylesheet" href="/assets/styles.css"/>
  <link rel="icon" type="image/webp" href="/assets/img/studioorganizeFavicon.webp"/>
</head>
<body>
  <header class="nav">
    <div class="brand-with-logo">
      <a class="brand" href="/">StudioOrganize</a>
      <img class="brand-with-logo__badge" src="/assets/img/screenplay_writer1.webp" alt="Screenplay Writer app logo" />
    </div>
    <nav class="menu">
      <a class="menu__link menu__link--plain menu__link--icon" href="/">
        <span aria-hidden="true">üè†</span>
        <span class="sr-only">Home</span>
      </a>
      <div class="dropdown">
        <button class="dropbtn dropbtn--plain" type="button">Use Cases</button>
        <div class="dropdown-content">
          <a href="/use-cases/">All Use Cases</a>
          <a href="/use-cases/generate-ideas.html">Generate Ideas</a>
          <a href="/use-cases/screenplay.html">Screenplay Script</a>
          <a href="/use-cases/character-design.html">Character Design</a>
          <a href="/use-cases/set-design.html">Set / Production Design</a>
        </div>
      </div>
      <a class="menu__link menu__link--plain" href="https://finishthatstory.com" target="_blank" rel="noopener noreferrer">FinishThatStory.com</a>
      <div class="menu__actions">
        <button class="theme-toggle theme-toggle--icon" type="button" data-theme-toggle aria-pressed="false">
          <span class="sr-only">Toggle theme</span>
          <span class="theme-toggle__icon" aria-hidden="true" data-theme-icon>‚òÄÔ∏è</span>
        </button>
        <a class="menu__cta" href="https://studioorganize.com/supabase-test.html" data-auth-link>Sign up / Log in</a>
        <div class="dropdown" data-account-menu hidden>
          <button class="menu__cta" type="button" data-account-button>Account</button>
          <div class="dropdown-content">
            <a href="/account.html">My Creator Page</a>
            <a href="/product/personal.html">My Subscription</a>
            <a href="#" data-account-logout>Log out</a>
          </div>
        </div>
      </div>
    </div>
    </nav>
  </header>

  <main class="section">
    <style>
      html,body{height:100%; font-family: ui-sans-serif,system-ui,Segoe UI,Roboto,Arial}
      body{color:var(--ink); --nav-height:72px;}
      main.section{flex:1; display:flex; flex-direction:column; width:100%; max-width:none; padding:0; margin:0;}
      .app{display:grid; grid-template-rows:56px auto 1fr; flex:1; min-height:0; transition:transform .35s ease}
      .topbar{display:flex; align-items:center; gap:12px; padding:8px 12px; background:var(--panel); border-bottom:1px solid var(--ring)}
      .topbar h1{font-size:16px; font-weight:600; margin:0 8px 0 0}
      .spacer{flex:1}
      .btn{background:var(--chip); color:var(--ink); border:1px solid var(--ring); border-radius:10px; padding:8px 12px; cursor:pointer}
      .btn[data-tab-btn].active{background:var(--acc); border-color:var(--acc); color:var(--active-tab-text); font-weight:600}
      .timeline-dock{position:sticky; top:0; z-index:1200; display:flex; flex-direction:column; align-items:center; gap:12px; padding:14px 20px 6px; background:linear-gradient(180deg, var(--bg) 0%, transparent 90%);}
      .timeline-dock__handle{order:2; width:clamp(64px, 18vw, 110px); height:10px; border-radius:999px; border:none; padding:0; background:var(--ring); cursor:pointer; transition:background .3s ease, box-shadow .3s ease, opacity .2s ease; box-shadow:0 2px 6px rgba(0,0,0,0.35);}
      .timeline-dock__handle:hover{background:var(--acc);}
      .timeline-dock__handle:focus-visible{outline:2px solid var(--acc); outline-offset:3px;}
      .timeline-dock.pinned .timeline-dock__handle{background:var(--acc); box-shadow:0 8px 22px rgba(79,123,255,0.35);}
      .timeline-dock.floating-hidden .timeline-dock__handle{opacity:0.85;}
      .timeline-dock__shell{order:1; width:min(1080px, 100%); background:var(--hud); border:1px solid var(--ring); border-radius:18px; box-shadow:0 14px 34px rgba(8,15,28,0.32); overflow:hidden; transition:max-height .35s ease, box-shadow .35s ease, border-color .3s ease; max-height:560px; margin:0 auto;}
      .timeline-dock.floating-hidden .timeline-dock__shell{max-height:0; border-color:transparent; box-shadow:none;}
      .timeline-dock__content{display:flex; flex-direction:column; gap:12px; padding:12px 16px 18px; opacity:1; transform:translateY(0); transition:transform .35s ease, opacity .25s ease;}
      .timeline-dock.floating-hidden .timeline-dock__content{opacity:0; transform:translateY(-18px); pointer-events:none;}
      .timeline-dock.floating-hidden{flex-direction:column-reverse; padding-top:6px; padding-bottom:0; gap:6px;}
      .story-arc-timeline{padding:0;}
      .story-arc-container{background:var(--panel); border:1px solid var(--ring); border-radius:14px; padding:3px 10px;}
      .story-arc-track{display:flex; align-items:stretch; justify-content:space-between; gap:8px; margin:0; padding:0; list-style:none;}
      .story-arc-step{flex:1; display:flex; min-width:0;}
      .story-arc-pill{position:relative; display:flex; flex-direction:column; gap:1px; align-items:flex-start; justify-content:center; width:100%; padding:3px 10px; border-radius:999px; border:1px solid var(--ring); background:linear-gradient(135deg, rgba(79,123,255,0.14), rgba(79,123,255,0.06)); box-shadow:inset 0 0 0 1px rgba(79,123,255,0.08); transition:background .2s ease, border-color .2s ease, box-shadow .2s ease;}
      .story-arc-label{font-size:9px; font-weight:600; letter-spacing:.28px; text-transform:uppercase; color:var(--muted);}
      .story-arc-subtitle{font-size:8px; color:var(--muted); letter-spacing:.22px;}
      .story-arc-step--active .story-arc-pill{background:linear-gradient(135deg, var(--acc), #7aa7ff); border-color:var(--acc); box-shadow:0 10px 20px rgba(79,123,255,0.2);}
      .story-arc-step--active .story-arc-label{color:var(--active-tab-text);}
      .story-arc-step--active .story-arc-subtitle{color:rgba(255,255,255,0.85);}
      .story-arc-scenes{padding:0;}
      .story-arc-scenes__container{background:var(--panel); border:1px solid var(--ring); border-radius:14px; padding:6px 12px;}
      .story-arc-scenes__track{display:flex; align-items:stretch; gap:8px; margin:0; padding:0; list-style:none;}
      .story-arc-scenes__step{flex:1 1 0; min-width:0; display:flex;}
      .story-arc-scenes__slot{flex:1; min-width:0; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:3px; padding:6px 6px; border-radius:10px; border:1px solid var(--ring); background:var(--chip); text-align:center; position:relative; transition:border-color .15s ease, box-shadow .15s ease, background .15s ease;}
      .story-arc-scenes__slot:hover,
      .story-arc-scenes__slot:focus-visible{border-color:var(--acc); box-shadow:0 10px 24px rgba(79,123,255,0.22); background:linear-gradient(135deg, rgba(122,167,255,0.12), rgba(122,167,255,0.04)); outline:none;}
      .story-arc-scenes__slot::after{content:attr(data-tooltip); position:absolute; left:50%; bottom:calc(100% + 10px); transform:translate(-50%, 0); background:var(--panel); color:var(--ink); border:1px solid var(--ring); border-radius:8px; padding:6px 10px; font-size:11px; font-weight:500; box-shadow:0 12px 24px rgba(8,15,28,0.25); opacity:0; pointer-events:none; white-space:nowrap; max-width:260px; text-overflow:ellipsis; overflow:hidden; transition:opacity .15s ease, transform .15s ease; z-index:20;}
      .story-arc-scenes__slot::before{content:''; position:absolute; left:50%; bottom:calc(100% + 2px); transform:translate(-50%, 0) rotate(45deg); width:10px; height:10px; background:var(--panel); border:1px solid var(--ring); border-top:none; border-left:none; opacity:0; pointer-events:none; transition:opacity .15s ease, transform .15s ease; z-index:19; box-shadow:0 8px 16px rgba(8,15,28,0.2);}
      .story-arc-scenes__slot:hover::after,
      .story-arc-scenes__slot:hover::before,
      .story-arc-scenes__slot:focus-visible::after,
      .story-arc-scenes__slot:focus-visible::before{opacity:1; transform:translate(-50%, -4px);}
      .story-arc-scenes__scene-number{font-size:10px; font-weight:600; letter-spacing:.3px; text-transform:uppercase; color:var(--muted); transition:color .15s ease;}
      .story-arc-scenes__scene-label{font-size:12px; font-weight:600; color:var(--ink); max-width:100%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; transition:color .15s ease;}
      .story-arc-scenes__slot--compact .story-arc-scenes__scene-number{text-transform:none; font-size:13px; letter-spacing:0;}
      .story-arc-scenes__slot--compact .story-arc-scenes__scene-label{display:none;}
      .story-arc-scenes__step--active .story-arc-scenes__slot{background:linear-gradient(135deg, var(--acc), rgba(122,167,255,0.95)); border-color:var(--acc); box-shadow:0 8px 20px rgba(79,123,255,0.18);}
      .story-arc-scenes__step--active .story-arc-scenes__scene-number{color:var(--active-tab-text);}
      .story-arc-scenes__step--active .story-arc-scenes__scene-label{color:var(--active-tab-text);}
      .story-arc-scenes__empty{flex:1; display:flex; align-items:center; justify-content:center; min-height:48px; border-radius:10px; border:1px dashed var(--ring); color:var(--muted); font-size:12px; background:var(--chip);}
      #openCharacterStudioBtn{
        position:relative;
        background:linear-gradient(var(--panel), var(--panel)) padding-box,
          linear-gradient(135deg, #4f7bff, #ff6b6b) border-box;
        border:2px solid transparent;
        border-radius:12px;
        color:var(--ink);
        font-weight:600;
        padding:10px 16px;
        box-shadow:0 0 0 2px rgba(79,123,255,0.18);
        transition:box-shadow 0.2s ease, transform 0.2s ease;
      }
      #openCharacterStudioBtn:hover{
        box-shadow:0 0 0 4px rgba(79,123,255,0.25);
        transform:translateY(-1px);
      }
      #openCharacterStudioBtn:focus-visible{
        outline:none;
        box-shadow:0 0 0 4px rgba(79,123,255,0.45);
      }
      .topbar-group{display:flex; gap:6px; align-items:center}
      .save-status{font-size:12px; color:var(--muted); min-width:64px;}
      .save-status[data-state="saving"]{color:var(--muted);}
      .save-status[data-state="success"]{color:var(--acc);}
      .save-status[data-state="error"]{color:#ff6b6b;}
      .save-status[hidden]{display:none !important;}
      .btn-menu{position:relative}
      .btn-menu-list{display:none; position:absolute; right:0; top:calc(100% + 6px); min-width:180px; background:var(--panel); border:1px solid var(--ring); border-radius:12px; box-shadow:0 18px 40px rgba(0,0,0,0.4); padding:6px; z-index:30; flex-direction:column; gap:6px}
      .btn-menu.open .btn-menu-list{display:flex}
      .btn-menu-list button,
      .btn-menu-list a{background:var(--chip); border:1px solid var(--ring); border-radius:10px; padding:8px 10px; text-align:left; color:var(--ink); cursor:pointer; text-decoration:none; display:block}
      .btn-menu-list button:hover,
      .btn-menu-list a:hover{border-color:var(--acc)}
      .layout{display:grid; grid-template-columns:280px 1fr 320px; gap:10px; padding:10px; min-height:0}
      .panel{background:var(--panel); border:1px solid var(--ring); border-radius:14px; overflow:hidden; display:flex; flex-direction:column; min-height:0}
      .panel h2{font-size:13px; font-weight:600; letter-spacing:.4px; color:var(--muted); margin:10px 12px}
      .scenes{overflow:auto; padding:8px}
      .scene-card{position:relative; background:var(--card); border:1px solid var(--ring); border-radius:12px; padding:10px; margin-bottom:8px; cursor:pointer; display:flex; flex-direction:column; gap:8px; overflow:visible}
      .scene-card.active{outline:2px solid var(--acc)}
      .scene-card small{color:var(--muted)}
      .scene-card-body{display:flex; justify-content:space-between; align-items:flex-start; gap:8px}
      .scene-card-title{display:flex; flex-direction:column; gap:2px; width:100%}
      .scene-card-display{display:flex; flex-direction:column; gap:2px; min-width:0}
      .scene-card-input-wrapper{display:none; width:100%; align-items:center}
      .scene-card-input{flex:1; border-radius:8px; border:1px solid var(--ring); background:var(--chip); color:var(--ink); padding:6px 8px; font-size:13px; font-weight:500}
      .scene-card.editing{cursor:text}
      .scene-card.editing .scene-card-display{display:none}
      .scene-card.editing .scene-card-input-wrapper{display:flex}
      .scene-card.editing .scene-card-input{background:var(--panel); border-color:var(--acc); box-shadow:0 0 0 2px rgba(79,123,255,0.2)}
      .scene-card-sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}
      .scene-card-tags{display:flex; align-items:center; gap:8px; margin-top:2px}
      .scene-card-tags-list{display:flex; flex-wrap:wrap; gap:6px; min-width:0; flex:1}
      .scene-card-tags-button{flex:0 0 auto; display:inline-flex; align-items:center; justify-content:center; width:28px; height:28px; border-radius:50%; border:1px solid var(--ring); background:var(--chip); color:var(--ink); font-size:14px; font-weight:700; cursor:pointer; transition:background .2s ease, color .2s ease, border-color .2s ease}
      .scene-card-tags-button:hover{border-color:var(--acc); color:var(--acc)}
      .scene-card-tags-button:focus-visible{outline:2px solid var(--acc); outline-offset:2px}
      .scene-card-tags-button span{display:inline-flex; align-items:center; justify-content:center; line-height:1}
      .scene-card-tag{display:inline-flex; align-items:center; gap:6px; font-size:11px; letter-spacing:.3px; padding:4px 8px; border-radius:999px; border:1px solid var(--ring); background:var(--chip); color:var(--ink); font-weight:600}
      .scene-card-tag--empty{font-weight:500; color:var(--muted); border-style:dashed; background:transparent}
      .scene-card.dragging{opacity:0.55}
      .scene-card.drag-over{position:relative}
      .scene-card.drag-over::before{
        content:'';
        position:absolute;
        left:0;
        right:0;
        top:-6px;
        border-top:2px solid var(--acc);
        border-radius:2px;
        pointer-events:none;
      }
      .scene-card[data-drop-position="after"]::before{
        top:auto;
        bottom:-6px;
      }
      .scene-card-popover{position:relative; margin-top:12px; width:100%; max-width:none; background:var(--panel); border:1px solid var(--ring); border-radius:12px; box-shadow:0 18px 40px rgba(15,23,42,0.35); padding:12px; opacity:0; transform:translateY(-6px) scale(0.98); pointer-events:none; z-index:1; transition:opacity .18s ease, transform .18s ease; display:none;}
      .scene-card-popover::before{content:''; position:absolute; top:-6px; left:32px; width:12px; height:12px; background:var(--panel); border-left:1px solid var(--ring); border-top:1px solid var(--ring); transform:rotate(45deg);}
      [data-theme="dark"] .scene-card-popover{border-color:rgba(79,123,255,0.45); box-shadow:0 22px 60px rgba(8,15,28,0.7), 0 0 0 1px rgba(79,123,255,0.28), 0 0 26px rgba(79,123,255,0.35);}
      [data-theme="dark"] .scene-card-popover::before{border-left-color:rgba(79,123,255,0.45); border-top-color:rgba(79,123,255,0.45); box-shadow:-2px -2px 6px rgba(79,123,255,0.25);}
      .scene-card-popover-section{display:flex; flex-direction:column; gap:6px; margin-bottom:10px}
      .scene-card-popover-section:last-child{margin-bottom:0}
      .scene-card-popover-title{font-size:11px; letter-spacing:.3px; text-transform:uppercase; color:var(--muted); margin:0}
      .scene-card-chip-row{display:flex; flex-wrap:wrap; gap:6px}
      .scene-card-chip{border:1px solid var(--ring); background:var(--chip); color:var(--ink); border-radius:999px; font-size:11px; letter-spacing:.3px; padding:6px 10px; cursor:pointer; transition:background .2s ease, color .2s ease, border-color .2s ease;}
      .scene-card-chip[aria-pressed="true"], .scene-card-chip.active{background:var(--acc); color:var(--active-tab-text); border-color:var(--acc); font-weight:600}
      .scene-card-chip[data-role="remove"]{display:inline-flex; align-items:center; gap:4px; padding:6px 12px}
      .scene-card-chip[data-role="remove"] span{display:inline-flex; align-items:center}
      .scene-card-popover input[data-scene-custom-input]{flex:1}
      .scene-card-popover-actions{display:flex; gap:6px; align-items:center}
      .scene-card-popover-actions button{flex:0 0 auto; font-size:11px; letter-spacing:.3px; padding:6px 10px; border-radius:999px; border:1px solid var(--ring); background:var(--chip); color:var(--ink); cursor:pointer}
      .scene-card-popover-actions button:disabled{opacity:0.6; cursor:not-allowed}
      .scene-card[data-popover-open="true"] .scene-card-popover{display:block; opacity:1; pointer-events:auto; transform:translateY(0) scale(1); animation:sceneCardPopoverIn .18s ease;}
      @keyframes sceneCardPopoverIn{from{opacity:0; transform:translateY(-6px) scale(0.96);} to{opacity:1; transform:translateY(0) scale(1);} }
      .scene-card[data-popover-open="true"]{z-index:30}
      .scene-card-chip[data-empty="true"]{background:transparent; border-style:dashed; color:var(--muted); cursor:default}
      .scene-card-chip[data-empty="true"]:hover{border-style:dashed}
      .scenes.drag-over-end{position:relative}
      .scenes.drag-over-end::after{
        content:'';
        position:absolute;
        left:8px;
        right:8px;
        bottom:4px;
        border-bottom:2px solid var(--acc);
        border-radius:2px;
        pointer-events:none;
      }
      .scene-card-color{display:inline-flex; width:14px; height:14px; border-radius:50%; border:1px solid rgba(15,23,42,0.3);}
      .scene-card[data-color-source="auto"] .scene-card-color{box-shadow:0 0 0 2px rgba(79,123,255,0.2);}
      .timeline-card-color{display:inline-flex; width:12px; height:12px; border-radius:50%; border:1px solid rgba(15,23,42,0.25);}
      .editor{padding:0; display:flex; flex-direction:column; min-height:0}
      .editor-heading{display:flex; align-items:center; justify-content:space-between; padding:10px 12px 0 12px; gap:12px}
      .editor-heading h2{margin:0; font-size:13px; font-weight:600; letter-spacing:.4px; color:var(--muted)}
      .editor-stage{flex:1; display:flex; flex-direction:column; min-height:0; position:relative; --page-width:794px; --page-height:1123px}
      .editor-scroll{flex:1; overflow:auto; padding:0 12px 12px; display:flex; justify-content:center; align-items:stretch; position:relative}
      .editor-area{flex:1; max-width:var(--page-width); width:100%; min-height:100%; padding:16px 20px; line-height:1.6; font-size:15px; white-space:pre-wrap; outline:none; direction:ltr; writing-mode:horizontal-tb; unicode-bidi:plaintext; border-radius:12px; background:var(--panel); transition:box-shadow .2s ease, background .2s ease}
      .editor-stage[data-view-mode="scroll"] .editor-area{background-image:linear-gradient(to bottom, transparent calc(var(--page-height) - 2px), rgba(79,123,255,0.35) calc(var(--page-height) - 2px), rgba(79,123,255,0.35) calc(var(--page-height) - 1px), transparent calc(var(--page-height) - 1px)); background-size:100% var(--page-height); background-repeat:repeat-y; background-origin:content-box; box-shadow:none}
      .editor-stage[data-view-mode="pages"]{gap:10px}
      .editor-stage[data-view-mode="pages"] .editor-scroll{height:calc(var(--page-height) + 40px); overflow-y:auto; padding:0; scrollbar-width:none}
      .editor-stage[data-view-mode="pages"] .editor-scroll::-webkit-scrollbar{display:none}
      .editor-stage[data-view-mode="pages"] .editor-area{max-width:var(--page-width); width:var(--page-width); margin:0; box-shadow:0 18px 48px rgba(15,23,42,0.35)}
      .editor-footer{padding:12px; border-top:1px solid var(--ring); background:var(--panel); display:flex; justify-content:center}
      .script-controls{display:flex; justify-content:center; transition:opacity .3s ease, transform .3s ease; will-change:opacity, transform}
      .script-controls[data-visible="false"]{opacity:0; pointer-events:none; transform:translateY(8px)}
      .editor-view-toggle{display:inline-flex; border:1px solid var(--ring); border-radius:999px; padding:2px; background:var(--chip); gap:2px}
      .editor-view-toggle button{border:none; background:transparent; color:var(--muted); font-size:11px; letter-spacing:.3px; text-transform:uppercase; padding:4px 10px; border-radius:999px; cursor:pointer; transition:background .2s ease, color .2s ease}
      .editor-view-toggle button.active{background:var(--acc); color:var(--active-tab-text); font-weight:600}
      .page-view-nav{display:flex; align-items:center; gap:6px; justify-content:center}
      .page-view-nav button{border:1px solid var(--ring); background:var(--chip); color:var(--ink); border-radius:8px; padding:4px 8px; font-size:12px; cursor:pointer}
      .page-view-nav button:disabled{opacity:0.5; cursor:not-allowed}
      .page-view-label{font-size:12px; color:var(--muted)}
      .line{margin:6px 0; position:relative}
      .line.slug{letter-spacing:.4px; font-weight:700}
      .line.character{text-transform:uppercase; margin-top:14px; margin-bottom:2px}
      .line.parenthetical{margin-left:30px; font-style:italic}
      .line.dialogue{margin-left:30px; max-width:60ch}
      .line.transition{text-align:right; letter-spacing:.2px}
      .line.exposition{margin-left:30px; font-style:italic; color:var(--muted)}
      .line[data-tag-label]{padding-top:20px}
      .line[data-tag-label]::after{
        content: attr(data-tag-label);
        position:absolute;
        left:0;
        top:-4px;
        transform:translateY(-100%);
        font-size:11px;
        letter-spacing:.3px;
        color:var(--muted);
        background:var(--panel);
        border:1px solid var(--ring);
        border-radius:12px;
        padding:2px 8px;
        pointer-events:none;
        white-space:nowrap;
        box-shadow:0 6px 18px rgba(0,0,0,0.15);
        z-index:2;
      }
      .line[data-story-part="intro"]{border-left:3px solid var(--acc); padding-left:12px}
      .line[data-story-part="beginning"]{border-left:3px solid #7c4dff; padding-left:12px}
      .line[data-story-part="middle"]{border-left:3px solid #18a999; padding-left:12px}
      .line[data-story-part="end"]{border-left:3px solid #ff6b6b; padding-left:12px}
      .line[data-story-beat="setup"]{background-image:linear-gradient(90deg, rgba(79,123,255,0.18), transparent)}
      .line[data-story-beat="confrontation"]{background-image:linear-gradient(90deg, rgba(255,170,64,0.2), transparent)}
      .line[data-story-beat="resolution"]{background-image:linear-gradient(90deg, rgba(24,169,153,0.18), transparent)}
      .notes{padding:8px; display:flex; flex-direction:column; gap:8px; overflow:auto}
      textarea, input, select{background:var(--field); color:var(--ink); border:1px solid var(--ring); border-radius:10px; padding:8px; width:100%}
      .row{display:flex; gap:8px}
      .scene-color-control{display:flex; align-items:center; gap:6px; flex:1}
      .scene-color-control input[type="color"]{flex:0 0 44px; min-width:44px; width:44px; height:40px; padding:0; border-radius:10px; cursor:pointer}
      .scene-color-control .scene-color-auto-btn{flex:1; font-size:12px; padding:8px 10px}
      .scene-color-control .scene-color-auto-btn:disabled{opacity:0.65; cursor:default}
      .scene-color-meta{display:flex; align-items:center; gap:8px; font-size:12px; color:var(--muted); margin:-2px 0 2px}
      .scene-color-meta[hidden]{display:none !important}
      .scene-color-badge{display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px; font-size:11px; font-weight:600; border:1px solid var(--ring); background:var(--chip); color:var(--ink); transition:background 0.2s ease, color 0.2s ease}
      .scene-color-badge::before{content:''; width:10px; height:10px; border-radius:50%; border:1px solid rgba(15,23,42,0.24); background:currentColor; opacity:0.9}
      .scene-color-badge[data-source="auto"]{box-shadow:0 0 0 1px rgba(79,123,255,0.22)}
      .scene-color-badge[data-source="custom"]{box-shadow:0 0 0 1px rgba(15,23,42,0.12)}
      .writer-theme-toggle{width:100%; justify-content:center}
      .counter{font-size:12px; color:var(--muted)}
      .tab-header{display:flex; padding:8px; gap:6px; background:var(--chip); border-bottom:1px solid var(--ring)}
      .tab-btn{flex:1; background:var(--chip); border:1px solid var(--ring); border-radius:10px; padding:8px 10px; font-size:12px; color:var(--ink); cursor:pointer; letter-spacing:.3px; text-transform:uppercase}
      .tab-btn.active{background:var(--acc); border-color:var(--acc); color:var(--active-tab-text); font-weight:600}
      .tab-panels{flex:1; display:flex; flex-direction:column; min-height:0}
      .tab-panel{display:none; flex-direction:column; flex:1; padding:12px; gap:12px; overflow:auto}
      .tab-panel.active{display:flex}
      .tab-panel h3{margin:0; font-size:12px; letter-spacing:.4px; color:var(--muted); text-transform:uppercase}
      .panel-footer{padding:12px; border-top:1px solid var(--ring); display:flex; flex-direction:column; gap:10px; background:var(--panel)}
      .storyboard-field{display:grid; gap:16px; grid-template-columns:repeat(auto-fit, minmax(280px, 1fr)); align-items:start;}
      .storyboard-field-primary{display:flex; flex-direction:column; gap:12px;}
      .storyboard-field-create{display:flex; flex-direction:column; gap:14px; background:var(--panel); border:1px solid var(--ring); border-radius:16px; padding:18px; box-shadow:0 10px 30px rgba(15,23,42,0.12);}
      .storyboard-field-create h3{margin:0; font-size:14px; letter-spacing:.4px; text-transform:uppercase; color:var(--muted);}
      .storyboard-field-create p{margin:0; font-size:13px; color:var(--muted); line-height:1.5;}
      .storyboard-viewer{position:relative; border:1px solid var(--ring); border-radius:12px; overflow:hidden; background:var(--card); aspect-ratio:16 / 9; display:flex; align-items:center; justify-content:center;}
      .storyboard-viewer img{width:100%; height:100%; object-fit:cover; transition:opacity .2s ease;}
      .storyboard-viewer video{width:100%; height:100%; object-fit:cover; display:none; background:var(--card); border:none; border-radius:0;}
      .storyboard-viewer video::-webkit-media-controls-panel{background:rgba(17,25,40,0.65);}
      .storyboard-viewer[data-mode="video"] img{display:none;}
      .storyboard-viewer[data-mode="video"] video{display:block;}
      .storyboard-viewer[data-empty="true"] img{opacity:0.3; filter:saturate(0.1);}
      .storyboard-empty{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; text-align:center; padding:0 16px; font-size:0.95rem; color:var(--muted); pointer-events:none;}
      .storyboard-viewer[data-empty="false"] .storyboard-empty{display:none;}
      .storyboard-nav{position:absolute; top:50%; transform:translateY(-50%); background:rgba(0,0,0,0.4); color:#fff; border:none; width:38px; height:38px; border-radius:999px; display:flex; align-items:center; justify-content:center; cursor:pointer;}
      .storyboard-nav.prev{left:12px;}
      .storyboard-nav.next{right:12px;}
      .storyboard-nav[disabled]{opacity:0.45; cursor:not-allowed; background:rgba(0,0,0,0.25);}
      .storyboard-meta{display:flex; align-items:center; justify-content:space-between; gap:12px; font-size:0.9rem;}
      .storyboard-mode-switch{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
      .storyboard-mode-btn{border:1px solid var(--ring); background:var(--chip); color:var(--ink); border-radius:999px; font-size:11px; padding:6px 12px; cursor:pointer; letter-spacing:.3px; text-transform:uppercase;}
      .storyboard-mode-btn.active{background:var(--acc); border-color:var(--acc); color:var(--active-tab-text); font-weight:600;}
      .storyboard-mode-btn[disabled]{opacity:0.6; cursor:not-allowed;}
      .storyboard-input{display:flex; gap:8px; flex-wrap:wrap;}
      .storyboard-input input{flex:1 1 220px;}
      .storyboard-remove{background:none; border:none; color:var(--muted); cursor:pointer; font-size:0.85rem; text-decoration:underline; padding:4px 0;}
      .storyboard-remove[disabled]{cursor:not-allowed; opacity:0.5; text-decoration:none;}
      .panel-footer h2{margin:0; font-size:13px; font-weight:600; letter-spacing:.4px; color:var(--muted); text-transform:uppercase}
      .panel-footer-actions{display:flex; flex-direction:column; gap:8px; padding:10px; border:1px solid var(--ring); border-radius:12px; background:var(--chip)}
      .panel-footer-actions .danger-btn{width:100%; text-align:center}
      .timeline-list{display:flex; flex-direction:column; gap:10px}
      .timeline-item{display:flex; gap:10px; align-items:flex-start; padding:10px; border:1px solid var(--ring); border-radius:12px; background:var(--chip); cursor:pointer; transition:background .2s, border-color .2s; font:inherit; color:inherit; text-align:left}
      .timeline-item:hover{border-color:var(--acc)}
      .timeline-item.active{background:var(--acc); border-color:var(--acc); color:var(--active-tab-text)}
      .timeline-item.active .timeline-bullet{background:var(--active-tab-text); color:var(--panel)}
      .timeline-bullet{width:26px; height:26px; border-radius:999px; background:var(--ring); color:var(--muted); display:flex; align-items:center; justify-content:center; font-size:12px; font-weight:600}
      .timeline-item:focus{outline:none}
      .timeline-item:focus-visible{outline:2px solid var(--acc); outline-offset:2px}
      .timeline-body{display:flex; flex-direction:column; gap:4px}
      .timeline-meta{font-size:11px; color:var(--muted)}
      .timeline-item.active .timeline-meta{color:var(--active-tab-text)}
      .timeline-empty{font-size:12px; color:var(--muted)}
      body.storyboard-mode{overflow:hidden;}
      #storyboardOverlay{
        position:fixed; left:0; right:0; bottom:0; top:var(--nav-height, 72px);
        background:rgba(10,12,18,0.78);
        backdrop-filter:blur(16px);
        display:none; align-items:flex-start; justify-content:center;
        padding:24px clamp(16px, 4vw, 48px) 32px; z-index:400;
        overflow-y:auto;
      }
      body.storyboard-mode #storyboardOverlay{display:flex;}
      .storyboard-window{
        position:relative; width:100%; max-width:1200px; min-height:0;
        background:var(--panel); border:1px solid var(--ring);
        border-radius:20px; box-shadow:0 28px 90px rgba(0,0,0,0.45);
        display:flex; flex-direction:column; overflow:hidden;
      }
      .storyboard-overlay-header{
        display:flex; align-items:center; justify-content:space-between;
        padding:18px 22px; border-bottom:1px solid var(--ring);
        gap:12px; background:var(--chip);
      }
      .storyboard-overlay-header h2{margin:0; font-size:18px; font-weight:600;}
      .storyboard-ai-config{margin-top:12px; display:flex; flex-wrap:wrap; gap:10px; align-items:flex-end;}
      .storyboard-ai-config-field{display:flex; flex-direction:column; gap:6px; flex:1 1 220px;}
      .storyboard-ai-config-field span{font-size:11px; letter-spacing:.3px; text-transform:uppercase; color:var(--muted);}
      .storyboard-ai-config-field input,
      .storyboard-ai-config-field select{background:var(--field); color:var(--ink); border:1px solid var(--ring); border-radius:10px; padding:8px 10px; width:100%;}
      .storyboard-ai-config-hint{margin:0; font-size:11px; flex-basis:100%;}
      .storyboard-close-btn{
        background:var(--chip); border:1px solid var(--ring); border-radius:999px;
        padding:6px 12px; cursor:pointer; color:var(--ink);
      }
      .storyboard-overlay-body{
        display:grid; grid-template-columns:280px minmax(0, 1fr);
        min-height:0; max-height:calc(100vh - var(--nav-height, 72px) - 160px);
      }
      .storyboard-sidebar{
        border-right:1px solid var(--ring);
        padding:18px 20px; display:flex; flex-direction:column; gap:16px;
        background:var(--panel);
      }
      .storyboard-sidebar-header h3{margin:0; font-size:13px; letter-spacing:.4px; text-transform:uppercase; color:var(--muted);}
      .storyboard-sidebar-header p{margin:4px 0 0; font-size:12px; color:var(--muted);}
      .storyboard-scene-list{
        flex:1; overflow:auto; display:flex; flex-direction:column; gap:8px;
      }
      .storyboard-scene-btn{
        display:flex; flex-direction:column; align-items:flex-start; gap:4px;
        border:1px solid var(--ring); background:var(--chip); border-radius:12px;
        padding:10px 12px; cursor:pointer; color:var(--ink); text-align:left;
        transition:border-color .2s ease, background .2s ease;
      }
      .storyboard-scene-btn:hover{border-color:var(--acc);}
      .storyboard-scene-btn.active{
        background:var(--acc); border-color:var(--acc); color:var(--active-tab-text);
      }
      .storyboard-scene-btn-title{font-weight:600;}
      .storyboard-scene-btn-meta{font-size:11px; color:var(--muted);}
      .storyboard-scene-btn.active .storyboard-scene-btn-meta{color:var(--active-tab-text);}
      .storyboard-sidebar-empty{font-size:12px; color:var(--muted);}
      .storyboard-gallery{
        padding:20px 24px; display:flex; flex-direction:column; gap:18px;
        overflow:auto; background:var(--card);
      }
      .storyboard-gallery-header{
        display:flex; align-items:flex-start; justify-content:space-between;
        gap:12px; flex-wrap:wrap;
      }
      .storyboard-gallery-heading h3{margin:0; font-size:18px;}
      .storyboard-gallery-heading p{margin:4px 0 0; font-size:13px;}
      .storyboard-gallery-input{display:flex; gap:10px; flex-wrap:wrap;}
      .storyboard-gallery-input input{flex:1 1 240px;}
      .storyboard-ai-panel{border:1px solid var(--ring); border-radius:16px; background:var(--panel); padding:16px; display:flex; flex-direction:column; gap:12px;}
      .storyboard-ai-panel-header{display:flex; align-items:flex-start; justify-content:space-between; gap:12px; flex-wrap:wrap;}
      .storyboard-ai-panel-header h4{margin:0; font-size:15px; font-weight:600;}
      .storyboard-ai-panel-header p{margin:4px 0 0; font-size:12px; max-width:52ch;}
      .storyboard-ai-count{display:flex; flex-direction:column; gap:6px; min-width:120px;}
      .storyboard-ai-count span{font-size:11px; letter-spacing:.3px; text-transform:uppercase; color:var(--muted);}
      .storyboard-ai-field{display:flex; flex-direction:column; gap:6px;}
      .storyboard-ai-field span{font-size:11px; letter-spacing:.3px; text-transform:uppercase; color:var(--muted);}
      .storyboard-ai-field textarea{min-height:96px; resize:vertical;}
      .storyboard-ai-characters{display:flex; flex-direction:column; gap:8px;}
      .storyboard-ai-label{font-size:11px; letter-spacing:.3px; text-transform:uppercase; color:var(--muted);}
      .storyboard-ai-character-list{display:flex; flex-direction:column; gap:8px;}
      .storyboard-ai-character{display:flex; gap:10px; align-items:flex-start; padding:10px 12px; border:1px solid var(--ring); border-radius:12px; background:var(--chip);}
      .storyboard-ai-character input{width:auto; flex:0 0 auto; margin-top:4px;}
      .storyboard-ai-character-details{display:flex; flex-direction:column; gap:2px; font-size:13px;}
      .storyboard-ai-character-token{font-size:11px; font-weight:600; letter-spacing:.3px; color:var(--muted);}
      .storyboard-ai-character-notes{font-size:12px; color:var(--muted);}
      .storyboard-ai-character-empty{font-size:12px; color:var(--muted);}
      .storyboard-ai-actions{display:flex; align-items:center; gap:12px; flex-wrap:wrap;}
      .storyboard-ai-status{min-height:1.2em; font-size:12px;}
      .storyboard-ai-status[data-state="error"]{color:#ff6b6b;}
      .storyboard-ai-status[data-state="success"]{color:#18a999;}
      .storyboard-ai-status[data-state="pending"]{color:var(--ink);}
      .storyboard-gallery-grid{display:grid; gap:16px; grid-template-columns:repeat(auto-fill, minmax(220px, 1fr));}
      .storyboard-gallery-card{
        border:1px solid var(--ring); border-radius:16px; overflow:hidden;
        background:var(--panel); display:flex; flex-direction:column;
        cursor:pointer; transition:border-color .2s ease, box-shadow .2s ease, transform .2s ease;
      }
      .storyboard-gallery-card:hover{
        border-color:var(--acc); box-shadow:0 16px 40px rgba(0,0,0,0.28); transform:translateY(-2px);
      }
      .storyboard-gallery-card.active{
        border-color:var(--acc); box-shadow:0 16px 48px rgba(47,110,255,0.32);
      }
      .storyboard-gallery-thumb{aspect-ratio:16 / 9; background:var(--field); overflow:hidden; display:flex; align-items:center; justify-content:center;}
      .storyboard-gallery-thumb img,
      .storyboard-gallery-thumb video{width:100%; height:100%; object-fit:cover; display:block;}
      .storyboard-gallery-thumb video{background:var(--field);}
      .storyboard-gallery-card-footer{
        display:flex; align-items:center; justify-content:space-between;
        padding:12px 14px; gap:10px;
      }
      .storyboard-gallery-card-footer span{font-weight:600; font-size:13px;}
      .storyboard-gallery-card-actions{display:flex; gap:8px;}
      .storyboard-gallery-card-actions button{
        background:none; border:none; color:var(--muted); cursor:pointer;
        font-size:12px; text-decoration:underline; padding:0;
      }
      .storyboard-gallery-card-actions button:hover{color:var(--ink);}
      .storyboard-gallery-empty{font-size:13px; color:var(--muted);}
      .storyboard-gallery-empty[hidden]{display:none;}
      .storyboard-open-btn[disabled]{opacity:0.6; cursor:not-allowed;}
      @media (max-width: 900px){
        .storyboard-overlay-body{grid-template-columns:1fr; max-height:none;}
        .storyboard-sidebar{border-right:none; border-bottom:1px solid var(--ring);}
      }
      body.timeline-mode{overflow:hidden;}
      #timelineOverlay{
        position:fixed; left:0; right:0; bottom:0; top:var(--nav-height, 72px);
        background:rgba(10,12,18,0.78);
        backdrop-filter:blur(16px);
        display:none; align-items:flex-start; justify-content:center;
        padding:24px clamp(16px, 4vw, 48px) 32px; z-index:400;
      }
      body.timeline-mode #timelineOverlay{display:flex;}
      .timeline-window{
        position:relative; width:100%; max-width:1100px; min-height:0;
        background:var(--panel); border:1px solid var(--ring);
        border-radius:20px; box-shadow:0 28px 90px rgba(0,0,0,0.45);
        display:flex; flex-direction:column; overflow:hidden;
      }
      .timeline-overlay-header{
        display:flex; align-items:center; justify-content:space-between;
        padding:18px 22px; border-bottom:1px solid var(--ring);
        gap:12px; background:var(--chip);
      }
      .timeline-overlay-header h2{margin:0; font-size:18px; font-weight:600;}
      .timeline-overlay-header .muted-text{margin:0;}
      .timeline-close-btn{
        background:var(--chip); border:1px solid var(--ring); border-radius:999px;
        padding:6px 12px; cursor:pointer; color:var(--ink);
      }
      .timeline-overlay-body{padding:20px 22px; display:flex; flex-direction:column; gap:16px; overflow:auto;}
      .timeline-prompt{font-size:14px; color:var(--muted);}
      .timeline-board-wrapper{overflow-x:auto; padding-bottom:8px;}
      .timeline-board{
        display:flex; gap:14px; align-items:stretch; min-height:220px;
        padding:4px 6px; flex-wrap:nowrap;
      }
      .timeline-card{
        flex:0 0 240px; background:var(--card); border:1px solid var(--ring);
        border-radius:16px; padding:16px; display:flex; flex-direction:column;
        gap:10px; cursor:pointer; position:relative; transition:transform .2s ease, border-color .2s ease, box-shadow .2s ease;
      }
      .timeline-card:hover{border-color:var(--acc); box-shadow:0 16px 40px rgba(0,0,0,0.28); transform:translateY(-2px);}
      .timeline-card.active{border-color:var(--acc); box-shadow:0 16px 48px rgba(47,110,255,0.32);}
      .timeline-card.dragging{opacity:0.6; box-shadow:none; transform:rotate(-2deg);} 
      .timeline-card small{color:var(--muted); font-size:11px; letter-spacing:.3px; text-transform:uppercase;}
      .timeline-card h4{margin:0; font-size:15px; line-height:1.35;}
      .timeline-card-snippet{font-size:13px; line-height:1.5; color:var(--inkMuted, var(--muted));}
      .timeline-card-actions{display:flex; justify-content:space-between; align-items:center; font-size:12px; color:var(--muted);}
      .timeline-dropzone{
        flex:0 0 52px; border:1px dashed transparent; border-radius:14px;
        display:flex; align-items:center; justify-content:center; position:relative;
        transition:border-color .2s ease, background .2s ease;
      }
      .timeline-dropzone.over{border-color:var(--acc); background:rgba(95,168,255,0.12);}
      .timeline-add-btn{
        background:var(--chip); border:1px solid var(--ring); border-radius:12px;
        padding:10px 12px; font-size:12px; cursor:pointer; color:var(--ink);
        display:flex; align-items:center; gap:6px;
      }
      .timeline-add-btn:hover{border-color:var(--acc);}
      .timeline-overlay-footer{
        padding:20px 22px 24px; border-top:1px solid var(--ring);
        background:var(--panel); display:flex; flex-direction:column; gap:12px;
      }
      .timeline-composer{display:flex; flex-direction:column; gap:10px;}
      .timeline-composer label{font-size:12px; letter-spacing:.3px; text-transform:uppercase; color:var(--muted);}
      .timeline-composer input,
      .timeline-composer textarea{background:var(--field); color:var(--ink); border:1px solid var(--ring); border-radius:12px; padding:10px 12px; font-size:14px; width:100%;}
      .timeline-composer textarea{min-height:96px; resize:vertical;}
      .timeline-composer-actions{display:flex; align-items:center; gap:12px; flex-wrap:wrap;}
      .timeline-position-label{font-size:12px; color:var(--muted);}
      .timeline-save-btn{
        background:var(--acc); border:1px solid var(--acc); color:var(--active-tab-text);
        border-radius:999px; padding:8px 18px; font-weight:600; letter-spacing:.3px; cursor:pointer;
      }
      .timeline-save-btn:disabled{opacity:0.5; cursor:not-allowed;}
      #timelinePreview{
        position:absolute; inset:16px; display:none; align-items:center; justify-content:center;
        pointer-events:none;
      }
      #timelinePreview.open{display:flex;}
      .timeline-preview-card{
        pointer-events:auto; width:min(640px, calc(100% - 40px)); max-height:calc(100% - 40px);
        background:var(--card); border:1px solid var(--ring); border-radius:18px;
        box-shadow:0 28px 80px rgba(0,0,0,0.45); display:flex; flex-direction:column;
        overflow:hidden; transform:scale(.94); opacity:0;
        transform-origin:calc(var(--origin-x, .5) * 100%) calc(var(--origin-y, .5) * 100%);
        transition:transform .24s ease, opacity .24s ease;
      }
      #timelinePreview.open .timeline-preview-card{transform:scale(1); opacity:1;}
      .timeline-preview-header{padding:18px 22px; border-bottom:1px solid var(--ring); display:flex; flex-direction:column; gap:6px;}
      .timeline-preview-header h3{margin:0; font-size:18px;}
      .timeline-preview-meta{font-size:12px; color:var(--muted);}
      .timeline-preview-body{padding:18px 22px 22px; overflow:auto; flex:1; display:flex; flex-direction:column; gap:8px;}
      .timeline-preview-body .line{margin:0;}
      .timeline-preview-actions{padding:16px 22px; border-top:1px solid var(--ring); display:flex; justify-content:flex-end; gap:12px; background:var(--chip);}
      .timeline-secondary-btn{
        background:var(--chip); border:1px solid var(--ring); border-radius:12px;
        padding:8px 14px; font-size:13px; cursor:pointer; color:var(--ink);
      }
      .timeline-secondary-btn:hover{border-color:var(--acc);}
      .stats-grid{display:grid; grid-template-columns:repeat(auto-fit, minmax(90px, 1fr)); gap:10px}
      .stat-card{border:1px solid var(--ring); border-radius:12px; padding:10px; background:var(--chip); display:flex; flex-direction:column; gap:4px; text-align:center}
      .stat-value{font-size:18px; font-weight:700; color:var(--ink)}
      .stat-label{font-size:11px; color:var(--muted); letter-spacing:.3px; text-transform:uppercase}
      .tab-chip-group{display:flex; flex-wrap:wrap; gap:6px}
      .tab-chip{background:var(--chip); border:1px solid var(--ring); border-radius:10px; padding:6px 10px; font-size:12px; color:var(--ink); cursor:pointer}
      .tab-chip:hover{border-color:var(--acc)}
      .danger-btn{background:#7f1d1d; border:1px solid #b91c1c; color:#fff; border-radius:10px; padding:8px 10px; font-size:12px; cursor:pointer}
      .danger-btn:disabled{opacity:0.5; cursor:not-allowed}
      .catalog-list{display:flex; flex-direction:column; gap:6px}
      .catalog-item{display:flex; justify-content:space-between; align-items:center; gap:8px; background:var(--card); border:1px solid var(--ring); border-radius:10px; padding:8px 10px}
      .catalog-item-label{display:flex; flex-direction:column; gap:2px; line-height:1.25}
      .catalog-item-label span{font-size:13px}
      .catalog-meta{font-size:11px; color:var(--muted)}
      .catalog-actions{display:flex; gap:6px}
      .catalog-actions button{background:var(--chip); border:1px solid var(--ring); border-radius:8px; padding:4px 8px; font-size:11px; color:var(--ink); cursor:pointer}
      .muted-text{color:var(--muted); font-size:12px}
      .tab-divider{height:1px; background:var(--ring); margin:4px 0}
      .sound-list{display:flex; flex-direction:column; gap:6px}
      .sound-item{display:flex; justify-content:space-between; align-items:center; gap:8px; background:var(--card); border:1px solid var(--ring); border-radius:10px; padding:8px 10px}
      .sound-item button{background:var(--chip); border:1px solid var(--ring); border-radius:8px; padding:4px 8px; font-size:11px; color:var(--ink); cursor:pointer}

      /* ==== Character Studio ==== */
      body.character-studio-mode{overflow:hidden;}
      #characterStudioOverlay{
        position:fixed; left:0; right:0; bottom:0; top:var(--nav-height, 72px);
        background:rgba(7,9,14,0.82);
        backdrop-filter:blur(18px);
        display:none; align-items:flex-start; justify-content:center;
        padding:24px clamp(16px, 4vw, 48px) 32px;
        z-index:420;
        overflow:auto;
      }
      body.character-studio-mode #characterStudioOverlay{display:flex;}
      .character-studio-window{
        position:relative; width:100%; max-width:1200px; min-height:0;
        background:var(--panel); border:1px solid var(--ring);
        border-radius:24px; box-shadow:0 36px 110px rgba(0,0,0,0.5);
        display:flex; flex-direction:column; overflow:hidden;
      }
      .character-studio-window:focus{outline:none;}
      .character-studio-header{
        display:flex; align-items:center; justify-content:space-between;
        padding:22px 26px; border-bottom:1px solid var(--ring);
        gap:16px; background:var(--chip);
      }
      .character-studio-header h2{margin:0; font-size:20px; font-weight:600;}
      .character-studio-header .muted-text{margin:4px 0 0; max-width:48ch;}
      .character-studio-close{
        background:var(--chip); border:1px solid var(--ring); border-radius:999px;
        padding:8px 16px; cursor:pointer; color:var(--ink);
      }
      .character-studio-body{padding:24px 26px 28px; flex:1; overflow:auto;}
      .character-studio-layout{display:grid; grid-template-columns:280px 1fr; gap:20px; min-height:0;}
      .character-studio-sidebar{display:flex; flex-direction:column; gap:12px; min-height:0;}
      .character-studio-sidebar-header{display:flex; justify-content:space-between; align-items:center; gap:8px;}
      .character-studio-sidebar h3{margin:0; font-size:12px; letter-spacing:.4px; text-transform:uppercase; color:var(--muted);}
      .character-studio-add{
        background:var(--acc); border:1px solid var(--acc); color:var(--active-tab-text);
        border-radius:999px; padding:6px 14px; font-size:12px; font-weight:600; cursor:pointer;
      }
      .character-studio-sidebar-list{display:flex; flex-direction:column; gap:8px; overflow:auto; padding-right:4px; max-height:100%;}
      .character-studio-list-item{
        background:var(--card); border:1px solid var(--ring); border-radius:14px;
        padding:10px 12px; text-align:left; display:flex; flex-direction:column; gap:4px;
        cursor:pointer; color:inherit; font:inherit;
      }
      .character-studio-list-item strong{font-size:14px;}
      .character-studio-list-item span{font-size:11px; color:var(--muted); letter-spacing:.3px; text-transform:uppercase;}
      .character-studio-list-item:hover{border-color:var(--acc);}
      .character-studio-list-item.active{border-color:var(--acc); box-shadow:0 18px 48px rgba(47,110,255,0.25); background:var(--acc); color:var(--active-tab-text);}
      .character-studio-list-item.active span{color:var(--active-tab-text); opacity:0.9;}
      .character-studio-sidebar-note{font-size:11px; color:var(--muted); line-height:1.4;}
      .character-studio-details{display:flex; flex-direction:column; gap:18px; min-height:0;}
      .character-studio-detail-header{display:flex; justify-content:space-between; align-items:flex-start; gap:18px; flex-wrap:wrap;}
      .character-studio-detail-header h2{margin:0; font-size:24px; font-weight:600;}
      .character-studio-detail-header .muted-text{margin:6px 0 0; font-size:13px;}
      .character-studio-header-actions{display:flex; align-items:center; gap:8px;}
      .character-studio-tertiary{
        background:none; border:1px solid var(--ring); border-radius:12px;
        padding:6px 12px; font-size:12px; cursor:pointer; color:var(--muted);
      }
      .character-studio-section{
        background:var(--card); border:1px solid var(--ring); border-radius:18px;
        padding:20px 22px; display:flex; flex-direction:column; gap:14px;
      }
      .character-studio-section h3{margin:0; font-size:14px; font-weight:600;}
      .character-studio-section p{margin:0;}
      .character-studio-two-col{display:grid; gap:12px; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));}
      .character-studio-field{display:flex; flex-direction:column; gap:6px; font-size:13px;}
      .character-studio-field span{font-size:11px; color:var(--muted); letter-spacing:.3px; text-transform:uppercase;}
      .character-studio-section textarea{min-height:96px; resize:vertical;}
      .character-studio-section textarea.small{min-height:72px;}
      .character-studio-stats-grid{display:grid; gap:12px; grid-template-columns:repeat(auto-fit, minmax(140px, 1fr));}
      .character-studio-stat{background:var(--chip); border:1px solid var(--ring); border-radius:16px; padding:14px; display:flex; flex-direction:column; gap:6px; align-items:flex-start;}
      .character-studio-stat-value{font-size:22px; font-weight:700;}
      .character-studio-stat-label{font-size:11px; color:var(--muted); letter-spacing:.3px; text-transform:uppercase;}
      .character-studio-traits-preview{display:flex; flex-wrap:wrap; gap:8px; min-height:34px; align-items:flex-start;}
      .character-studio-chip{background:var(--chip); border:1px solid var(--ring); border-radius:999px; padding:4px 10px; font-size:12px;}
      .character-studio-chip strong{font-weight:600;}
      .character-studio-look-grid{display:grid; gap:12px; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));}
      .character-studio-look-card{position:relative; border:1px solid var(--ring); border-radius:16px; overflow:hidden; background:var(--chip); aspect-ratio:4 / 3; display:flex; align-items:center; justify-content:center; text-align:center;}
      .character-studio-look-card img{width:100%; height:100%; object-fit:cover;}
      .character-studio-look-empty{padding:0 16px; font-size:12px; color:var(--muted); line-height:1.45;}
      .character-studio-look-label{position:absolute; top:10px; left:10px; padding:4px 8px; border-radius:999px; font-size:11px; text-transform:uppercase; letter-spacing:.3px; background:rgba(15,18,30,0.65); color:#fff;}
      .character-studio-ai-actions{display:flex; flex-wrap:wrap; gap:10px; align-items:center;}
      .character-studio-ai-actions button{background:var(--acc); border:1px solid var(--acc); color:var(--active-tab-text); border-radius:999px; padding:8px 16px; font-weight:600; cursor:pointer;}
      .character-studio-status{font-size:12px; color:var(--muted); min-height:18px;}
      .character-studio-status[data-state="ready"]{color:var(--acc);}
      .character-studio-status[data-state="warning"]{color:#f97316;}
      .character-studio-empty, .character-studio-empty-list{border:1px dashed var(--ring); border-radius:16px; padding:28px; text-align:center; display:flex; flex-direction:column; gap:10px; color:var(--muted);}
      .character-studio-empty h2{margin:0; font-size:20px; color:var(--ink);}
      .character-studio-empty p{margin:0; font-size:13px;}
      .character-studio-empty-list{color:var(--muted); font-size:12px; align-items:center;}
      @media (max-width: 1100px){
        .character-studio-layout{grid-template-columns:240px 1fr;}
      }
      @media (max-width: 900px){
        .character-studio-layout{grid-template-columns:1fr;}
        .character-studio-sidebar{order:2;}
        .character-studio-details{order:1;}
      }

      /* ==== Script dialog ==== */
      body.script-dialog-open{overflow:hidden;}
      .script-dialog{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(11,15,20,0.75); z-index:1200; padding:24px;}
      .script-dialog.open{display:flex;}
      .script-dialog__backdrop{position:absolute; inset:0;}
      .script-dialog__panel{position:relative; background:var(--card); border:1px solid var(--ring); border-radius:16px; box-shadow:0 24px 80px rgba(0,0,0,0.45); max-width:1000px; width:100%; padding:24px; display:flex; flex-direction:column; gap:20px; color:var(--ink);}
      .script-dialog__header{display:flex; justify-content:space-between; align-items:flex-start; gap:12px;}
      .script-dialog__header h2{margin:0; font-size:20px;}
      .script-dialog__close{background:none; border:1px solid var(--ring); border-radius:50%; width:32px; height:32px; display:grid; place-items:center; cursor:pointer; color:var(--ink);}
      .script-dialog__body{display:grid; gap:20px; grid-template-columns:1fr; align-items:start;}
      .script-dialog__column{display:flex; flex-direction:column; gap:12px; align-self:stretch;}
      .script-dialog__column-title{margin:0; font-size:15px; font-weight:600; letter-spacing:.4px; text-transform:uppercase; color:var(--muted);}
      .script-dialog__column-card{display:flex; flex-direction:column; gap:20px; border:1px solid var(--ring); border-radius:16px; padding:20px; background:var(--chip); transition:border-color .2s ease, box-shadow .2s ease; flex:1;}
      .script-dialog__column-card:hover,
      .script-dialog__column-card:focus-within{border-color:var(--acc); box-shadow:0 0 0 3px rgba(79,123,255,0.25);}
      .script-dialog__field{display:flex; flex-direction:column; gap:4px; font-size:13px; color:var(--ink);}
      .script-dialog__field select{width:100%; padding:8px 10px; border-radius:10px; border:1px solid var(--ring); background:var(--chip); color:var(--ink); font-size:14px;}
      .script-dialog__field input{width:100%; padding:8px 10px; border-radius:10px; border:1px solid var(--ring); background:var(--chip); color:var(--ink); font-size:14px;}
      .script-dialog__status{min-height:18px;}
      .script-dialog__section{display:flex; flex-direction:column; gap:16px;}
      .script-dialog__section + .script-dialog__section{border-top:1px solid var(--ring); padding-top:20px;}
      .script-dialog__section-header{display:flex; flex-direction:column; gap:4px;}
      .script-dialog__section-header h4{margin:0; font-size:16px;}
      .script-dialog__section-header p{margin:0; font-size:13px; color:var(--muted);}
      .script-dialog__preview{display:flex; gap:12px; align-items:flex-start; border:1px solid var(--ring); border-radius:12px; padding:12px; background:rgba(255,255,255,0.04);}
      .script-dialog__preview img{width:96px; height:96px; object-fit:cover; border-radius:10px; border:1px solid var(--ring); background:rgba(255,255,255,0.04);}
      .script-dialog__preview h3{margin:0 0 4px; font-size:16px;}
      .script-dialog__preview p{margin:0;}
      .script-dialog__cover-group{display:flex; gap:12px; align-items:flex-start;}
      .script-dialog__cover-field{flex:1;}
      .script-dialog__cover-preview{position:relative; width:128px; aspect-ratio:3 / 2; border:1px solid var(--ring); border-radius:12px; overflow:hidden; background:rgba(255,255,255,0.04); display:flex; align-items:center; justify-content:center;}
      .script-dialog__cover-preview img{width:100%; height:100%; object-fit:cover; transition:opacity 0.2s ease, filter 0.2s ease;}
      .script-dialog__cover-preview[data-empty="true"] img{opacity:0.2; filter:saturate(0.1);}
      .script-dialog__cover-empty{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; text-align:center; padding:12px; font-size:12px; color:var(--muted); pointer-events:none; opacity:0; transition:opacity 0.2s ease;}
      .script-dialog__cover-preview[data-empty="true"] .script-dialog__cover-empty{opacity:1;}
      .script-dialog__actions{display:flex; justify-content:flex-end; gap:8px;}
      .script-dialog__column-footer{margin-top:auto; padding-top:20px; border-top:1px solid var(--ring); display:flex; justify-content:flex-end; gap:8px;}
      .script-dialog__hint{margin:0; font-size:12px; color:var(--muted);}
      .script-dialog__footer{display:flex; justify-content:flex-end; gap:8px;}
      @media (min-width: 720px){
        .script-dialog__body{grid-template-columns:repeat(2,minmax(0,1fr));}
      }
      @media (min-width: 1080px){
        .script-dialog__body{grid-template-columns:repeat(3,minmax(0,1fr));}
      }
      @media (max-width: 600px){
        .script-dialog{padding:16px;}
        .script-dialog__panel{width:100%; padding:20px;}
        .script-dialog__body{grid-template-columns:1fr;}
        .script-dialog__preview{flex-direction:column; align-items:center; text-align:center;}
      }
      @media (max-width: 900px){
        .timeline-dock{padding:12px 14px 6px;}
        .timeline-dock__content{padding:12px 12px 16px;}
      }
      @media (max-width: 600px){
        .timeline-dock{padding:10px 10px 4px;}
        .timeline-dock__shell{border-radius:14px;}
        .timeline-dock__content{padding:10px 10px 14px; gap:10px;}
      }

      /* ==== Focus Mode ==== */
      body.focus-mode .layout{ grid-template-columns: 1fr; }
      body.focus-mode .layout .panel:first-child,
      body.focus-mode .layout .panel:last-child{ display:none !important; }
      body.focus-mode .editor-area{
        max-width: 68ch;
        margin: 0 auto;
        padding: 48px 24px;
        font-size: 17px;
        line-height: 1.7;
      }
      body.focus-mode .topbar .non-essential{ display:none !important; }

      /* Line highlight */
      .line.active{ background: rgba(255,255,255,0.05); border-radius: 8px; padding: 2px 6px; }
      body.focus-mode .line.active{ background: rgba(95,168,255,0.12); }

      /* Site chrome animations for focus mode */
      .nav,
      .footer{
        transition: transform 0.35s ease, opacity 0.3s ease;
        transform: translateY(0);
        opacity: 1;
      }
      body.focus-mode .nav{
        transform: translateY(-100%);
        opacity: 0;
        pointer-events: none;
      }
      body.focus-mode .footer{
        transform: translateY(100%);
        opacity: 0;
        pointer-events: none;
      }

      body.focus-mode .app{ transform: translateY(calc(-1 * var(--nav-height, 0px))); }

      /* Bottom HUD visible only in focus mode */
      #focusHudDock{
        position: fixed;
        left: 50%;
        bottom: 18px;
        transform: translateX(-50%);
        display: none;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        z-index: 9999;
        width: max-content;
      }
      body.focus-mode #focusHudDock{ display:flex; }
      #focusHudDock.floating-hidden{ gap: 0; }
      #focusHudHandle{
        width: 64px;
        height: 8px;
        border-radius: 999px;
        border: none;
        padding: 0;
        display: block;
        background: var(--ring);
        cursor: pointer;
        transition: width 0.35s ease, background 0.3s ease, opacity 0.3s ease;
        box-shadow: 0 2px 6px rgba(0,0,0,0.35);
      }
      #focusHudHandle:hover{ background: var(--acc); }
      #focusHudHandle:focus-visible{
        outline: 2px solid var(--acc);
        outline-offset: 3px;
      }
      #focusHudDock.pinned #focusHudHandle{
        background: var(--acc);
        box-shadow: 0 6px 20px rgba(0,0,0,0.45);
      }
      #focusHudDock.floating #focusHudHandle{ width: 64px; }
      #focusHudDock.floating-hidden #focusHudHandle{ opacity: 0.85; }
      #focusHudDock .focus-hud-shell{
        overflow: hidden;
        border-radius: 12px;
        transition: max-height 0.35s ease;
        max-height: 520px;
      }
      #focusHudDock.floating-hidden .focus-hud-shell{ max-height: 0; }
      #focusHud{
        background: var(--hud);
        border: 1px solid var(--ring);
        border-radius: 12px;
        padding: 8px 12px;
        display: flex;
        gap: 8px;
        align-items: center;
        box-shadow: 0 8px 24px rgba(0,0,0,0.35);
        transform: translateY(0);
        opacity: 1;
        transition: transform 0.35s ease, opacity 0.25s ease;
      }
      #focusHudDock.floating-hidden #focusHud{
        transform: translateY(16px);
        opacity: 0;
        pointer-events: none;
      }
      #focusHud .hud-text{ font-size:12px; color: var(--muted); white-space:nowrap }
      #focusHud select, #focusHud button{background:var(--chip); color:var(--ink); border:1px solid var(--ring);
        border-radius:10px; padding:6px 10px; font-size:12px; cursor:pointer
      }

      /* ==== Pomodoro (Focus HUD) ==== */
      #focusHud .pomo-chip{display:flex; align-items:center; gap:10px; padding:6px 8px; border-radius:10px;
        background:var(--chip); border:1px solid var(--ring);
      }
      .pomo-ring{
        --pct: 0; /* 0..100 */
        width:44px; height:44px; border-radius:50%;
        background: conic-gradient(var(--acc) calc(var(--pct)*1%), var(--progressTrack) 0);
        display:grid; place-items:center;
      }
      .pomo-dial{
        width:34px; height:34px; border-radius:50%;
        display:grid; place-items:center;
        background:var(--dial); font-size:11px; letter-spacing:0.3px;
        color:var(--ink); border:1px solid var(--ring);
      }
      .pomo-meta{ display:flex; flex-direction:column; line-height:1.15 }
      .pomo-mode{ font-size:11px; color:var(--muted) }
      .pomo-controls{ display:flex; gap:6px }
      .pomo-btn{
        background:var(--chip); color:var(--ink); border:1px solid var(--ring);
        border-radius:10px; padding:4px 8px; font-size:12px; cursor:pointer;
      }

      /* Print to PDF: keep only the script */
      @media print{
        .topbar, .layout .panel:first-child, .layout .panel:last-child, #focusHud, #focusHudDock{ display:none !important; }
        .layout{ grid-template-columns: 1fr; }
        .editor-area{ max-width: 70ch; margin:0 auto; }
        body{ background:#fff; color:#000; }
        .panel{ border:none }
      }

      .selection-menu{position:fixed; z-index:1400; background:var(--panel); border:1px solid var(--ring); border-radius:16px; box-shadow:0 24px 60px rgba(0,0,0,0.35); padding:14px 16px; display:flex; flex-direction:column; gap:12px; min-width:220px; max-width:280px}
      .selection-menu[hidden]{display:none !important;}
      .selection-menu__quick{display:flex; flex-wrap:wrap; gap:8px; margin-bottom:4px}
      .selection-menu__quick-btn{flex:1; min-width:0; display:flex; align-items:center; justify-content:center}
      .selection-menu__quick-btn[data-selection-type-trigger]{position:relative; padding-right:22px}
      .selection-menu__quick-btn[data-selection-type-trigger]::after{content:'‚ñ∏'; position:absolute; right:10px; top:50%; transform:translateY(-50%); font-size:10px; opacity:0.7}
      .selection-menu__quick-btn[data-selection-type-trigger][aria-expanded="true"]::after{content:'‚ñæ'}
      .selection-menu__advanced-toggle{background:none; border:none; color:var(--muted); font-size:11px; letter-spacing:.35px; text-transform:uppercase; display:inline-flex; align-items:center; gap:6px; padding:0; cursor:pointer; align-self:flex-start}
      .selection-menu__advanced-toggle::after{content:'‚ñ∏'; font-size:10px; opacity:0.7}
      .selection-menu__advanced-toggle[aria-expanded="true"]::after{content:'‚ñæ'}
      .selection-menu__advanced{display:flex; flex-direction:column; gap:12px}
      .selection-menu__advanced[hidden]{display:none !important}
      .selection-menu__section{display:flex; flex-direction:column; gap:6px}
      .selection-menu__label{font-size:11px; color:var(--muted); text-transform:uppercase; letter-spacing:.35px}
      .selection-menu__actions{display:flex; flex-wrap:wrap; gap:6px}
      .selection-menu button{background:var(--chip); border:1px solid var(--ring); border-radius:10px; padding:6px 10px; font-size:12px; color:var(--ink); cursor:pointer; transition:background .2s ease, border-color .2s ease, color .2s ease}
      .selection-menu button:hover, .selection-menu button:focus{border-color:var(--acc); outline:none}
      .selection-menu button.active{background:var(--acc); border-color:var(--acc); color:var(--active-tab-text); font-weight:600}
      .selection-type-menu button{background:var(--chip); border:1px solid var(--ring); border-radius:10px; padding:6px 10px; font-size:12px; color:var(--ink); cursor:pointer; transition:background .2s ease, border-color .2s ease, color .2s ease}
      .selection-type-menu button:hover, .selection-type-menu button:focus{border-color:var(--acc); outline:none}
      .selection-type-menu button.active{background:var(--acc); border-color:var(--acc); color:var(--active-tab-text); font-weight:600}
      .selection-type-menu{position:fixed; z-index:1450; background:var(--panel); border:1px solid var(--ring); border-radius:14px; box-shadow:0 20px 50px rgba(0,0,0,0.35); padding:12px 14px; min-width:220px; display:flex; flex-direction:column; gap:12px}
      .selection-type-menu[hidden]{display:none !important}
      [data-theme="dark"] .selection-menu, [data-theme="dark"] .selection-type-menu{box-shadow:0 30px 70px rgba(8,15,28,0.72), 0 0 0 1px rgba(79,123,255,0.35), 0 0 22px rgba(79,123,255,0.3)}
    </style>
    <div class="app">
      <div class="topbar">
        <h1 id="title">Untitled Project</h1>
        <span class="counter" id="counter">0 pages ‚Ä¢ 0 words</span>
        <div class="spacer"></div>

        <!-- non-essential buttons collapse in focus mode -->
        <div class="topbar-group non-essential" role="group" aria-label="Quick panel toggles">
          <div class="btn-menu" id="saveMenu">
            <button class="btn" type="button" id="saveSceneBtn" aria-haspopup="true" aria-expanded="false">Save ‚ñæ</button>
            <div class="btn-menu-list" id="saveMenuList" role="menu">
              <button type="button" id="saveSceneMenuAction" data-save-action="save" role="menuitem">Save</button>
              <button type="button" id="saveSceneCloseAction" data-save-action="save-close" role="menuitem">Save &amp; Close</button>
              <button type="button" data-save-action="backup" role="menuitem">Backup Now</button>
              <button type="button" data-save-action="restore" role="menuitem">Restore‚Ä¶</button>
            </div>
          </div>
          <span class="save-status" id="saveSceneStatus" role="status" aria-live="polite" hidden></span>
          <div class="btn-menu non-essential" id="storyboardMenu">
            <button class="btn" type="button" id="storyboardMenuButton" aria-haspopup="true" aria-expanded="false">Storyboard ‚ñæ</button>
            <div class="btn-menu-list" id="storyboardMenuList" role="menu">
              <button class="btn-menu-item" type="button" id="storyboardModeBtn" aria-haspopup="dialog" aria-pressed="false" role="menuitem">Storyboard Lite</button>
              <a class="btn-menu-item" id="storyboardProLink" href="/StoryboardPro.html" role="menuitem">Storyboard Pro</a>
            </div>
          </div>
          <button class="btn" type="button" id="timelineModeBtn">Timeline</button>
        </div>

        <div class="btn-menu non-essential" id="exportMenu">
          <button class="btn" type="button" id="exportMenuButton" aria-haspopup="true" aria-expanded="false">Export ‚ñæ</button>
          <div class="btn-menu-list" id="exportMenuList" role="menu">
            <button type="button" data-export-action="fountain" role="menuitem">Fountain (.fountain)</button>
            <button type="button" data-export-action="pdf" role="menuitem">PDF</button>
          </div>
        </div>

        <button class="btn non-essential" id="scriptBtn" type="button" onclick="openScriptDialog()">Script‚Ä¶</button>

        <!-- Focus toggle -->
        <button class="btn" id="focusBtn" onclick="toggleFocus()">Focus</button>
      </div>
      <div id="timelineDock" class="timeline-dock pinned" aria-label="Story timeline dock">
        <button id="timelineDockHandle" class="timeline-dock__handle" type="button" aria-pressed="true" aria-expanded="true" aria-label="Click to float story timelines" title="Click to float story timelines"></button>
        <div class="timeline-dock__shell">
          <div class="timeline-dock__content">
            <div class="story-arc-timeline" aria-label="Story arc timeline">
              <div class="story-arc-container">
                <ol class="story-arc-track" role="list">
                  <li class="story-arc-step" role="listitem">
                    <div class="story-arc-pill">
                      <span class="story-arc-label">Opening</span>
                    </div>
                  </li>
                  <li class="story-arc-step story-arc-step--active" role="listitem" aria-current="step">
                    <div class="story-arc-pill">
                      <span class="story-arc-label">Middle</span>
                      <span class="story-arc-subtitle">Scene title</span>
                    </div>
                  </li>
                  <li class="story-arc-step" role="listitem">
                    <div class="story-arc-pill">
                      <span class="story-arc-label">End</span>
                    </div>
                  </li>
                </ol>
              </div>
            </div>
            <div class="story-arc-scenes" aria-label="Scene timeline">
              <div class="story-arc-scenes__container">
                <ol class="story-arc-scenes__track" id="storyArcSceneSlots" role="list"></ol>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="layout">
        <div class="panel">
          <h2 style="display:flex;align-items:center;justify-content:space-between;margin-right:8px">
            Scenes
            <button class="btn" style="padding:4px 8px" onclick="addScene()">+ Scene</button>
          </h2>
          <div id="sceneList" class="scenes"></div>
        </div>

        <div class="panel editor">
          <div class="editor-heading">
            <h2>Script</h2>
            <div class="editor-view-toggle" role="group" aria-label="Script view mode">
              <button type="button" class="active" data-script-view-mode="scroll" aria-pressed="true">Scroll</button>
              <button type="button" data-script-view-mode="pages" aria-pressed="false">Pages</button>
            </div>
          </div>
          <div class="editor-stage" id="editorStage" data-view-mode="scroll">
            <div class="editor-scroll" id="editorScroll">
              <div id="editor" class="editor-area" contenteditable="true"></div>
            </div>
          </div>
          <div class="editor-footer">
            <div class="script-controls" id="scriptControls" data-visible="true">
              <div class="page-view-nav" id="pageViewNav" hidden>
                <button type="button" id="pageViewPrev" aria-label="Previous page">‚óÇ</button>
                <span class="page-view-label" id="pageViewLabel">Page 1 of 1</span>
                <button type="button" id="pageViewNext" aria-label="Next page">‚ñ∏</button>
              </div>
            </div>
          </div>
        </div>

        <div class="panel">
          <div class="tab-header" id="rightTabBar">
            <button class="tab-btn" data-tab-btn="write">Visual</button>
            <button class="tab-btn" data-tab-btn="characters">Characters</button>
            <button class="tab-btn" data-tab-btn="set">Set</button>
            <button class="tab-btn" data-tab-btn="sound">Sound</button>
            <button class="tab-btn" data-tab-btn="timeline">Timeline</button>
            <button class="tab-btn" data-tab-btn="stats">Stats</button>
          </div>
          <div class="tab-panels">
            <div class="tab-panel" data-tab="write" id="tabWrite">
              <div class="storyboard-field">
                <div class="storyboard-field-create">
                  <h3>AI storyboard assistant</h3>
                  <p>Generate picture frames with AI or drop in your own storyboard image or clip.</p>
                  <div class="storyboard-mode-switch" role="group" aria-label="Storyboard media mode">
                    <button class="storyboard-mode-btn active" type="button" data-storyboard-mode-btn="image" aria-pressed="true">Picture frames</button>
                    <button class="storyboard-mode-btn" type="button" data-storyboard-mode-btn="video" aria-pressed="false">Video clips</button>
                  </div>
                  <div class="storyboard-input">
                    <input id="newStoryboardUrl" placeholder="Storyboard image URL" inputmode="url" autocomplete="off" />
                    <button class="btn" type="button" id="addStoryboardBtn">Add storyboard</button>
                  </div>
                </div>
                <div class="storyboard-field-primary">
                  <div class="storyboard-viewer" id="storyboardViewer" data-empty="true" data-mode="image">
                    <button class="storyboard-nav prev" type="button" id="storyboardPrev" aria-label="Previous storyboard image">&#x2039;</button>
                    <img id="storyboardImage" src="https://placehold.co/480x270?text=Storyboard" alt="Storyboard preview" loading="lazy" />
                    <video id="storyboardVideo" preload="metadata" playsinline controls hidden></video>
                    <div class="storyboard-empty" id="storyboardEmpty">No storyboard yet</div>
                    <button class="storyboard-nav next" type="button" id="storyboardNext" aria-label="Next storyboard image">&#x203A;</button>
                  </div>
                  <div class="storyboard-meta">
                    <span id="storyboardCounter" class="muted-text">No storyboard yet</span>
                    <button class="storyboard-remove" type="button" id="removeStoryboardBtn" disabled>Remove current</button>
                  </div>
                </div>
              </div>
              <div class="tab-divider"></div>
              <div>
                <h3>Scene Slug</h3>
                <div class="tab-chip-group">
                  <button class="tab-chip" data-slug-prefix="INT.">INT</button>
                  <button class="tab-chip" data-slug-prefix="EXT.">EXT</button>
                  <button class="tab-chip" data-slug-prefix="INT-EXT.">INT-EXT</button>
                </div>
                <div class="tab-chip-group">
                  <button class="tab-chip" data-slug-suffix="DAY">DAY</button>
                  <button class="tab-chip" data-slug-suffix="NIGHT">NIGHT</button>
                </div>
              </div>
              <div class="tab-divider"></div>
              <div>
                <h3>Insert Line</h3>
                <div class="tab-chip-group">
                  <button class="tab-chip" data-line-type="slug">Slug</button>
                  <button class="tab-chip" data-line-type="action">Action</button>
                  <button class="tab-chip" data-line-type="character">Character</button>
                  <button class="tab-chip" data-line-type="parenthetical">Parenthetical</button>
                  <button class="tab-chip" data-line-type="dialogue">Dialogue</button>
                  <button class="tab-chip" data-line-type="transition">Transition</button>
                </div>
              </div>
              <div class="tab-divider"></div>
            </div>
            <div class="tab-panel" data-tab="characters" id="tabCharacters">
              <div>
                <h3>Characters</h3>
                <div class="catalog-list" id="characterList"></div>
              </div>
              <div class="row">
                <input id="newCharacterName" placeholder="Add character" />
                <button class="btn" id="addCharacterBtn">Add</button>
              </div>
              <div class="row">
                <button class="btn" type="button" id="openCharacterStudioBtn">Character Studio</button>
              </div>
              <p class="muted-text">Tap a name to insert it as a CHARACTER line.</p>
              <p class="muted-text">Open Character Studio to develop arcs, looks, and family trees.</p>
            </div>
            <div class="tab-panel" data-tab="set" id="tabSet">
              <div>
                <h3>Locations</h3>
                <div class="catalog-list" id="setList"></div>
              </div>
              <div class="row">
                <input id="newSetName" placeholder="Add location" />
                <button class="btn" id="addSetBtn">Add</button>
              </div>
            </div>
            <div class="tab-panel" data-tab="sound" id="tabSound">
              <div>
                <h3>Sound Cues</h3>
                <div class="sound-list" id="soundList"></div>
              </div>
              <div class="row">
                <input id="newSoundCue" placeholder="Add sound cue" />
                <button class="btn" id="addSoundBtn">Add</button>
              </div>
            </div>
            <div class="tab-panel" data-tab="timeline" id="tabTimeline">
              <h3>Timeline</h3>
              <p class="muted-text" style="margin:0 0 8px">Open timeline mode for a card view of your scenes.</p>
              <div class="timeline-list" id="timelineList"></div>
            </div>
            <div class="tab-panel" data-tab="stats" id="tabStats">
              <h3>Stats</h3>
              <div class="stats-grid">
                <div class="stat-card">
                  <span class="stat-value" id="statSceneCount">0</span>
                  <span class="stat-label">Scenes</span>
                </div>
                <div class="stat-card">
                  <span class="stat-value" id="statPageCount">0</span>
                  <span class="stat-label">Pages</span>
                </div>
                <div class="stat-card">
                  <span class="stat-value" id="statWordCount">0</span>
                  <span class="stat-label">Words</span>
                </div>
                <div class="stat-card">
                  <span class="stat-value" id="statLineCount">0</span>
                  <span class="stat-label">Lines</span>
                </div>
              </div>
            </div>
          </div>
          <div class="panel-footer">
            <h2>Notes &amp; Meta</h2>
            <div class="notes">
              <textarea id="projectNotes" rows="8" placeholder="Project notes"></textarea>
              <div class="row">
                <input id="sceneSlug" placeholder="Scene Heading (Slug)" />
                <div class="scene-color-control">
                  <input id="sceneColor" type="color" aria-describedby="sceneColorDescription" />
                  <button id="sceneColorAutoBtn" class="btn scene-color-auto-btn" type="button">Auto from slug</button>
                </div>
              </div>
              <div class="scene-color-meta" id="sceneColorMeta" aria-live="polite">
                <span class="scene-color-badge" id="sceneColorBadge" data-source="auto">Auto</span>
                <span id="sceneColorDescription">Stripboard palette ready.</span>
              </div>
              <div class="row">
                <select id="smartFormat">
                  <option value="true">Smart format: ON</option>
                  <option value="false">Smart format: OFF</option>
                </select>
                <button id="writerThemeToggle" class="theme-toggle writer-theme-toggle" type="button" data-theme-toggle aria-pressed="false">Toggle theme</button>
              </div>
            </div>
            <div class="panel-footer-actions">
              <button class="danger-btn" id="deleteSceneBtn">Delete Scene</button>
            </div>
          </div>
      </div>
    </div>
  </div>

    <div id="selectionMenu" class="selection-menu" hidden>
      <div class="selection-menu__quick">
        <button type="button" class="selection-menu__quick-btn" data-selection-type-trigger aria-haspopup="true" aria-expanded="false">Type</button>
        <button type="button" class="selection-menu__quick-btn" data-quick-action="fix">Help Fix</button>
        <button type="button" class="selection-menu__quick-btn" data-quick-action="brainstorm">Help Brainstorm</button>
      </div>
      <button type="button" class="selection-menu__advanced-toggle" data-selection-advanced-toggle aria-expanded="false">Advanced</button>
      <div class="selection-menu__advanced" data-selection-advanced hidden>
        <div class="selection-menu__section">
          <span class="selection-menu__label">Format</span>
          <div class="selection-menu__actions">
            <button type="button" data-menu-line-type="slug">Scene Slug</button>
            <button type="button" data-menu-line-type="action">Action</button>
            <button type="button" data-menu-line-type="dialogue">Dialogue</button>
            <button type="button" data-menu-line-type="character">Character</button>
            <button type="button" data-menu-line-type="parenthetical">Parenthetical</button>
            <button type="button" data-menu-line-type="transition">Transition</button>
            <button type="button" data-menu-line-type="exposition">Exposition</button>
          </div>
        </div>
        <div class="selection-menu__section">
          <span class="selection-menu__label">Story Part</span>
          <div class="selection-menu__actions">
            <button type="button" data-menu-story-part="intro">Intro</button>
            <button type="button" data-menu-story-part="beginning">Beginning</button>
            <button type="button" data-menu-story-part="middle">Middle</button>
            <button type="button" data-menu-story-part="end">End</button>
            <button type="button" data-menu-story-part="">Clear</button>
          </div>
        </div>
        <div class="selection-menu__section">
          <span class="selection-menu__label">Three-Act Beat</span>
          <div class="selection-menu__actions">
            <button type="button" data-menu-act="setup">Setup</button>
            <button type="button" data-menu-act="confrontation">Confrontation</button>
            <button type="button" data-menu-act="resolution">Resolution</button>
            <button type="button" data-menu-act="">Clear</button>
          </div>
        </div>
        <div class="selection-menu__section" data-selection-characters-section hidden>
          <span class="selection-menu__label">Character</span>
          <div class="selection-menu__actions" data-selection-characters></div>
        </div>
      </div>
    </div>
    <div id="selectionTypeMenu" class="selection-type-menu" hidden>
      <div class="selection-menu__section" data-type-characters-section hidden>
        <span class="selection-menu__label">Characters</span>
        <div class="selection-menu__actions" data-type-characters></div>
      </div>
      <div class="selection-menu__section">
        <span class="selection-menu__label">Category</span>
        <div class="selection-menu__actions" data-type-note-actions>
          <button type="button" data-type-note>Note</button>
          <button type="button" data-type-character="">Clear Character</button>
        </div>
      </div>
    </div>

    <!-- Minimal HUD for focus mode -->
    <div id="focusHudDock" class="floating">
      <button id="focusHudHandle" type="button" aria-pressed="false" aria-label="Pin focus controls" title="Click to pin focus controls"></button>
      <div class="focus-hud-shell">
        <div id="focusHud">
          <span class="hud-text" id="hudCounter">0 pages ‚Ä¢ 0 words</span>
          <select id="hudScenePicker" onchange="pickSceneFromHud(this.value)"></select>

          <div class="pomo-chip">
            <div class="pomo-ring"><div class="pomo-dial" id="pomoTime">25:00</div></div>
            <div class="pomo-meta">
              <div class="pomo-mode" id="pomoMode">Work</div>
              <div class="pomo-controls">
                <button class="pomo-btn" id="pomoToggle" onclick="togglePomodoro()">Start</button>
                <button class="pomo-btn" onclick="resetPomodoro()">Reset</button>
              </div>
            </div>
          </div>

          <button onclick="addScene()">+ Scene</button>
          <button onclick="toggleFocus()">Exit Focus</button>
        </div>
      </div>
    </div>

    <div id="characterStudioOverlay" aria-hidden="true">
      <div class="character-studio-window" role="dialog" aria-modal="true" aria-labelledby="characterStudioTitle" tabindex="-1">
        <div class="character-studio-header">
          <div>
            <h2 id="characterStudioTitle">Character Studio</h2>
            <p class="muted-text">Craft multidimensional characters with dedicated planners, lookbooks, and AI prompts.</p>
          </div>
          <button class="character-studio-close" type="button" id="characterStudioClose">Close ‚úï</button>
        </div>
        <div class="character-studio-body">
          <div class="character-studio-layout">
            <aside class="character-studio-sidebar">
              <div class="character-studio-sidebar-header">
                <h3>Cast</h3>
                <button class="character-studio-add" type="button" id="characterStudioAddBtn">+ New</button>
              </div>
              <div class="character-studio-sidebar-list" data-character-list></div>
              <p class="character-studio-sidebar-note">Keep track of stats, arcs, and visual references for every character in one place.</p>
            </aside>
            <section class="character-studio-details" data-character-details>
              <div class="character-studio-empty">
                <h2>No characters yet</h2>
                <p>Add a character to start building their profile, traits, and arc.</p>
              </div>
            </section>
          </div>
        </div>
      </div>
    </div>

    <div id="storyboardOverlay" aria-hidden="true">
      <div class="storyboard-window" role="dialog" aria-modal="true" aria-labelledby="storyboardOverlayTitle">
        <div class="storyboard-overlay-header">
          <div>
            <h2 id="storyboardOverlayTitle">Storyboard</h2>
            <p class="muted-text">Map out every beat with scene-linked frames you can update in seconds.</p>
            <div class="storyboard-ai-config" role="group" aria-label="AI configuration">
              <label class="storyboard-ai-config-field" for="storyboardApiKey">
                <span>OpenRouter API key</span>
                <input id="storyboardApiKey" type="password" placeholder="sk-or-v1-‚Ä¶" autocomplete="off" />
              </label>
              <label class="storyboard-ai-config-field" for="storyboardModel">
                <span>Model</span>
                <select id="storyboardModel">
                  <option value="google/gemini-2.5-flash-image-preview">Gemini 2.5 Image Preview</option>
                </select>
              </label>
              <p class="storyboard-ai-config-hint muted-text">Keys stay on this device. Use consistent character handles for reliable panels.</p>
            </div>
          </div>
          <button class="storyboard-close-btn" type="button" id="storyboardOverlayClose">Close ‚úï</button>
        </div>
        <div class="storyboard-overlay-body">
          <aside class="storyboard-sidebar">
            <div class="storyboard-sidebar-header">
              <h3>Scenes</h3>
              <p class="muted-text">Jump between scenes and keep their key frames in sync.</p>
            </div>
            <div class="storyboard-scene-list" id="storyboardSceneList"></div>
          </aside>
          <section class="storyboard-gallery">
            <div class="storyboard-gallery-header">
              <div class="storyboard-gallery-heading">
                <h3 id="storyboardGalleryTitle">No scene selected</h3>
                <p class="muted-text" id="storyboardGalleryMeta"></p>
              </div>
              <div class="storyboard-mode-switch storyboard-mode-switch--overlay" role="group" aria-label="Storyboard media mode">
                <button class="storyboard-mode-btn active" type="button" data-storyboard-mode-btn="image" aria-pressed="true">Picture frames</button>
                <button class="storyboard-mode-btn" type="button" data-storyboard-mode-btn="video" aria-pressed="false">Video clips</button>
              </div>
              <button class="btn storyboard-open-btn" type="button" id="storyboardOpenSceneBtn" disabled>Open in Writer</button>
            </div>
            <div class="storyboard-gallery-input">
              <input id="storyboardQuickUrl" placeholder="Paste storyboard image URL" inputmode="url" autocomplete="off" disabled />
              <button class="btn" type="button" id="storyboardQuickAdd" disabled>Add storyboard</button>
            </div>
            <section class="storyboard-ai-panel" aria-labelledby="storyboardAIPanelTitle">
              <div class="storyboard-ai-panel-header">
                <div>
                  <h4 id="storyboardAIPanelTitle">AI storyboard assistant</h4>
                  <p class="muted-text">Describe the shot and Gemini 2.5 Image Preview will render frames that keep your cast on model.</p>
                </div>
                <label class="storyboard-ai-count" for="storyboardAIFrameCount">
                  <span>Frames</span>
                  <input id="storyboardAIFrameCount" type="number" min="1" max="4" value="1" inputmode="numeric" />
                </label>
              </div>
              <label class="storyboard-ai-field" for="storyboardAIPrompt">
                <span>Shot description</span>
                <textarea id="storyboardAIPrompt" rows="3" placeholder="Describe the composition, action, and emotion you want to visualize‚Ä¶"></textarea>
              </label>
              <div class="storyboard-ai-characters">
                <span class="storyboard-ai-label">Character handles</span>
                <div id="storyboardAICharacterList" class="storyboard-ai-character-list"></div>
              </div>
              <div class="storyboard-ai-actions">
                <button class="btn" type="button" id="storyboardAIGenerate">Generate storyboard</button>
                <span class="storyboard-ai-status muted-text" id="storyboardAIStatus" role="status" aria-live="polite"></span>
              </div>
            </section>
            <div class="storyboard-gallery-grid" id="storyboardGalleryGrid"></div>
            <div class="storyboard-gallery-empty" id="storyboardGalleryEmpty">Select a scene to start building a storyboard.</div>
          </section>
        </div>
      </div>
    </div>

    <div id="timelineOverlay" aria-hidden="true">
      <div class="timeline-window" role="dialog" aria-modal="true" aria-labelledby="timelineOverlayTitle">
        <div class="timeline-overlay-header">
          <div>
            <h2 id="timelineOverlayTitle">Timeline</h2>
            <p class="muted-text">Rearrange scenes, add new beats, and preview the flow of your story.</p>
          </div>
          <button class="timeline-close-btn" type="button" id="timelineOverlayClose">Close ‚úï</button>
        </div>
        <div class="timeline-overlay-body">
          <div class="timeline-prompt">What happens next? Drag cards to reorder scenes or click + to drop a new moment anywhere.</div>
          <div class="timeline-board-wrapper">
            <div class="timeline-board" id="timelineBoard"></div>
          </div>
        </div>
        <div class="timeline-overlay-footer">
          <div class="timeline-composer">
            <label for="timelineNewSceneTitle">New scene prompt</label>
            <input id="timelineNewSceneTitle" placeholder="Scene heading (e.g. INT. OFFICE - DAY)" />
            <textarea id="timelineNewSceneSummary" placeholder="What happens in this scene?"></textarea>
          </div>
          <div class="timeline-composer-actions">
            <span class="timeline-position-label" id="timelinePositionLabel">Will insert at the end.</span>
            <button class="timeline-save-btn" type="button" id="timelineAddSceneBtn">Add Scene</button>
          </div>
        </div>
        <div id="timelinePreview">
          <div class="timeline-preview-card" role="document">
            <div class="timeline-preview-header">
              <h3 id="timelinePreviewTitle">Scene Title</h3>
              <div class="timeline-preview-meta" id="timelinePreviewMeta"></div>
            </div>
            <div class="timeline-preview-body" id="timelinePreviewBody"></div>
            <div class="timeline-preview-actions">
              <button class="timeline-secondary-btn" type="button" id="timelinePreviewClose">Close</button>
              <button class="timeline-save-btn" type="button" id="timelinePreviewOpen">Open in Writer</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="scriptDialog" class="script-dialog" aria-hidden="true">
      <div class="script-dialog__backdrop" data-close-script></div>
      <div class="script-dialog__panel" role="dialog" aria-modal="true" aria-labelledby="scriptDialogTitle">
        <div class="script-dialog__header">
          <div>
            <h2 id="scriptDialogTitle">Load Script</h2>
            <p class="muted-text" id="scriptDialogSubtitle">Save your current work, then switch to a different script.</p>
          </div>
          <button type="button" class="script-dialog__close" id="scriptDialogClose" aria-label="Close script dialog">‚úï</button>
        </div>
        <div class="script-dialog__body">
          <div class="script-dialog__column">
            <h3 class="script-dialog__column-title">Current script</h3>
            <div class="script-dialog__column-card">
              <section class="script-dialog__section">
                <div class="script-dialog__section-header">
                  <h4>Project details</h4>
                  <p>Update the name of your active project.</p>
                </div>
                <div class="script-dialog__field">
                  <span class="muted-text">Current name</span>
                  <strong id="scriptDialogCurrentName">Untitled Project</strong>
                </div>
                <label class="script-dialog__field" for="scriptDialogCurrentTitle">
                  <span>Script title</span>
                  <input id="scriptDialogCurrentTitle" type="text" placeholder="Give your script a name" autocomplete="off" />
                </label>
              </section>
              <section class="script-dialog__section">
                <div class="script-dialog__section-header">
                  <h4>Current script artwork</h4>
                  <p>Use an image to represent the script you have open right now.</p>
                </div>
                <div class="script-dialog__cover-group">
                  <div class="script-dialog__cover-preview" id="scriptDialogCurrentCoverPreview" data-empty="true">
                    <img id="scriptDialogCurrentCoverImage" src="https://placehold.co/240x160?text=Script" alt="Current script title artwork" loading="lazy" />
                    <div class="script-dialog__cover-empty">No artwork yet</div>
                  </div>
                  <label class="script-dialog__field script-dialog__cover-field" for="scriptDialogCoverUrl">
                    <span>Title image URL</span>
                    <input id="scriptDialogCoverUrl" type="url" placeholder="https://example.com/cover.jpg" autocomplete="off" inputmode="url" />
                  </label>
                </div>
                <p class="muted-text script-dialog__hint">Shown wherever the current script needs a cover.</p>
                <div class="script-dialog__actions">
                  <button type="button" class="btn non-essential" id="scriptDialogClearCover">Remove artwork</button>
                  <button type="button" class="btn" id="scriptDialogApplyCover">Update artwork</button>
                </div>
              </section>
              <div class="script-dialog__column-footer">
                <button type="button" class="btn" id="scriptDialogSave">Save</button>
              </div>
            </div>
          </div>
          <div class="script-dialog__column">
            <h3 class="script-dialog__column-title">Switch scripts</h3>
            <div class="script-dialog__column-card">
              <section class="script-dialog__section">
                <div class="script-dialog__section-header">
                  <h4>Script selection</h4>
                  <p>Select another script to load its details.</p>
                </div>
                <label class="script-dialog__field" for="scriptSelect">
                  <span>Choose a script</span>
                  <select id="scriptSelect"></select>
                </label>
                <div class="script-dialog__status muted-text" id="scriptDialogStatus"></div>
                <div class="script-dialog__preview" id="scriptDialogPreview">
                  <img id="scriptPreviewImage" src="https://placehold.co/240x160?text=Script" alt="Selected script artwork" loading="lazy" />
                  <div>
                    <h3 id="scriptPreviewName">Select a script</h3>
                    <p class="muted-text" id="scriptPreviewDescription"></p>
                  </div>
                </div>
              </section>
              <div class="script-dialog__column-footer">
                <button type="button" class="btn btn-primary" id="scriptDialogLoad">Save &amp; Load</button>
              </div>
            </div>
          </div>
          <div class="script-dialog__column">
            <h3 class="script-dialog__column-title">Create new script</h3>
            <div class="script-dialog__column-card">
              <section class="script-dialog__section">
                <div class="script-dialog__section-header">
                  <h4>New script</h4>
                  <p>Start a blank project with its own scenes.</p>
                </div>
                <label class="script-dialog__field" for="scriptDialogNewTitle">
                  <span>Script title</span>
                  <input id="scriptDialogNewTitle" type="text" placeholder="Give your script a name" autocomplete="off" />
                </label>
                <label class="script-dialog__field" for="scriptDialogNewCoverUrl">
                  <span>Optional cover image URL</span>
                  <input id="scriptDialogNewCoverUrl" type="url" placeholder="https://example.com/new-script.jpg" autocomplete="off" inputmode="url" />
                </label>
                <p class="muted-text script-dialog__hint">Applied to the script you create.</p>
              </section>
              <div class="script-dialog__column-footer">
                <button type="button" class="btn" id="scriptDialogCreate">Create</button>
              </div>
            </div>
          </div>
        </div>
        <div class="script-dialog__footer">
          <button type="button" class="btn non-essential" id="scriptDialogCancel">Close</button>
        </div>
      </div>
    </div>

    <script>
    function syncNavHeight(){
      const nav = document.querySelector('.nav');
      if (!nav) return;
      const rect = nav.getBoundingClientRect();
      const height = Math.max(0, Math.round(rect.height));
      document.documentElement.style.setProperty('--nav-height', `${height}px`);
    }
    syncNavHeight();
    window.addEventListener('resize', syncNavHeight);

    /* =========================
     * IndexedDB minimal wrapper
     * =======================*/
    const DB_NAME = 'sw_db_v1';
    const STORE = 'projects';
    let db;

    function openDB(){
      return new Promise((resolve, reject)=>{
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = e => {
          const idb = e.target.result;
          if(!idb.objectStoreNames.contains(STORE)){
            idb.createObjectStore(STORE, { keyPath: 'projectId' });
          }
        };
        req.onsuccess = e => { db = e.target.result; resolve(); };
        req.onerror = e => reject(e);
      });
    }
    function saveLocal(project){
      return new Promise((resolve,reject)=>{
        const tx = db.transaction([STORE],'readwrite');
        tx.objectStore(STORE).put(project);
        tx.oncomplete = resolve;
        tx.onerror = reject;
      });
    }
    function loadLocal(projectId){
      return new Promise((resolve,reject)=>{
        const tx = db.transaction([STORE],'readonly');
        const req = tx.objectStore(STORE).get(projectId);
        req.onsuccess = ()=> resolve(req.result || null);
        req.onerror = reject;
      });
    }

    const STORY_PART_LABELS = {
      intro: 'Intro',
      beginning: 'Beginning',
      middle: 'Middle',
      end: 'End'
    };
    const STORY_BEAT_LABELS = {
      setup: 'Setup',
      confrontation: 'Confrontation',
      resolution: 'Resolution'
    };
    const STORYBOARD_AI_CONFIG_STORAGE_KEY = 'SW_STORYBOARD_AI_CONFIG_V1';
    const STORYBOARD_AI_DEFAULT_MODEL = 'google/gemini-2.5-flash-image-preview';
    const STORYBOARD_MODE_STORAGE_KEY = 'SW_STORYBOARD_MEDIA_MODE_V1';
    const STORYBOARD_MEDIA_IMAGE = 'image';
    const STORYBOARD_MEDIA_VIDEO = 'video';
    const STORYBOARD_MEDIA_MODES = [STORYBOARD_MEDIA_IMAGE, STORYBOARD_MEDIA_VIDEO];
    const STORYBOARD_MODE_CONFIG = {
      [STORYBOARD_MEDIA_IMAGE]: {
        label: 'Picture frames',
        singular: 'frame',
        plural: 'frames',
        addAction: 'Add frame',
        removeAction: 'Remove frame',
        placeholder: 'Storyboard image URL',
        quickPlaceholder: 'Paste storyboard image URL',
        empty: 'No storyboard frames yet',
        counterEmpty: 'No storyboard frames yet',
        counterPrefix: 'Storyboard frame',
        aiAvailable: true
      },
      [STORYBOARD_MEDIA_VIDEO]: {
        label: 'Video clips',
        singular: 'clip',
        plural: 'clips',
        addAction: 'Add clip',
        removeAction: 'Remove clip',
        placeholder: 'Storyboard clip URL',
        quickPlaceholder: 'Paste storyboard clip URL',
        empty: 'No storyboard clips yet',
        counterEmpty: 'No storyboard clips yet',
        counterPrefix: 'Storyboard clip',
        aiAvailable: false
      }
    };
    const SCENE_LOCATION_TYPES = [
      { value: 'INT.', label: 'Interior' },
      { value: 'EXT.', label: 'Exterior' },
      { value: 'INT./EXT.', label: 'Int./Ext.' },
      { value: 'EXT./INT.', label: 'Ext./Int.' }
    ];
    const SCENE_TIME_OF_DAY_OPTIONS = [
      { value: 'DAY', label: 'Day' },
      { value: 'NIGHT', label: 'Night' },
      { value: 'MORNING', label: 'Morning' },
      { value: 'EVENING', label: 'Evening' },
      { value: 'LATER', label: 'Later' }
    ];
    const SCENE_TAG_MAX_CUSTOM = 4;
    function getDefaultStoryboardAIConfig(){
      return { apiKey: '', model: STORYBOARD_AI_DEFAULT_MODEL };
    }
    function loadStoryboardAIConfig(){
      const fallback = getDefaultStoryboardAIConfig();
      try {
        const raw = localStorage.getItem(STORYBOARD_AI_CONFIG_STORAGE_KEY);
        if (!raw) return fallback;
        const parsed = JSON.parse(raw);
        return {
          apiKey: typeof parsed?.apiKey === 'string' ? parsed.apiKey : '',
          model: typeof parsed?.model === 'string' && parsed.model ? parsed.model : STORYBOARD_AI_DEFAULT_MODEL
        };
      } catch (err){
        return fallback;
      }
    }
    function saveStoryboardAIConfig(){
      try {
        localStorage.setItem(STORYBOARD_AI_CONFIG_STORAGE_KEY, JSON.stringify(storyboardAIConfig));
      } catch (err){}
    }

    function loadStoryboardMediaMode(){
      try {
        const raw = localStorage.getItem(STORYBOARD_MODE_STORAGE_KEY);
        if (!raw) return STORYBOARD_MEDIA_IMAGE;
        return STORYBOARD_MEDIA_MODES.includes(raw) ? raw : STORYBOARD_MEDIA_IMAGE;
      } catch (err){
        return STORYBOARD_MEDIA_IMAGE;
      }
    }

    function saveStoryboardMediaMode(mode){
      try {
        localStorage.setItem(STORYBOARD_MODE_STORAGE_KEY, mode);
      } catch (err){}
    }

    function getStoryboardModeConfig(mode){
      return STORYBOARD_MODE_CONFIG[mode] || STORYBOARD_MODE_CONFIG[STORYBOARD_MEDIA_IMAGE];
    }

    /* =========================
     * State & Config
     * =======================*/
    let project = null;
    let activeSceneId = null;
    let saveTimer = null;
    let saveSceneStatusTimer = null;
    let storyboardMode = false;
    let storyboardMediaMode = loadStoryboardMediaMode();
    let storyboardOverlaySceneId = null;
    let storyboardAIConfig = loadStoryboardAIConfig();
    const storyboardAIPrompts = new Map();
    const storyboardAISelections = new Map();
    const storyboardAIFrameCounts = new Map();
    const storyboardCharacterTokenCache = new Map();
    let storyboardAIActiveSceneId = null;
    let storyboardAIGenerating = false;
    let timelineMode = false;
    let timelineInsertIndex = 0;
    let timelineDragSceneId = null;
    let timelinePendingPreviewId = null;
    let timelineSuppressClick = false;
    const TIMELINE_HIDE_DELAY = 3500;
    let timelinePinned = true;
    let timelineHideTimer = null;
    let timelineHovering = false;
    let lastTimelinePinned = null;
    let sceneDragSceneId = null;
    const SCENE_CARD_CLICK_DELAY = 220;
    let scenePopoverOpenId = null;
    let scenePopoverDismissBound = false;
    let sceneInlineRenameId = null;
    let sceneInlineRenameDraft = '';
    let scenePopoverClickTimer = null;
    let pendingSceneRenameFocusId = null;
    const characterStudioState = {
      open: false,
      activeId: null
    };

    function randomId(){
      const cryptoObj = (typeof globalThis !== 'undefined' && globalThis.crypto)
        || (typeof window !== 'undefined' && window.crypto)
        || null;
      if (cryptoObj && typeof cryptoObj.randomUUID === 'function'){
        try {
          return cryptoObj.randomUUID();
        } catch (err){
          console.warn('crypto.randomUUID failed, falling back to manual id generation.', err);
        }
      }
      if (cryptoObj && typeof cryptoObj.getRandomValues === 'function'){
        const bytes = cryptoObj.getRandomValues(new Uint8Array(16));
        bytes[6] = (bytes[6] & 0x0f) | 0x40;
        bytes[8] = (bytes[8] & 0x3f) | 0x80;
        const toHex = b => b.toString(16).padStart(2, '0');
        return `${toHex(bytes[0])}${toHex(bytes[1])}${toHex(bytes[2])}${toHex(bytes[3])}-${toHex(bytes[4])}${toHex(bytes[5])}-${toHex(bytes[6])}${toHex(bytes[7])}-${toHex(bytes[8])}${toHex(bytes[9])}-${toHex(bytes[10])}${toHex(bytes[11])}${toHex(bytes[12])}${toHex(bytes[13])}${toHex(bytes[14])}${toHex(bytes[15])}`;
      }
      return `id-${Math.random().toString(36).slice(2)}-${Date.now().toString(36)}`;
    }

    function createCharacterData(name=''){
      const trimmed = (name || '').trim();
      return {
        id: randomId(),
        name: trimmed,
        role: '',
        archetype: '',
        pronouns: '',
        age: '',
        summary: '',
        traits: [],
        background: '',
        familyTree: '',
        stats: { scenes: 0, screenTime: 0, dialogue: 0 },
        arc: { setup: '', development: '', resolution: '' },
        looks: { portrait: '', turnarounds: [], expressions: [] },
        ai: { prompt: '', notes: '' }
      };
    }

    function normalizeList(value){
      if (Array.isArray(value)) return value.map(v => String(v || '').trim()).filter(Boolean);
      if (typeof value === 'string') return value.split(/\r?\n+/).map(v => v.trim()).filter(Boolean);
      return [];
    }

    function normalizeCharacter(item){
      const base = createCharacterData(item && typeof item.name === 'string' ? item.name : '');
      if (!item || typeof item !== 'object') return base;
      const normalized = { ...base, ...item };
      normalized.id = item.id || base.id;
      normalized.name = typeof item.name === 'string' ? item.name : base.name;
      normalized.role = typeof item.role === 'string' ? item.role : '';
      normalized.archetype = typeof item.archetype === 'string' ? item.archetype : '';
      if (typeof item.pronouns === 'string') normalized.pronouns = item.pronouns;
      if (typeof item.age === 'string') normalized.age = item.age;
      else if (typeof item.age === 'number') normalized.age = String(item.age);
      normalized.summary = typeof item.summary === 'string' ? item.summary : '';
      normalized.background = typeof item.background === 'string' ? item.background : '';
      normalized.familyTree = typeof item.familyTree === 'string' ? item.familyTree : '';
      if (Array.isArray(item.traits)) normalized.traits = item.traits.map(t => String(t || '').trim()).filter(Boolean);
      else if (typeof item.traits === 'string') normalized.traits = normalizeList(item.traits);
      normalized.stats = { ...base.stats, ...(item.stats || {}) };
      normalized.stats.scenes = Number.isFinite(Number(normalized.stats.scenes)) ? Number(normalized.stats.scenes) : 0;
      normalized.stats.screenTime = Number.isFinite(Number(normalized.stats.screenTime)) ? Number(normalized.stats.screenTime) : 0;
      normalized.stats.dialogue = Number.isFinite(Number(normalized.stats.dialogue)) ? Number(normalized.stats.dialogue) : 0;
      normalized.arc = { ...base.arc, ...(item.arc || {}) };
      normalized.arc.setup = typeof normalized.arc.setup === 'string' ? normalized.arc.setup : '';
      normalized.arc.development = typeof normalized.arc.development === 'string' ? normalized.arc.development : '';
      normalized.arc.resolution = typeof normalized.arc.resolution === 'string' ? normalized.arc.resolution : '';
      normalized.looks = { ...base.looks, ...(item.looks || {}) };
      normalized.looks.portrait = typeof normalized.looks.portrait === 'string' ? normalized.looks.portrait : '';
      normalized.looks.turnarounds = normalizeList(normalized.looks.turnarounds);
      normalized.looks.expressions = normalizeList(normalized.looks.expressions);
      normalized.ai = { ...base.ai, ...(item.ai || {}) };
      normalized.ai.prompt = typeof normalized.ai.prompt === 'string' ? normalized.ai.prompt : '';
      normalized.ai.notes = typeof normalized.ai.notes === 'string' ? normalized.ai.notes : '';
      return normalized;
    }

    function createSceneElement(type='action', text='', ownerId=null, storyPart=null, storyBeat=null){
      const normalizedType = typeof type === 'string' && type ? type : 'action';
      const normalizedText = typeof text === 'string' ? text : '';
      const owner = (typeof ownerId === 'string' && ownerId) ? ownerId : null;
      const part = (typeof storyPart === 'string' && STORY_PART_LABELS[storyPart]) ? storyPart : null;
      const beat = (typeof storyBeat === 'string' && STORY_BEAT_LABELS[storyBeat]) ? storyBeat : null;
      return { t: normalizedType, txt: normalizedText, ownerId: owner, storyPart: part, storyBeat: beat };
    }

    function normalizeSceneElement(element){
      if (!element || typeof element !== 'object'){
        const fallbackText = typeof element === 'string' ? element : '';
        return createSceneElement('action', fallbackText);
      }
      const type = typeof element.t === 'string' && element.t ? element.t : 'action';
      const text = typeof element.txt === 'string' ? element.txt : '';
      const owner = (typeof element.ownerId === 'string' && element.ownerId) ? element.ownerId : null;
      const part = (typeof element.storyPart === 'string' && STORY_PART_LABELS[element.storyPart]) ? element.storyPart : null;
      const beat = (typeof element.storyBeat === 'string' && STORY_BEAT_LABELS[element.storyBeat]) ? element.storyBeat : null;
      return createSceneElement(type, text, owner, part, beat);
    }

    const BACKUP_IDLE_MS = 120000;   // 2 min idle ‚Üí auto backup
    const FULL_SNAPSHOT_EVERY = 10;  // every 10 deltas
    const MAX_DELTA_BYTES = 128 * 1024;

    let backupTimer = null;
    let lastSerializedMetaHash = '';
    let supabaseSession = null;
    let supabaseSessionBound = false;
    const storyboardIndexState = new Map();
    const STORYBOARD_INDEX_DELIMITER = '::';

    function storyboardIndexKey(sceneId, mode = storyboardMediaMode){
      const safeSceneId = sceneId || 'scene';
      const safeMode = STORYBOARD_MEDIA_MODES.includes(mode) ? mode : STORYBOARD_MEDIA_IMAGE;
      return `${safeSceneId}${STORYBOARD_INDEX_DELIMITER}${safeMode}`;
    }

    function getStoryboardIndex(sceneId, mode = storyboardMediaMode){
      return storyboardIndexState.get(storyboardIndexKey(sceneId, mode)) ?? 0;
    }

    function setStoryboardIndex(sceneId, value, mode = storyboardMediaMode){
      storyboardIndexState.set(storyboardIndexKey(sceneId, mode), value);
    }

    function deleteStoryboardIndex(sceneId, mode){
      storyboardIndexState.delete(storyboardIndexKey(sceneId, mode));
    }

    function clampStoryboardIndex(scene, mode = storyboardMediaMode){
      if (!scene) return 0;
      const storyboards = getSceneStoryboards(scene, mode);
      const max = Math.max(0, storyboards.length - 1);
      const current = getStoryboardIndex(scene.id, mode);
      const next = Math.max(0, Math.min(current, max));
      setStoryboardIndex(scene.id, next, mode);
      return next;
    }

    function bindSupabaseSessionClient(client){
      if (!client || supabaseSessionBound) return;
      supabaseSessionBound = true;
      client.auth.getSession().then(({ data, error }) => {
        if (error) {
          console.warn('Supabase session fetch failed:', error);
          return;
        }
        supabaseSession = data?.session || null;
      });
      client.auth.onAuthStateChange((_event, session) => {
        supabaseSession = session;
      });
    }

    if (window.supabaseClient) bindSupabaseSessionClient(window.supabaseClient);
    window.addEventListener('auth:ready', e => {
      if (supabaseSessionBound && supabaseSession) return;
      bindSupabaseSessionClient(e.detail?.supabase);
    });

    async function getSupabaseSession(client){
      if (!client) return null;
      if (supabaseSession && supabaseSession.user) return supabaseSession;
      const { data, error } = await client.auth.getSession();
      if (error) throw error;
      supabaseSession = data?.session || null;
      return supabaseSession;
    }

    function cloneValue(value){
      if (value === null || value === undefined) return value;
      if (typeof structuredClone === 'function'){
        try { return structuredClone(value); }
        catch (err) { /* fall back */ }
      }
      try { return JSON.parse(JSON.stringify(value)); }
      catch (err) { return value; }
    }

    function toFiniteNumber(value){
      if (value === null || value === undefined) return null;
      const num = Number(value);
      return Number.isFinite(num) ? num : null;
    }

    function toStringOrNull(value){
      return (value === null || value === undefined) ? null : String(value);
    }

    function sanitizeSceneRow(row){
      if (!row) return null;
      const cloneArray = (arr) => Array.isArray(arr) ? cloneValue(arr) : [];
      const cloneObject = (obj) => (obj && typeof obj === 'object') ? cloneValue(obj) : {};
      const rawColor = typeof row.color === 'string' ? row.color : toStringOrNull(row.color);
      return {
        id: row.id ?? null,
        owner_id: row.owner_id ?? null,
        project_id: row.project_id ?? null,
        slug: typeof row.slug === 'string' ? row.slug : toStringOrNull(row.slug),
        title: typeof row.title === 'string' ? row.title : toStringOrNull(row.title),
        synopsis: typeof row.synopsis === 'string' ? row.synopsis : toStringOrNull(row.synopsis),
        scene_number: toFiniteNumber(row.scene_number),
        script_order: toFiniteNumber(row.script_order),
        color: normalizeSceneColor(rawColor || ''),
        location: typeof row.location === 'string' ? row.location : toStringOrNull(row.location),
        time_of_day: typeof row.time_of_day === 'string' ? row.time_of_day : toStringOrNull(row.time_of_day),
        cards: cloneArray(row.cards),
        elements: cloneArray(row.elements),
        sounds: cloneArray(row.sounds),
        metadata: cloneObject(row.metadata)
      };
    }

    function sanitizeStoryboardRowList(rows){
      if (!Array.isArray(rows)) return [];
      return rows
        .filter(row => row && (typeof row.image_url === 'string' || typeof row.url === 'string'))
        .map(row => {
          const rawUrl = typeof row.image_url === 'string' ? row.image_url : row.url;
          const url = typeof rawUrl === 'string' ? rawUrl.trim() : '';
          const position = Number.isFinite(row.position) ? row.position : 0;
          const rawType = typeof row.media_type === 'string' ? row.media_type : row.type;
          const type = rawType === STORYBOARD_MEDIA_VIDEO ? STORYBOARD_MEDIA_VIDEO : STORYBOARD_MEDIA_IMAGE;
          return { id: row.id ?? null, url, position, type };
        })
        .filter(entry => !!entry.url)
        .sort((a, b) => (a.position || 0) - (b.position || 0))
        .map((entry, idx) => ({ id: entry.id, url: entry.url, position: idx, type: entry.type }));
    }

    function ensureSceneStoryboardStructure(scene){
      if (!scene || typeof scene !== 'object') return;
      if (!scene.metadata || typeof scene.metadata !== 'object') scene.metadata = {};
      const metadataList = Array.isArray(scene.metadata.storyboards) ? scene.metadata.storyboards : [];
      const baseList = Array.isArray(scene.storyboards) ? scene.storyboards : [];
      const source = baseList.length ? baseList : metadataList;
      const seen = new Set();
      const sanitized = [];
      source.forEach(item => {
        let url = '';
        let id = '';
        let type = STORYBOARD_MEDIA_IMAGE;
        if (typeof item === 'string'){
          url = item.trim();
        } else if (item && typeof item === 'object'){
          const rawUrl = typeof item.url === 'string' ? item.url : item.image_url;
          url = typeof rawUrl === 'string' ? rawUrl.trim() : '';
          id = item.id;
          const rawType = typeof item.type === 'string' ? item.type : item.media_type;
          if (rawType === STORYBOARD_MEDIA_VIDEO) type = STORYBOARD_MEDIA_VIDEO;
        }
        if (!url) return;
        if (!id || seen.has(id)){
          id = randomId();
        }
        seen.add(id);
        sanitized.push({ id, url, type });
      });
      sanitized.forEach((entry, idx) => { entry.position = idx; });
      scene.storyboards = sanitized;
    }

    function refreshStoryboardPositions(scene){
      if (!scene || !Array.isArray(scene.storyboards)) return;
      const filtered = [];
      scene.storyboards.forEach(entry => {
        if (!entry || typeof entry.url !== 'string') return;
        const trimmed = entry.url.trim();
        if (!trimmed) return;
        if (!entry.id) entry.id = randomId();
        entry.url = trimmed;
        entry.type = entry.type === STORYBOARD_MEDIA_VIDEO ? STORYBOARD_MEDIA_VIDEO : STORYBOARD_MEDIA_IMAGE;
        filtered.push(entry);
      });
      filtered.forEach((entry, idx) => { entry.position = idx; });
      if (filtered.length !== scene.storyboards.length || filtered.some((entry, idx) => scene.storyboards[idx] !== entry)){
        scene.storyboards.splice(0, scene.storyboards.length, ...filtered);
      }
    }

    function getSceneStoryboards(scene, mediaType = null){
      if (!scene || !Array.isArray(scene.storyboards)) return [];
      refreshStoryboardPositions(scene);
      const entries = scene.storyboards.map(entry => ({
        id: entry.id,
        url: entry.url,
        position: entry.position,
        type: entry.type === STORYBOARD_MEDIA_VIDEO ? STORYBOARD_MEDIA_VIDEO : STORYBOARD_MEDIA_IMAGE
      }));
      if (!mediaType || !STORYBOARD_MEDIA_MODES.includes(mediaType)) return entries;
      return entries.filter(entry => entry.type === mediaType);
    }

    function sanitizeStoryboardStateForComparison(scene){
      return getSceneStoryboards(scene).map(entry => ({ id: entry.id, url: entry.url, position: entry.position, type: entry.type }));
    }

    function sanitizeStoryboardRowForComparison(rows){
      return sanitizeStoryboardRowList(rows);
    }

    function isTableMissingError(error){
      if (!error) return false;
      if (error.code === '42P01') return true;
      return typeof error.message === 'string' && error.message.includes('42P01');
    }

    /* =========================
     * Script library & dialog
     * =======================*/
    const DEFAULT_SCRIPT_IMAGE = 'https://placehold.co/240x160?text=Script';
    const DEFAULT_STORYBOARD_IMAGE = 'https://placehold.co/480x270?text=Storyboard';

    function getCoverImageUrl(){
      if (!project || !project.settings) return '';
      const raw = project.settings.coverImageUrl;
      return typeof raw === 'string' ? raw.trim() : '';
    }

    function updateCurrentCoverPreview(url){
      const normalized = (url || '').trim();
      const preview = document.getElementById('scriptDialogCurrentCoverPreview');
      const img = document.getElementById('scriptDialogCurrentCoverImage');
      const source = normalized || DEFAULT_SCRIPT_IMAGE;
      if (img){
        img.src = source;
        img.alt = normalized ? 'Current script title artwork' : 'Current script title artwork placeholder';
      }
      if (preview){
        preview.dataset.empty = normalized ? 'false' : 'true';
      }
    }

    function getStoryboardPlaceholderImage(){
      const cover = getCoverImageUrl();
      return cover || DEFAULT_STORYBOARD_IMAGE;
    }

    let scriptOptionsCache = null;
    let scriptOptionsStatus = '';
    let scriptDialogSelectedId = null;
    let scriptDialogLoading = false;
    let scriptDialogSaving = false;
    let scriptDialogCreating = false;

    function updateCachedCoverImage(url){
      if (!Array.isArray(scriptOptionsCache) || !project) return;
      const normalized = url ? url : DEFAULT_SCRIPT_IMAGE;
      const ids = new Set([project.libraryEntryId, project.projectId].filter(Boolean));
      scriptOptionsCache = scriptOptionsCache.map(entry => {
        if (!entry) return entry;
        const matches = ids.has(entry.id) || ids.has(entry.project_id) || ids.has(entry.script_id);
        if (!matches) return entry;
        return Object.assign({}, entry, { image_url: normalized });
      });
    }

    async function getScriptOptions(force = false){
      if (scriptOptionsCache && !force){
        scriptOptionsStatus = '';
        return scriptOptionsCache;
      }
      scriptOptionsStatus = '';
      let options = [];
      const supabase = window.supabaseClient;
      if (!supabase){
        scriptOptionsStatus = 'Connect Supabase to browse your saved scripts.';
        scriptOptionsCache = null;
        return [];
      }
      try {
        const { data, error } = await supabase
          .from('project_data')
          .select('id, project_id, script_id, script_name, name, title, description, summary, image_url, thumbnail_url');
        if (error) throw error;
        options = (Array.isArray(data) ? data : []).map(row => {
          const id = row.id || row.project_id || row.script_id || null;
          if (!id) return null;
          const name = row.script_name || row.name || row.title || 'Untitled Script';
          return {
            id,
            project_id: row.project_id || null,
            script_id: row.script_id || null,
            name,
            description: row.description || row.summary || '',
            image_url: row.image_url || row.thumbnail_url || DEFAULT_SCRIPT_IMAGE
          };
        }).filter(Boolean);
        options.sort((a, b) => {
          return a.name.localeCompare(b.name, undefined, { sensitivity: 'base' });
        });
        if (!options.length){
          scriptOptionsStatus = 'No scripts found yet. Save a script to Supabase to load it here.';
        }
      } catch (err){
        console.warn('Script metadata fetch failed:', err);
        scriptOptionsStatus = 'Unable to load scripts from Supabase.';
        scriptOptionsCache = null;
        return [];
      }
      scriptOptionsCache = options.length ? options : null;
      return options;
    }

    async function fetchScriptById(scriptId){
      if (!scriptId) return null;
      const supabase = window.supabaseClient;
      if (!supabase){
        console.warn('Supabase client is required to fetch scripts.');
        return null;
      }
      try {
        const filters = [`id.eq.${scriptId}`];
        filters.push(`project_id.eq.${scriptId}`);
        filters.push(`script_id.eq.${scriptId}`);
        const { data, error } = await supabase
          .from('project_data')
          .select('id, project_id, script_id, project_json, project, script, payload, data, name, script_name, title, description, summary')
          .or(filters.join(','))
          .maybeSingle();
        if (error) throw error;
        const payload = data?.project_json ?? data?.project ?? data?.script ?? data?.payload ?? data?.data;
        if (payload){
          if (typeof payload === 'string'){
            try { return JSON.parse(payload); }
            catch (err){ console.warn('Failed to parse script payload from Supabase', err); }
          } else if (typeof payload === 'object'){
            return payload;
          }
        }
        if (data){
          const clone = Object.assign({}, data);
          delete clone.project_json;
          delete clone.project;
          delete clone.script;
          delete clone.payload;
          delete clone.data;
          if (clone.scenes){
            return clone;
          }
        }
      } catch (err){
        console.warn('Script fetch failed:', err);
      }
      return null;
    }

    function updateScriptDialogLoadState(){
      const loadBtn = document.getElementById('scriptDialogLoad');
      const saveBtn = document.getElementById('scriptDialogSave');
      const createBtn = document.getElementById('scriptDialogCreate');
      const newTitleInput = document.getElementById('scriptDialogNewTitle');
      const coverInput = document.getElementById('scriptDialogCoverUrl');
      const coverApplyBtn = document.getElementById('scriptDialogApplyCover');
      const coverClearBtn = document.getElementById('scriptDialogClearCover');
      const newCoverInput = document.getElementById('scriptDialogNewCoverUrl');
      const busy = scriptDialogLoading || scriptDialogSaving || scriptDialogCreating;
      if (loadBtn){
        const disable = !scriptDialogSelectedId || (project && scriptDialogSelectedId === project.projectId);
        loadBtn.disabled = disable || busy;
        if (scriptDialogLoading){
          loadBtn.textContent = 'Loading‚Ä¶';
        } else if (scriptDialogSaving || scriptDialogCreating){
          loadBtn.textContent = 'Please wait‚Ä¶';
        } else if (!scriptDialogSelectedId){
          loadBtn.textContent = 'Select a script';
        } else if (disable && scriptDialogSelectedId === project?.projectId){
          loadBtn.textContent = 'Current Script';
        } else {
          loadBtn.textContent = 'Save & Load';
        }
      }
      if (saveBtn){
        saveBtn.disabled = busy;
        saveBtn.textContent = scriptDialogSaving ? 'Saving‚Ä¶' : 'Save';
      }
      if (newTitleInput){
        newTitleInput.disabled = scriptDialogLoading || scriptDialogSaving || scriptDialogCreating;
      }
      if (coverInput){
        coverInput.disabled = scriptDialogLoading;
      }
      if (createBtn){
        const hasTitle = Boolean(newTitleInput && newTitleInput.value.trim());
        createBtn.disabled = busy || !hasTitle;
        createBtn.textContent = scriptDialogCreating ? 'Creating‚Ä¶' : 'Create';
      }
      if (coverApplyBtn){
        coverApplyBtn.disabled = busy;
      }
      if (coverClearBtn){
        coverClearBtn.disabled = busy;
      }
      if (newCoverInput){
        newCoverInput.disabled = scriptDialogLoading || scriptDialogSaving || scriptDialogCreating;
      }
    }

    function updateScriptPreview(scriptId){
      scriptDialogSelectedId = scriptId || null;
      const options = scriptOptionsCache || [];
      const meta = options.find(opt => opt.id === scriptId) || null;
      const titleEl = document.getElementById('scriptPreviewName');
      const descEl = document.getElementById('scriptPreviewDescription');
      const imgEl = document.getElementById('scriptPreviewImage');
      const coverUrl = getCoverImageUrl();
      const defaultImage = coverUrl || DEFAULT_SCRIPT_IMAGE;
      if (meta){
        if (titleEl) titleEl.textContent = meta.name || 'Untitled Script';
        if (descEl) descEl.textContent = meta.description || 'Ready when you are.';
        const isCurrentScript = Boolean(project) && (
          meta.id === project.projectId ||
          meta.project_id === project.projectId ||
          meta.script_id === project.projectId ||
          (project.libraryEntryId && meta.id === project.libraryEntryId)
        );
        const previewImage = (isCurrentScript && coverUrl) ? coverUrl : (meta.image_url || defaultImage);
        if (imgEl) imgEl.src = previewImage || DEFAULT_SCRIPT_IMAGE;
      } else {
        if (titleEl) titleEl.textContent = 'Select a script';
        if (descEl) descEl.textContent = '';
        if (imgEl) imgEl.src = defaultImage;
      }
      updateCurrentCoverPreview(getCoverImageUrl());
      updateScriptDialogLoadState();
    }

    async function openScriptDialog(){
      const dialog = document.getElementById('scriptDialog');
      if (!dialog || dialog.classList.contains('open')) return;
      dialog.classList.add('open');
      dialog.setAttribute('aria-hidden', 'false');
      document.body.classList.add('script-dialog-open');
      const currentNameEl = document.getElementById('scriptDialogCurrentName');
      if (currentNameEl) currentNameEl.textContent = project?.title || 'Untitled Script';
      const currentTitleInput = document.getElementById('scriptDialogCurrentTitle');
      if (currentTitleInput) currentTitleInput.value = project?.title || '';
      const coverInput = document.getElementById('scriptDialogCoverUrl');
      if (coverInput) coverInput.value = getCoverImageUrl();
      updateCurrentCoverPreview(getCoverImageUrl());
      const select = document.getElementById('scriptSelect');
      const status = document.getElementById('scriptDialogStatus');
      if (status) status.textContent = 'Loading scripts‚Ä¶';
      if (select){
        select.innerHTML = '';
        select.disabled = true;
      }
      scriptDialogSaving = false;
      scriptDialogCreating = false;
      const newTitleInput = document.getElementById('scriptDialogNewTitle');
      if (newTitleInput){
        newTitleInput.value = '';
      }
      const newCoverInput = document.getElementById('scriptDialogNewCoverUrl');
      if (newCoverInput){
        newCoverInput.value = '';
      }
      scriptDialogSelectedId = null;
      updateScriptPreview('');
      scriptDialogLoading = true;
      updateScriptDialogLoadState();
      try {
        const options = await getScriptOptions();
        if (select){
          const frag = document.createDocumentFragment();
          options.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt.id;
            option.textContent = opt.name || 'Untitled Script';
            frag.appendChild(option);
          });
          select.appendChild(frag);
          select.disabled = !options.length;
          const initial = (()=>{
            if (!options.length) return '';
            const different = options.find(opt => opt.id !== project?.projectId);
            return (different || options[0]).id;
          })();
          if (initial){
            select.value = initial;
          }
          updateScriptPreview(select.value || '');
        } else {
          updateScriptPreview('');
        }
        if (status) status.textContent = scriptOptionsStatus || (options.length ? '' : 'No scripts available yet.');
      } catch (err){
        console.warn(err);
        if (status) status.textContent = scriptOptionsStatus || 'Unable to load scripts right now.';
        updateScriptPreview('');
      } finally {
        scriptDialogLoading = false;
        updateScriptDialogLoadState();
      }
      setTimeout(()=>{
        if (select && !select.disabled) select.focus();
      }, 0);
    }

    function closeScriptDialog(){
      const dialog = document.getElementById('scriptDialog');
      if (!dialog) return;
      dialog.classList.remove('open');
      dialog.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('script-dialog-open');
      scriptDialogSelectedId = null;
      scriptDialogLoading = false;
      scriptDialogSaving = false;
      scriptDialogCreating = false;
      const status = document.getElementById('scriptDialogStatus');
      if (status) status.textContent = '';
      const newTitleInput = document.getElementById('scriptDialogNewTitle');
      if (newTitleInput) newTitleInput.value = '';
      const newCoverInput = document.getElementById('scriptDialogNewCoverUrl');
      if (newCoverInput) newCoverInput.value = '';
      updateScriptDialogLoadState();
    }

    async function handleScriptLoad(){
      const select = document.getElementById('scriptSelect');
      if (!select) return;
      const scriptId = select.value;
      if (!scriptId || (project && scriptId === project.projectId)){
        closeScriptDialog();
        return;
      }
      const confirmed = window.confirm('Save your current script before loading a new one? This ensures you do not lose any work.');
      if (!confirmed) return;
      try { syncActiveScene(false); } catch(e){}
      try {
        await saveLocal(project);
      } catch (err){
        console.error('Failed to save current script before switching:', err);
        alert('Saving the current script failed. Please try again before switching.');
        return;
      }
      scriptDialogLoading = true;
      updateScriptDialogLoadState();
      try {
        const data = await fetchScriptById(scriptId);
        if (!data){
          alert('Unable to load that script right now. Please try again later.');
          return;
        }
        const meta = (scriptOptionsCache || []).find(opt => opt.id === scriptId) || {};
        await applyLoadedProject(data, meta);
        closeScriptDialog();
      } catch (err){
        console.error('Script load failed:', err);
        alert('Loading the selected script failed. Please try again.');
      } finally {
        scriptDialogLoading = false;
        updateScriptDialogLoadState();
      }
    }

    function buildProjectLibraryPayload(){
      if (!project) return null;
      const payload = cloneValue(project);
      if (!payload || typeof payload !== 'object') return null;
      delete payload._hashes;
      delete payload._lastBackedUpVersion;
      delete payload._deltaCountSinceFull;
      delete payload._pomoState;
      delete payload.libraryEntryId;
      return payload;
    }

    async function saveScriptToLibrary(supabase, ownerId){
      if (!supabase) throw new Error('Supabase client unavailable');
      if (!ownerId) throw new Error('Owner ID required');
      if (!project) throw new Error('No project loaded');
      ensureProjectShape();
      const payload = buildProjectLibraryPayload();
      if (!payload) throw new Error('Nothing to save');
      const scriptName = (project.title || '').trim() || 'Untitled Script';
      const description = typeof project.notes === 'string' ? project.notes : '';
      const coverUrl = getCoverImageUrl();
      const record = {
        owner_id: ownerId,
        project_id: project.projectId,
        script_id: project.projectId,
        script_name: scriptName,
        name: scriptName,
        title: scriptName,
        description,
        summary: description,
        project_json: payload,
        updated_at: new Date().toISOString()
      };
      if (coverUrl){
        record.image_url = coverUrl;
        record.thumbnail_url = coverUrl;
      } else {
        record.image_url = null;
        record.thumbnail_url = null;
      }
      if (project.libraryEntryId){
        record.id = project.libraryEntryId;
      }
      const { data, error } = await supabase
        .from('project_data')
        .upsert(record, { onConflict: 'id' })
        .select('id, script_name, description, image_url, thumbnail_url')
        .maybeSingle();
      if (error) throw error;
      const savedId = data?.id || record.id || project.libraryEntryId || project.projectId;
      project.libraryEntryId = savedId;
      const libraryImage = coverUrl || data?.image_url || data?.thumbnail_url || DEFAULT_SCRIPT_IMAGE;
      const entry = {
        id: savedId,
        name: record.script_name || 'Untitled Script',
        description: data?.description ?? record.description ?? '',
        image_url: libraryImage
      };
      if (Array.isArray(scriptOptionsCache)){
        const next = scriptOptionsCache.slice();
        const idx = next.findIndex(opt => opt.id === entry.id);
        if (idx >= 0){
          next[idx] = Object.assign({}, next[idx], entry);
        } else {
          next.push(entry);
        }
        next.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
        scriptOptionsCache = next;
      } else {
        scriptOptionsCache = [entry];
      }
      scriptOptionsStatus = '';
      return entry;
    }

    async function handleScriptDialogSave(){
      if (!project){
        return { success: false, reason: 'no_project' };
      }
      const status = document.getElementById('scriptDialogStatus');
      try { syncActiveScene(false); } catch(e){}
      try { await saveLocal(project); } catch (err){ console.error('Failed to persist script locally before saving to library:', err); }
      const supabase = window.supabaseClient;
      if (!supabase){
        if (status) status.textContent = 'Supabase is still initializing. Please try again.';
        return { success: false, reason: 'supabase_unavailable' };
      }
      scriptDialogSaving = true;
      updateScriptDialogLoadState();
      if (status) status.textContent = 'Saving script‚Ä¶';
      let outcome = { success: false, reason: 'unknown' };
      try {
        const session = await getSupabaseSession(supabase);
        if (!session || !session.user){
          if (status) status.textContent = 'Sign in to save scripts to your library.';
          alert('Sign in to save scripts to your library.');
          outcome = { success: false, reason: 'auth_required' };
        } else {
          const entry = await saveScriptToLibrary(supabase, session.user.id);
          if (status) status.textContent = 'Saved to your library.';
          if (entry?.id){
            lastSerializedMetaHash = metaSignature(project);
            scriptDialogSelectedId = entry.id;
            const select = document.getElementById('scriptSelect');
            if (select){
              let option = Array.from(select.options).find(opt => opt.value === entry.id);
              if (!option){
                option = document.createElement('option');
                option.value = entry.id;
                option.textContent = entry.name || 'Untitled Script';
                select.appendChild(option);
              } else {
                option.textContent = entry.name || option.textContent;
              }
              select.value = entry.id;
            }
            updateScriptPreview(entry.id);
          }
          outcome = { success: true };
        }
      } catch (err){
        console.error('Saving script to library failed:', err);
        if (status) status.textContent = 'Saving failed. Please try again.';
        alert('Saving your script failed. Please try again.');
        outcome = { success: false, reason: 'error' };
      } finally {
        scriptDialogSaving = false;
        updateScriptDialogLoadState();
      }
      return outcome;
    }

    async function handleScriptDialogCreate(){
      const input = document.getElementById('scriptDialogNewTitle');
      const status = document.getElementById('scriptDialogStatus');
      const rawTitle = input ? input.value.trim() : '';
      const newCoverInput = document.getElementById('scriptDialogNewCoverUrl');
      const rawCover = newCoverInput ? newCoverInput.value.trim() : '';
      let normalizedCover = '';
      if (!rawTitle){
        if (status) status.textContent = 'Enter a title to create a new script.';
        if (input) input.focus();
        return;
      }
      if (rawCover){
        const parsedCover = normalizeStoryboardUrl(rawCover);
        if (!parsedCover){
          if (status) status.textContent = 'Enter a valid image URL for the new script cover, or leave it blank.';
          alert('Enter a valid image URL (including http:// or https://) for the new script cover, or leave it blank.');
          if (newCoverInput) newCoverInput.focus();
          return;
        }
        normalizedCover = parsedCover;
      }
      const confirmed = window.confirm('Create a new script? Your current work will be saved locally first.');
      if (!confirmed) return;
      try { syncActiveScene(false); } catch(e){}
      try { await saveLocal(project); } catch (err){ console.error('Failed to save current script before creating a new one:', err); }
      scriptDialogCreating = true;
      updateScriptDialogLoadState();
      if (status) status.textContent = 'Creating new script‚Ä¶';
      try {
        newProject();
        project.title = rawTitle;
        project.libraryEntryId = null;
        ensureProjectShape();
        setProjectCoverImage(normalizedCover);
        ensurePomodoroSettings();
        activeSceneId = project.scenes?.[0]?.id || null;
        render();
        applyFocusModeUI();
        updatePomodoroUI();
        await saveLocal(project);
        lastSerializedMetaHash = metaSignature(project);
        scheduleBackup();
        closeScriptDialog();
      } catch (err){
        console.error('New script creation failed:', err);
        if (status) status.textContent = 'Unable to create a new script. Please try again.';
        alert('Creating a new script failed. Please try again.');
      } finally {
        scriptDialogCreating = false;
        updateScriptDialogLoadState();
      }
    }

    async function applyLoadedProject(nextProject, meta = {}){
      if (!nextProject || typeof nextProject !== 'object'){
        throw new Error('Invalid project payload');
      }
      const loaded = cloneValue(nextProject);
      loaded.projectId = loaded.projectId || meta.id || randomId();
      loaded.title = loaded.title || meta.name || 'Untitled Script';
      loaded.format = loaded.format || 'screenplay/v1';
      loaded.createdAt = loaded.createdAt || Date.now();
      loaded.updatedAt = Date.now();
      loaded.version = typeof loaded.version === 'number' ? loaded.version : 1;
      loaded.libraryEntryId = loaded.libraryEntryId || meta.id || null;
      if (typeof loaded.notes !== 'string' && meta.description){
        loaded.notes = meta.description;
      }
      project = loaded;
      ensureProjectShape();
      if (!project.settings.coverImageUrl){
        const metaCover = typeof meta.image_url === 'string' ? meta.image_url : (typeof meta.thumbnail_url === 'string' ? meta.thumbnail_url : '');
        const normalizedMetaCover = metaCover ? normalizeStoryboardUrl(metaCover) : null;
        if (normalizedMetaCover) project.settings.coverImageUrl = normalizedMetaCover;
      }
      updateCachedCoverImage(project.settings.coverImageUrl);
      project.scenes = Array.isArray(project.scenes) ? project.scenes : [];
      project.scenes.forEach(scene => {
        if (!scene.id) scene.id = randomId();
        if (!Array.isArray(scene.cards)) scene.cards = [];
        if (!Array.isArray(scene.elements)) scene.elements = [];
        if (!Array.isArray(scene.sounds)) scene.sounds = [];
      });
      storyboardIndexState.clear();
      project.scenes.forEach(scene => {
        STORYBOARD_MEDIA_MODES.forEach(mode => setStoryboardIndex(scene.id, 0, mode));
      });
      project._hashes = { scene: {} };
      project.scenes.forEach(scene => {
        project._hashes.scene[scene.id] = hashString(stableSceneString(scene));
      });
      project._lastBackedUpVersion = project.version || 0;
      project._deltaCountSinceFull = 0;
      project._pomoState = null;
      activeSceneId = project.scenes?.[0]?.id || null;
      setLastProjectId(project.projectId);
      ensurePomodoroSettings();
      closeTimelineMode();
      closeStoryboardMode();
      timelineInsertIndex = project.scenes.length;
      lastSerializedMetaHash = metaSignature(project);
      render();
      applyTheme();
      applyFocusModeUI();
      updatePomodoroUI();
      updateHud();
      updateTimelineButton();
      markActiveLine();
      try {
        await saveLocal(project);
      } catch (err){
        console.error('Failed to persist loaded script locally:', err);
      }
      scheduleBackup();
    }

    function normalizeForComparison(value){
      if (Array.isArray(value)) return value.map(normalizeForComparison);
      if (value && typeof value === 'object'){
        const sorted = {};
        Object.keys(value).sort().forEach(key => {
          sorted[key] = normalizeForComparison(value[key]);
        });
        return sorted;
      }
      return value;
    }

    function scenesMatch(a, b){
      if (!a || !b) return false;
      return JSON.stringify(normalizeForComparison(a)) === JSON.stringify(normalizeForComparison(b));
    }

    function setSaveSceneStatus(state, message){
      const el = document.getElementById('saveSceneStatus');
      if (!el) return;
      if (saveSceneStatusTimer){
        clearTimeout(saveSceneStatusTimer);
        saveSceneStatusTimer = null;
      }
      if (!state){
        el.textContent = '';
        el.dataset.state = '';
        el.hidden = true;
        return;
      }
      el.hidden = false;
      el.dataset.state = state;
      el.textContent = message || '';
      if (state === 'success'){
        saveSceneStatusTimer = setTimeout(()=>{
          if (el.dataset.state === 'success'){
            el.textContent = '';
            el.dataset.state = '';
            el.hidden = true;
          }
        }, 3000);
      }
    }

    const RIGHT_TAB_KEY = 'SW_RIGHT_TAB';
    let activeRightTab = (()=>{
      try { return localStorage.getItem(RIGHT_TAB_KEY) || 'write'; }
      catch(e){ return 'write'; }
    })();

    /* =========================
     * Hashing (FNV-1a) & helpers
     * =======================*/
    function hashString(str) {
      let h = 2166136261 >>> 0;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return (h >>> 0).toString(16);
    }
    function stableSceneString(s){
      const colorMeta = getSceneColorMeta(s);
      return JSON.stringify({
        id: s.id,
        slug: s.slug,
        elements: s.elements,
        color: colorMeta.color,
        colorSource: s.colorSource || SCENE_COLOR_SOURCE_AUTO,
        notes: s.notes,
        sounds: s.sounds,
        storyboards: s.storyboards,
        tags: getSceneTagState(s)
      });
    }
    function metaSignature(p){
      return JSON.stringify({ title:p.title, notes:p.notes, settings:p.settings });
    }

    function ensureProjectShape(){
      project.settings = project.settings || {};
      if (typeof project.settings.coverImageUrl !== 'string') project.settings.coverImageUrl = '';
      else project.settings.coverImageUrl = project.settings.coverImageUrl.trim();
      if (typeof project.libraryEntryId === 'undefined') project.libraryEntryId = null;
      if (!project.settings.theme){
        const globalTheme = (typeof window.getSiteTheme === 'function') ? window.getSiteTheme() : (document.documentElement.dataset.theme || 'dark');
        project.settings.theme = globalTheme || 'dark';
      }
      if (project.settings.scriptViewMode !== 'scroll' && project.settings.scriptViewMode !== 'pages'){
        project.settings.scriptViewMode = 'scroll';
      }
      if (typeof project.settings.scriptViewPage !== 'number' || !isFinite(project.settings.scriptViewPage)){
        project.settings.scriptViewPage = 0;
      }
      if (typeof project.settings.timelineDockPinned !== 'boolean'){
        project.settings.timelineDockPinned = true;
      }
      project.catalogs = project.catalogs || {};
      project.catalogs.characters = (project.catalogs.characters || []).map(item => {
        if (typeof item === 'string') return normalizeCharacter({ id: randomId(), name: item });
        const normalized = normalizeCharacter(item);
        if (!normalized.id) normalized.id = randomId();
        return normalized;
      });
      project.catalogs.locations = (project.catalogs.locations || []).map(item => {
        if (typeof item === 'string') return { id: randomId(), name: item };
        if (!item || typeof item !== 'object') return { id: randomId(), name: '' };
        if (!item.id) item.id = randomId();
        item.name = typeof item.name === 'string' ? item.name : '';
        return item;
      });
      project.scenes = (project.scenes || []).map(scene => {
        if (!scene || typeof scene !== 'object') scene = {};
        if (!Array.isArray(scene.cards)) scene.cards = [];
        if (!Array.isArray(scene.elements)) scene.elements = [];
        scene.elements = scene.elements.map(normalizeSceneElement);
        if (!scene.elements.length){
          scene.elements = [createSceneElement('action', '...')];
        }
        scene.sounds = (scene.sounds || []).map(sound => {
          if (typeof sound === 'string') return { id: randomId(), cue: sound };
          if (!sound || typeof sound !== 'object') return { id: randomId(), cue: '' };
          if (!sound.id) sound.id = randomId();
          sound.cue = typeof sound.cue === 'string' ? sound.cue : '';
          return sound;
        });
        if (!scene.metadata || typeof scene.metadata !== 'object') scene.metadata = {};
        const normalizedColor = normalizeSceneColor(scene.color);
        const rawSource = typeof scene.colorSource === 'string' ? scene.colorSource : scene.metadata.sceneColorSource;
        let source = (rawSource === SCENE_COLOR_SOURCE_CUSTOM || rawSource === SCENE_COLOR_SOURCE_AUTO) ? rawSource : null;
        if (!source){
          source = normalizedColor !== DEFAULT_SCENE_COLOR ? SCENE_COLOR_SOURCE_CUSTOM : SCENE_COLOR_SOURCE_AUTO;
        }
        scene.colorSource = source;
        scene.color = normalizedColor;
        scene.metadata.sceneColorSource = scene.colorSource;
        ensureSceneStoryboardStructure(scene);
        refreshStoryboardPositions(scene);
        return scene;
      });
      project.scenes.forEach(scene => {
        STORYBOARD_MEDIA_MODES.forEach(mode => {
          clampStoryboardIndex(scene, mode);
        });
      });
      const validIds = new Set(project.scenes.map(scene => scene.id));
      Array.from(storyboardIndexState.keys()).forEach(key => {
        const [sceneId, mode] = key.split(STORYBOARD_INDEX_DELIMITER);
        if (!validIds.has(sceneId) || (mode && !STORYBOARD_MEDIA_MODES.includes(mode))){
          storyboardIndexState.delete(key);
        }
      });
    }

    function setRightTab(tab){
      const allowed = ['write','characters','set','sound','timeline','stats'];
      activeRightTab = allowed.includes(tab) ? tab : 'write';
      try { localStorage.setItem(RIGHT_TAB_KEY, activeRightTab); } catch(e){}
      applyActiveTabUI();
    }

    function applyActiveTabUI(){
      const allowed = ['write','characters','set','sound','timeline','stats'];
      if (!allowed.includes(activeRightTab)) activeRightTab = 'write';
      document.querySelectorAll('[data-tab-btn]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tabBtn === activeRightTab);
      });
      document.querySelectorAll('.tab-panel').forEach(panel => {
        panel.classList.toggle('active', panel.dataset.tab === activeRightTab);
      });
    }

    function setupSaveMenu(){
      const menu = document.getElementById('saveMenu');
      const toggle = document.getElementById('saveSceneBtn');
      if (!menu || !toggle) return;
      const list = document.getElementById('saveMenuList');
      if (!list) return;

      const setOpen = (open)=>{
        menu.classList.toggle('open', open);
        toggle.setAttribute('aria-expanded', open ? 'true' : 'false');
      };

      list.addEventListener('click', e=>{
        e.stopPropagation();
      });

      toggle.addEventListener('click', e=>{
        e.stopPropagation();
        setOpen(!menu.classList.contains('open'));
      });

      const setSaveButtonsDisabled = (disabled)=>{
        ['saveSceneMenuAction', 'saveSceneCloseAction'].forEach(id=>{
          const button = document.getElementById(id);
          if (button) button.disabled = !!disabled;
        });
      };

      const setSaveFailureStatus = (reason)=>{
        if (reason === 'supabase_unavailable') setSaveSceneStatus('error', 'Supabase unavailable');
        else if (reason === 'no_project') setSaveSceneStatus('error', 'Nothing to save');
        else if (reason === 'auth_required') setSaveSceneStatus('error', 'Sign in required');
        else setSaveSceneStatus('error', 'Save failed. Please try again.');
      };

      const runSaveFlow = async (onSuccess)=>{
        setSaveButtonsDisabled(true);
        setSaveSceneStatus('saving', 'Saving‚Ä¶');
        try {
          const result = await handleScriptDialogSave();
          if (result && result.success){
            if (typeof onSuccess === 'function'){
              await onSuccess(result);
            } else {
              setSaveSceneStatus('success', 'Saved!');
            }
            return result;
          }
          setSaveFailureStatus(result ? result.reason : 'error');
          return result || { success: false, reason: 'error' };
        } catch (saveError){
          console.error('Save menu action failed:', saveError);
          setSaveSceneStatus('error', 'Save failed. Please try again.');
          return { success: false, reason: 'error' };
        } finally {
          setSaveButtonsDisabled(false);
        }
      };

      menu.querySelectorAll('[data-save-action]').forEach(btn=>{
        btn.addEventListener('click', async e=>{
          e.stopPropagation();
          const action = btn.dataset.saveAction;
          setOpen(false);
          if (action === 'save'){
            await runSaveFlow();
          } else if (action === 'save-close'){
            await runSaveFlow(()=>{
              setSaveSceneStatus('success', 'Saved! Redirecting‚Ä¶');
              window.location.href = '/account.html';
            });
          } else if (action === 'backup') backupNow();
          else if (action === 'restore') openRestore();
        });
      });

      document.addEventListener('click', e=>{
        if (!menu.contains(e.target)) setOpen(false);
      });

      document.addEventListener('keydown', e=>{
        if (e.key === 'Escape') setOpen(false);
      });
    }

    function setupExportMenu(){
      const menu = document.getElementById('exportMenu');
      const toggle = document.getElementById('exportMenuButton');
      if (!menu || !toggle) return;
      const list = document.getElementById('exportMenuList');
      if (!list) return;

      const setOpen = (open)=>{
        menu.classList.toggle('open', open);
        toggle.setAttribute('aria-expanded', open ? 'true' : 'false');
      };

      toggle.addEventListener('click', e=>{
        e.stopPropagation();
        setOpen(!menu.classList.contains('open'));
      });

      menu.querySelectorAll('[data-export-action]').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const action = btn.dataset.exportAction;
          setOpen(false);
          if (action === 'fountain') exportFountain();
          else if (action === 'pdf') printPDF();
        });
      });

      document.addEventListener('click', e=>{
        if (!menu.contains(e.target)) setOpen(false);
      });

      document.addEventListener('keydown', e=>{
        if (e.key === 'Escape') setOpen(false);
      });
    }

    function setStoryboardMenuOpen(open){
      const menu = document.getElementById('storyboardMenu');
      const toggle = document.getElementById('storyboardMenuButton');
      if (!menu || !toggle) return;
      menu.classList.toggle('open', open);
      toggle.setAttribute('aria-expanded', open ? 'true' : 'false');
    }

    function setupStoryboardMenu(){
      const menu = document.getElementById('storyboardMenu');
      const toggle = document.getElementById('storyboardMenuButton');
      if (!menu || !toggle) return;
      const list = document.getElementById('storyboardMenuList');
      if (!list) return;

      list.addEventListener('click', e=>{
        e.stopPropagation();
      });

      toggle.addEventListener('click', e=>{
        e.stopPropagation();
        setStoryboardMenuOpen(!menu.classList.contains('open'));
      });

      const liteBtn = document.getElementById('storyboardModeBtn');
      if (liteBtn){
        liteBtn.addEventListener('click', ()=> setStoryboardMenuOpen(false));
      }

      const proLink = document.getElementById('storyboardProLink');
      if (proLink){
        proLink.addEventListener('click', ()=> setStoryboardMenuOpen(false));
      }

      document.addEventListener('click', e=>{
        if (!menu.contains(e.target)) setStoryboardMenuOpen(false);
      });

      document.addEventListener('keydown', e=>{
        if (e.key === 'Escape') setStoryboardMenuOpen(false);
      });
    }

    /* =========================
     * Project creation / load
     * =======================*/
    function getLastProjectId(){ try { return localStorage.getItem('SW_LAST_PROJECT_ID'); } catch(e){ return null; } }
    function setLastProjectId(id){ try { localStorage.setItem('SW_LAST_PROJECT_ID', id); } catch(e){} }

    function newProject(){
      const pid = randomId();
      project = {
        projectId: pid,
        title: 'Untitled Project',
        format: 'screenplay/v1',
        createdAt: Date.now(),
        updatedAt: Date.now(),
        version: 1,
        libraryEntryId: null,
        settings: {
          theme: (typeof window.getSiteTheme === 'function' ? window.getSiteTheme() : (document.documentElement.dataset.theme || 'dark')),
          smartFormat: true,
          coverImageUrl: '',
          pageWidth: 60,
          focus: false,
          timelineDockPinned: true,
          pomodoro: { workMin: 25, breakMin: 5, autoStartBreak: true, autoStartWork: false }
        },
        catalogs: { characters:[], locations:[] },
        scenes: [{
          id: randomId(),
          slug: 'INT. HOUSE - DAY',
          cards: ['Opening image'],
          elements: [{t:'action', txt:'A room. Quiet.'}],
          color: DEFAULT_SCENE_COLOR,
          colorSource: SCENE_COLOR_SOURCE_AUTO,
          notes: '',
          sounds: [],
          storyboards: [],
          metadata: { sceneColorSource: SCENE_COLOR_SOURCE_AUTO, sceneTagState: { locationType: '', timeOfDay: '', custom: [] } }
        }],
        notes: '',
        _hashes: { scene: {} },
        _pomoState: null,
        _lastBackedUpVersion: 0,
        _deltaCountSinceFull: 0
      };
      project.scenes.forEach(s => { project._hashes.scene[s.id] = hashString(stableSceneString(s)); });
      activeSceneId = project.scenes[0].id;
      scenePopoverOpenId = null;
      storyboardIndexState.clear();
      if (activeSceneId){
        STORYBOARD_MEDIA_MODES.forEach(mode => setStoryboardIndex(activeSceneId, 0, mode));
      }
      setLastProjectId(pid);
      lastTimelinePinned = null;
    }

    /* =========================
     * Rendering & UI
     * =======================*/
    function render(){
      ensureProjectShape();
      pruneStoryboardAIState();
      updateStoryboardModeUI();
      hideSelectionMenu();
      document.getElementById('title').textContent = project.title || 'Untitled Project';
      const dialogTitleInput = document.getElementById('scriptDialogCurrentTitle');
      if (dialogTitleInput) dialogTitleInput.value = project.title || '';
      const dialogCurrentName = document.getElementById('scriptDialogCurrentName');
      if (dialogCurrentName) dialogCurrentName.textContent = project.title || 'Untitled Script';
      document.getElementById('projectNotes').value = project.notes || '';
      const smartSel = document.getElementById('smartFormat');
      if (smartSel) smartSel.value = String(!!project.settings.smartFormat);
      project.settings.theme = project.settings.theme || (typeof window.getSiteTheme === 'function' ? window.getSiteTheme() : (document.documentElement.dataset.theme || 'dark'));
      const pinnedSetting = !!project.settings.timelineDockPinned;
      if (pinnedSetting !== lastTimelinePinned){
        syncTimelineDockState(true);
      }

      const storyArcSceneTrack = document.getElementById('storyArcSceneSlots');
      if (storyArcSceneTrack){
        storyArcSceneTrack.innerHTML = '';
        const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
        if (scenes.length){
          const collapseSceneLabels = scenes.length > 8;
          scenes.forEach((scene, index)=>{
            const li = document.createElement('li');
            li.className = 'story-arc-scenes__step' + (scene.id === activeSceneId ? ' story-arc-scenes__step--active' : '');
            li.setAttribute('role', 'listitem');
            const slot = document.createElement('div');
            slot.className = 'story-arc-scenes__slot' + (collapseSceneLabels ? ' story-arc-scenes__slot--compact' : '');
            slot.tabIndex = 0;
            slot.setAttribute('role', 'button');
            slot.setAttribute('aria-pressed', scene.id === activeSceneId ? 'true' : 'false');
            const numberSpan = document.createElement('span');
            numberSpan.className = 'story-arc-scenes__scene-number';
            const sceneNumberLabel = `Scene ${index + 1}`;
            numberSpan.textContent = collapseSceneLabels ? String(index + 1) : sceneNumberLabel;
            const labelSpan = document.createElement('span');
            labelSpan.className = 'story-arc-scenes__scene-label';
            const rawSlug = typeof scene?.slug === 'string' ? scene.slug.trim() : '';
            const fallbackTitle = typeof scene?.title === 'string' ? scene.title.trim() : '';
            const displayLabel = rawSlug || fallbackTitle || `Scene ${index + 1}`;
            if (collapseSceneLabels){
              labelSpan.textContent = '';
              labelSpan.hidden = true;
            } else {
              labelSpan.textContent = displayLabel;
            }
            labelSpan.title = displayLabel;
            const tooltipLabel = displayLabel && displayLabel !== sceneNumberLabel ? `${sceneNumberLabel} ‚Ä¢ ${displayLabel}` : sceneNumberLabel;
            slot.dataset.tooltip = tooltipLabel;
            slot.setAttribute('aria-label', tooltipLabel);
            slot.addEventListener('click', event => {
              event.preventDefault();
              event.stopPropagation();
              if (sceneDragSceneId) return;
              if (sceneInlineRenameId) return;
              let shouldRender = false;
              if (scenePopoverOpenId){
                scenePopoverOpenId = null;
                shouldRender = true;
              }
              if (activeSceneId !== scene.id){
                activeSceneId = scene.id;
                shouldRender = true;
              }
              if (shouldRender) render();
            });
            slot.addEventListener('keydown', event => {
              if (event.target !== slot) return;
              if (event.key === 'Enter' || event.key === ' '){
                event.preventDefault();
                slot.click();
              }
            });
            slot.appendChild(numberSpan);
            slot.appendChild(labelSpan);
            li.appendChild(slot);
            storyArcSceneTrack.appendChild(li);
          });
        } else {
          const emptyState = document.createElement('li');
          emptyState.className = 'story-arc-scenes__empty';
          emptyState.setAttribute('role', 'listitem');
          emptyState.textContent = 'Add scenes to build your timeline.';
          storyArcSceneTrack.appendChild(emptyState);
        }
      }

      // scenes list
      const list = document.getElementById('sceneList');
      list.innerHTML = '';
      list.classList.remove('drag-over-end');
      if (!list.dataset.sceneDragBound){
        list.addEventListener('dragover', handleSceneListDragOver);
        list.addEventListener('drop', handleSceneListDrop);
        list.addEventListener('dragleave', handleSceneListDragLeave);
        list.dataset.sceneDragBound = 'true';
      }
      if (scenePopoverOpenId && !project.scenes.some(scene => scene.id === scenePopoverOpenId)){
        cancelScenePopoverClickTimer();
        scenePopoverOpenId = null;
      }
      ensureScenePopoverDismissBound();
      const renameFocusTargets = [];
      project.scenes.forEach((s, idx)=>{
        const div = document.createElement('div');
        const isActive = s.id === activeSceneId;
        const isEditing = sceneInlineRenameId === s.id;
        div.className = 'scene-card' + (isActive ? ' active' : '') + (isEditing ? ' editing' : '');
        div.dataset.sceneId = s.id;
        div.dataset.index = String(idx);
        const colorMeta = getSceneColorMeta(s);
        div.dataset.colorSource = colorMeta.source;
        div.dataset.popoverOpen = scenePopoverOpenId === s.id ? 'true' : 'false';
        const rawSlug = typeof s.slug === 'string' ? s.slug : '';
        const slugDisplay = rawSlug.trim() ? rawSlug.trim() : '(no slug)';
        const sceneNumberLabel = `Scene ${idx+1}`;
        const accessibleLabel = rawSlug.trim() ? `${sceneNumberLabel} ‚Ä¢ ${slugDisplay}` : sceneNumberLabel;
        div.setAttribute('role', 'button');
        div.setAttribute('aria-label', accessibleLabel);
        div.tabIndex = 0;
        div.draggable = !isEditing;
        div.addEventListener('dragstart', handleSceneCardDragStart);
        div.addEventListener('dragend', handleSceneCardDragEnd);
        div.addEventListener('dragover', handleSceneCardDragOver);
        div.addEventListener('dragleave', handleSceneCardDragLeave);
        div.addEventListener('drop', handleSceneCardDrop);
        div.addEventListener('click', event => {
          event.stopPropagation();
          if (sceneDragSceneId) return;
          if (sceneInlineRenameId === s.id) return;
          let shouldRender = false;
          if (scenePopoverOpenId){
            scenePopoverOpenId = null;
            shouldRender = true;
          }
          if (activeSceneId !== s.id){
            activeSceneId = s.id;
            shouldRender = true;
          }
          if (shouldRender) render();
        });
        div.addEventListener('keydown', event => {
          if (event.target !== div) return;
          if (event.key === 'F2'){
            event.preventDefault();
            beginSceneInlineRename(s.id);
            return;
          }
          if (sceneInlineRenameId === s.id) return;
          if (event.key === 'Enter' || event.key === ' '){
            event.preventDefault();
            if (sceneDragSceneId) return;
            let shouldRender = false;
            if (scenePopoverOpenId){
              scenePopoverOpenId = null;
              shouldRender = true;
            }
            if (activeSceneId !== s.id){
              activeSceneId = s.id;
              shouldRender = true;
            }
            if (shouldRender) render();
          }
        });
        const colorTitle = colorMeta.tooltip || colorMeta.description || 'Scene color';
        const colorBorder = hexToRgba(colorMeta.textColor, 0.35);
        const tags = getSceneNameTags(s);
        const tagsHtml = tags.length
          ? tags.map(tag => `<span class="scene-card-tag">${escapeHtml(tag)}</span>`).join('')
          : '<span class="scene-card-tag scene-card-tag--empty">Add scene tags</span>';
        div.innerHTML = `
          <div class="scene-card-body">
            <div class="scene-card-title" data-scene-edit-root>
              <div class="scene-card-display" data-scene-card-display>
                <strong data-scene-card-slug>${escapeHtml(slugDisplay)}</strong>
                <small>${escapeHtml(sceneNumberLabel)}</small>
              </div>
              <label class="scene-card-input-wrapper">
                <span class="scene-card-sr-only">Rename ${escapeHtml(sceneNumberLabel)}</span>
                <input type="text" class="scene-card-input" data-scene-input value="${escapeHtml(rawSlug)}" autocomplete="off" maxlength="140" />
              </label>
            </div>
            <span class="scene-card-color" title="${escapeHtml(colorTitle)}" style="background:${colorMeta.color};border-color:${colorBorder}"></span>
          </div>
          <div class="scene-card-tags">
            <button type="button" class="scene-card-tags-button" data-scene-tags-trigger aria-label="Edit scene tags"><span aria-hidden="true">#</span></button>
            <div class="scene-card-tags-list" data-scene-tags>${tagsHtml}</div>
          </div>`;
        const editRoot = div.querySelector('[data-scene-edit-root]');
        if (editRoot){
          editRoot.addEventListener('dblclick', event => {
            event.preventDefault();
            event.stopPropagation();
            beginSceneInlineRename(s.id);
          });
        }
        const tagsButton = div.querySelector('[data-scene-tags-trigger]');
        if (tagsButton){
          tagsButton.addEventListener('click', event => {
            event.stopPropagation();
            if (sceneDragSceneId) return;
            if (sceneInlineRenameId === s.id) return;
            cancelScenePopoverClickTimer();
            const alreadyOpen = scenePopoverOpenId === s.id;
            activeSceneId = s.id;
            scenePopoverOpenId = alreadyOpen ? null : s.id;
            render();
          });
        }
        const input = div.querySelector('[data-scene-input]');
        if (input){
          input.dataset.sceneId = s.id;
          if (isEditing){
            input.value = sceneInlineRenameDraft;
            renameFocusTargets.push({ input, select: pendingSceneRenameFocusId === s.id });
          } else {
            input.value = rawSlug;
          }
          input.addEventListener('input', event => {
            if (sceneInlineRenameId === s.id){
              sceneInlineRenameDraft = event.target.value;
            }
          });
          input.addEventListener('keydown', event => {
            if (event.key === 'Enter'){
              event.preventDefault();
              finishSceneInlineRename(s.id, event.target.value);
            } else if (event.key === 'Escape'){
              event.preventDefault();
              event.stopPropagation();
              cancelSceneInlineRename(s.id);
            }
          });
          input.addEventListener('blur', event => {
            if (sceneInlineRenameId === s.id){
              finishSceneInlineRename(s.id, event.target.value);
            }
          });
          input.addEventListener('click', event => event.stopPropagation());
          input.addEventListener('mousedown', event => event.stopPropagation());
        }
        const popover = document.createElement('div');
        popover.className = 'scene-card-popover';
        popover.setAttribute('role', 'dialog');
        popover.setAttribute('aria-label', 'Scene tags');
        popover.innerHTML = buildSceneCardPopoverHtml(s);
        popover.addEventListener('click', event => event.stopPropagation());
        div.appendChild(popover);
        setupSceneCardPopover(popover, s);
        list.appendChild(div);
      });
      if (renameFocusTargets.length){
        requestAnimationFrame(()=>{
          renameFocusTargets.forEach(({ input, select })=>{
            if (!input) return;
            input.focus({ preventScroll: true });
            if (select){
              input.select();
            } else {
              const len = input.value.length;
              try { input.setSelectionRange(len, len); } catch (err) {}
            }
          });
          pendingSceneRenameFocusId = null;
        });
      }

      // right-side bindings
      const scene = getActiveScene();
      if (!scene){
        updateSceneColorUI(null);
        document.getElementById('editor').innerHTML = '';
        applyScriptViewSettingsFromProject();
        updateCounters();
        updateHud();
        updatePomodoroUI();
        applyTheme();
        renderStoryboard();
        renderCatalogs();
        renderSoundList();
        renderTimeline();
        updateDeleteSceneButton();
        applyActiveTabUI();
        if (timelineMode) renderTimelineBoard();
        else updateTimelineInsertLabel();
        updateTimelineButton();
        if (storyboardMode) renderStoryboardGallery();
        updateStoryboardButton();
        if (characterStudioState.open) renderCharacterStudio();
        return;
      }
      if (!Array.isArray(scene.sounds)) scene.sounds = [];
      document.getElementById('sceneSlug').value = scene.slug || '';
      updateSceneColorUI(scene);
      renderStoryboard();

      // editor render
      const editor = document.getElementById('editor');
      editor.innerHTML = scene.elements.map(el=>{
        const normalized = normalizeSceneElement(el);
        return `<div class="line ${escapeHtml(normalized.t)}" data-t="${escapeHtml(normalized.t)}">${escapeHtml(normalized.txt)}</div>`;
      }).join('');
      normalizeEditorLines(); // ensure structure
      const nodes = Array.from(editor.querySelectorAll('.line'));
      nodes.forEach((node, idx)=>{
        const meta = normalizeSceneElement(scene.elements[idx] || createSceneElement('action', ''));
        scene.elements[idx] = meta;
        node.dataset.t = meta.t || 'action';
        if (meta.ownerId) node.dataset.owner = meta.ownerId;
        else delete node.dataset.owner;
        if (meta.storyPart) node.dataset.storyPart = meta.storyPart;
        else delete node.dataset.storyPart;
        if (meta.storyBeat) node.dataset.storyBeat = meta.storyBeat;
        else delete node.dataset.storyBeat;
        applyLineTypeClass(node);
        updateLineTagLabel(node);
      });

      applyScriptViewSettingsFromProject();
      updateCounters();
      updateHud();
      updatePomodoroUI();
      applyTheme();
      renderCatalogs();
      renderSoundList();
      renderTimeline();
      updateDeleteSceneButton();
      applyActiveTabUI();
      if (timelineMode) renderTimelineBoard();
      else updateTimelineInsertLabel();
      updateTimelineButton();
      if (storyboardMode) renderStoryboardGallery();
      updateStoryboardButton();
      if (characterStudioState.open) renderCharacterStudio();
    }

    function beginSceneInlineRename(sceneId){
      if (!sceneId || !Array.isArray(project?.scenes)) return;
      if (sceneInlineRenameId === sceneId) return;
      const scene = project.scenes.find(s=>s.id===sceneId);
      if (!scene) return;
      cancelScenePopoverClickTimer();
      sceneInlineRenameId = sceneId;
      sceneInlineRenameDraft = typeof scene.slug === 'string' ? scene.slug : '';
      pendingSceneRenameFocusId = sceneId;
      scenePopoverOpenId = null;
      render();
    }

    function finishSceneInlineRename(sceneId, nextValue, commit = true){
      const scene = Array.isArray(project?.scenes) ? project.scenes.find(s=>s.id===sceneId) : null;
      const nextSlug = typeof nextValue === 'string' ? nextValue : '';
      const currentSlug = typeof scene?.slug === 'string' ? scene.slug : '';
      const shouldUpdate = Boolean(scene) && commit && nextSlug !== currentSlug;
      sceneInlineRenameId = null;
      sceneInlineRenameDraft = '';
      pendingSceneRenameFocusId = null;
      if (shouldUpdate){
        scene.slug = nextSlug;
        bumpVersion();
        updateSceneHash(scene);
      }
      render();
      if (shouldUpdate){
        scheduleSave();
        scheduleBackup();
      }
    }

    function cancelSceneInlineRename(sceneId){
      finishSceneInlineRename(sceneId, undefined, false);
    }

    function updateSceneColorUI(scene){
      const colorInput = document.getElementById('sceneColor');
      const autoBtn = document.getElementById('sceneColorAutoBtn');
      const badge = document.getElementById('sceneColorBadge');
      const description = document.getElementById('sceneColorDescription');
      const metaContainer = document.getElementById('sceneColorMeta');
      if (!colorInput || !badge || !description || !metaContainer) return;
      if (!scene){
        colorInput.value = DEFAULT_SCENE_COLOR;
        colorInput.disabled = true;
        colorInput.removeAttribute('title');
        if (autoBtn){
          autoBtn.disabled = true;
          autoBtn.textContent = 'Auto from slug';
          autoBtn.setAttribute('aria-pressed', 'false');
          autoBtn.removeAttribute('title');
        }
        badge.textContent = 'Auto';
        badge.dataset.source = SCENE_COLOR_SOURCE_AUTO;
        badge.style.background = 'var(--chip)';
        badge.style.color = 'var(--ink)';
        badge.style.borderColor = 'var(--ring)';
        description.textContent = 'Select a scene to edit its color.';
        metaContainer.dataset.source = SCENE_COLOR_SOURCE_AUTO;
        metaContainer.hidden = false;
        return;
      }
      const meta = getSceneColorMeta(scene);
      colorInput.disabled = false;
      colorInput.value = meta.color;
      colorInput.setAttribute('title', meta.description || 'Scene color');
      colorInput.dataset.source = meta.source;
      if (autoBtn){
        autoBtn.disabled = meta.source === SCENE_COLOR_SOURCE_AUTO;
        autoBtn.textContent = meta.source === SCENE_COLOR_SOURCE_AUTO ? 'Auto color active' : 'Use auto color';
        autoBtn.setAttribute('aria-pressed', meta.source === SCENE_COLOR_SOURCE_AUTO ? 'true' : 'false');
        autoBtn.setAttribute('title', 'Reapply the automatic stripboard palette');
      }
      badge.textContent = meta.sourceLabel;
      badge.dataset.source = meta.source;
      badge.style.background = meta.color;
      badge.style.color = meta.textColor;
      badge.style.borderColor = hexToRgba(meta.textColor, 0.35);
      description.textContent = meta.description || 'Scene color';
      metaContainer.dataset.source = meta.source;
      metaContainer.hidden = false;
    }

    /* Scene list drag-and-drop helpers */
    function clearSceneCardDropIndicators(){
      document.querySelectorAll('#sceneList .scene-card.drag-over').forEach(card => {
        card.classList.remove('drag-over');
        card.removeAttribute('data-drop-position');
      });
    }

    function clearSceneListDropIndicators(){
      clearSceneCardDropIndicators();
      const list = document.getElementById('sceneList');
      if (list) list.classList.remove('drag-over-end');
    }

    function computeSceneDropTarget(card, event){
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      const fromIdx = scenes.findIndex(s => s.id === sceneDragSceneId);
      if (!card || !scenes.length){
        return { fromIdx, toIdx: fromIdx, before: true };
      }
      const rawIdx = parseInt(card.dataset.index || '0', 10);
      const targetIdx = Number.isNaN(rawIdx) ? 0 : rawIdx;
      const rect = card.getBoundingClientRect();
      const midpoint = rect ? rect.height / 2 : 0;
      const offset = rect ? event.clientY - rect.top : 0;
      const before = rect && rect.height ? offset < midpoint : true;
      let insertIndex = before ? targetIdx : targetIdx + 1;
      insertIndex = Math.max(0, Math.min(insertIndex, scenes.length));
      let toIdx = insertIndex;
      if (fromIdx < insertIndex) toIdx = insertIndex - 1;
      toIdx = Math.max(0, Math.min(toIdx, scenes.length - 1));
      return { fromIdx, toIdx, before };
    }

    function handleSceneCardDragStart(event){
      const card = event.currentTarget;
      if (scenePopoverOpenId){
        const openCard = document.querySelector('#sceneList .scene-card[data-popover-open="true"]');
        if (openCard) openCard.dataset.popoverOpen = 'false';
        cancelScenePopoverClickTimer();
        scenePopoverOpenId = null;
      }
      sceneDragSceneId = card?.dataset?.sceneId || null;
      if (card) card.classList.add('dragging');
      clearSceneListDropIndicators();
      if (event.dataTransfer){
        event.dataTransfer.effectAllowed = 'move';
        try { event.dataTransfer.setData('text/plain', sceneDragSceneId || ''); } catch (err) {}
      }
    }

    function handleSceneCardDragEnd(event){
      const card = event.currentTarget;
      if (card) card.classList.remove('dragging');
      sceneDragSceneId = null;
      clearSceneListDropIndicators();
    }

    function handleSceneCardDragOver(event){
      if (!sceneDragSceneId) return;
      event.preventDefault();
      event.stopPropagation();
      if (event.dataTransfer) event.dataTransfer.dropEffect = 'move';
      const card = event.currentTarget;
      if (!card) return;
      const list = document.getElementById('sceneList');
      if (list) list.classList.remove('drag-over-end');
      const { before } = computeSceneDropTarget(card, event);
      clearSceneCardDropIndicators();
      card.classList.add('drag-over');
      card.dataset.dropPosition = before ? 'before' : 'after';
    }

    function handleSceneCardDragLeave(event){
      const card = event.currentTarget;
      if (!card) return;
      const related = event.relatedTarget;
      if (related && card.contains(related)) return;
      card.classList.remove('drag-over');
      card.removeAttribute('data-drop-position');
    }

    function handleSceneCardDrop(event){
      if (!sceneDragSceneId) return;
      event.preventDefault();
      event.stopPropagation();
      const card = event.currentTarget;
      const { fromIdx, toIdx } = computeSceneDropTarget(card, event);
      clearSceneListDropIndicators();
      const draggingCard = document.querySelector('#sceneList .scene-card.dragging');
      if (draggingCard) draggingCard.classList.remove('dragging');
      if (fromIdx < 0 || toIdx < 0 || fromIdx === toIdx){
        sceneDragSceneId = null;
        return;
      }
      sceneDragSceneId = null;
      moveScene(fromIdx, toIdx);
    }

    function handleSceneListDragOver(event){
      if (!sceneDragSceneId) return;
      const targetEl = event.target instanceof Element ? event.target : null;
      if (targetEl && targetEl.closest('.scene-card')) return;
      event.preventDefault();
      if (event.dataTransfer) event.dataTransfer.dropEffect = 'move';
      const list = event.currentTarget;
      clearSceneCardDropIndicators();
      if (list) list.classList.add('drag-over-end');
    }

    function handleSceneListDragLeave(event){
      if (!sceneDragSceneId) return;
      const list = event.currentTarget;
      if (!list) return;
      const related = event.relatedTarget;
      if (related && list.contains(related)) return;
      list.classList.remove('drag-over-end');
    }

    function handleSceneListDrop(event){
      if (!sceneDragSceneId) return;
      const targetEl = event.target instanceof Element ? event.target : null;
      if (targetEl && targetEl.closest('.scene-card')) return;
      event.preventDefault();
      const list = event.currentTarget;
      clearSceneListDropIndicators();
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      if (!scenes.length) return;
      const fromIdx = scenes.findIndex(s => s.id === sceneDragSceneId);
      const draggingCard = document.querySelector('#sceneList .scene-card.dragging');
      if (draggingCard) draggingCard.classList.remove('dragging');
      if (fromIdx < 0){
        sceneDragSceneId = null;
        return;
      }
      const insertIndex = scenes.length;
      let toIdx = insertIndex;
      if (fromIdx < insertIndex) toIdx = insertIndex - 1;
      toIdx = Math.max(0, Math.min(toIdx, scenes.length - 1));
      if (fromIdx === toIdx){
        sceneDragSceneId = null;
        return;
      }
      sceneDragSceneId = null;
      moveScene(fromIdx, toIdx);
      if (list) list.classList.remove('drag-over-end');
    }

    /* Keep child nodes as .line blocks */
    function normalizeEditorLines(){
      const editor = document.getElementById('editor');
      const children = Array.from(editor.childNodes);
      const normalized = [];
      let changed = false;

      for (let n of children){
        if (n.nodeType === 3){ // text node
          const div = document.createElement('div');
          div.dataset.t = 'action';
          div.textContent = (n.textContent || '').trim();
          applyLineTypeClass(div);
          updateLineTagLabel(div);
          normalized.push(div);
          changed = true;
        } else if (n.nodeType === 1){ // element
          if (n.classList.contains('line')) {
            if (!n.dataset.t) n.dataset.t = 'action';
            applyLineTypeClass(n);
            updateLineTagLabel(n);
            normalized.push(n);
          } else if (n.tagName === 'BR') {
            const div = document.createElement('div');
            div.dataset.t = 'action';
            div.textContent = '';
            applyLineTypeClass(div);
            updateLineTagLabel(div);
            normalized.push(div);
            changed = true;
          } else {
            const div = document.createElement('div');
            div.dataset.t = 'action';
            div.textContent = n.textContent || '';
            applyLineTypeClass(div);
            updateLineTagLabel(div);
            normalized.push(div);
            changed = true;
          }
        }
      }

      if (!changed && normalized.length === children.length) return;

      editor.innerHTML = '';
      normalized.forEach(d=>editor.appendChild(d));
    }

    function syncActiveScene(autoDetect = true){
      const scene = getActiveScene();
      if (!scene) return;
      project.settings = project.settings || {};
      normalizeEditorLines();
      if (autoDetect && project.settings.smartFormat) autoDetectTypes();
      const nodes = Array.from(document.querySelectorAll('#editor .line'));
      scene.elements = nodes.map(n=> createSceneElement(
        n.dataset.t || 'action',
        n.textContent,
        n.dataset.owner || null,
        n.dataset.storyPart || null,
        n.dataset.storyBeat || null
      ));
      updateSceneHash(scene);
      bumpVersion();
      updateCounters();
      scheduleSave();
      scheduleBackup();
    }

    function renderCatalogs(){
      const charContainer = document.getElementById('characterList');
      if (charContainer){
        charContainer.innerHTML = '';
        if (!project.catalogs.characters.length){
          const empty = document.createElement('p');
          empty.className = 'muted-text';
          empty.textContent = 'No characters yet.';
          charContainer.appendChild(empty);
        } else {
          project.catalogs.characters.forEach(char => {
            const row = document.createElement('div');
            row.className = 'catalog-item';
            const label = document.createElement('div');
            label.className = 'catalog-item-label';
            const name = document.createElement('span');
            name.textContent = char.name || '';
            label.appendChild(name);
            const metaParts = [];
            if (char.role) metaParts.push(char.role);
            const identity = [char.pronouns, char.age].filter(Boolean).join(' ‚Ä¢ ');
            if (identity) metaParts.push(identity);
            if (!metaParts.length && char.archetype) metaParts.push(char.archetype);
            if (metaParts.length){
              const meta = document.createElement('span');
              meta.className = 'catalog-meta';
              meta.textContent = metaParts.join(' ‚Äî ');
              label.appendChild(meta);
            }
            const actions = document.createElement('div');
            actions.className = 'catalog-actions';
            const insertBtn = document.createElement('button');
            insertBtn.textContent = 'Insert';
            insertBtn.addEventListener('click', ()=>{
              insertLine('character', char.name || '');
              setRightTab('write');
            });
            const delBtn = document.createElement('button');
            delBtn.textContent = 'Delete';
            delBtn.addEventListener('click', ()=>{
              removeCharacter(char.id);
            });
            actions.appendChild(insertBtn);
            actions.appendChild(delBtn);
            row.appendChild(label);
            row.appendChild(actions);
            charContainer.appendChild(row);
          });
        }
      }

      const setContainer = document.getElementById('setList');
      if (setContainer){
        setContainer.innerHTML = '';
        if (!project.catalogs.locations.length){
          const empty = document.createElement('p');
          empty.className = 'muted-text';
          empty.textContent = 'No locations yet.';
          setContainer.appendChild(empty);
        } else {
          project.catalogs.locations.forEach(loc => {
            const row = document.createElement('div');
            row.className = 'catalog-item';
            const name = document.createElement('span');
            name.textContent = loc.name || '';
            const actions = document.createElement('div');
            actions.className = 'catalog-actions';
            const delBtn = document.createElement('button');
            delBtn.textContent = 'Delete';
            delBtn.addEventListener('click', ()=>{
              removeLocation(loc.id);
            });
            actions.appendChild(delBtn);
            row.appendChild(name);
            row.appendChild(actions);
            setContainer.appendChild(row);
          });
        }
      }
      updateSelectionMenuCharacters();
      updateAllLineTagLabels();
    }

    function renderSoundList(){
      const container = document.getElementById('soundList');
      if (!container) return;
      container.innerHTML = '';
      const scene = getActiveScene();
      if (!scene){
        const empty = document.createElement('p');
        empty.className = 'muted-text';
        empty.textContent = 'No scene selected.';
        container.appendChild(empty);
        return;
      }
      if (!scene.sounds.length){
        const empty = document.createElement('p');
        empty.className = 'muted-text';
        empty.textContent = 'No sound cues yet.';
        container.appendChild(empty);
        return;
      }
      scene.sounds.forEach(sound => {
        const row = document.createElement('div');
        row.className = 'sound-item';
        const label = document.createElement('span');
        label.textContent = sound.cue || '';
        const btn = document.createElement('button');
        btn.textContent = 'Delete';
        btn.addEventListener('click', ()=> removeSoundCue(sound.id));
        row.appendChild(label);
        row.appendChild(btn);
        container.appendChild(row);
      });
    }

    function renderStoryboard(){
      const scene = getActiveScene();
      const viewer = document.getElementById('storyboardViewer');
      const image = document.getElementById('storyboardImage');
      const video = document.getElementById('storyboardVideo');
      const counter = document.getElementById('storyboardCounter');
      const prevBtn = document.getElementById('storyboardPrev');
      const nextBtn = document.getElementById('storyboardNext');
      const removeBtn = document.getElementById('removeStoryboardBtn');
      const emptyState = document.getElementById('storyboardEmpty');
      if (!viewer || !image || !counter || !prevBtn || !nextBtn || !removeBtn || !emptyState){
        return;
      }

      const config = getStoryboardModeConfig(storyboardMediaMode);
      const storyboards = scene ? getSceneStoryboards(scene, storyboardMediaMode) : [];
      let index = 0;
      if (scene){
        index = clampStoryboardIndex(scene, storyboardMediaMode);
      }
      const currentStoryboard = storyboards.length ? storyboards[index] : null;
      const hasStoryboard = !!currentStoryboard;

      viewer.dataset.empty = hasStoryboard ? 'false' : 'true';
      viewer.dataset.mode = storyboardMediaMode;

      const label = hasStoryboard ? `${config.counterPrefix} ${index + 1} of ${storyboards.length}` : config.counterEmpty;
      if (image){
        if (hasStoryboard && currentStoryboard.type === STORYBOARD_MEDIA_IMAGE){
          image.src = currentStoryboard.url;
          image.alt = label;
          image.hidden = false;
        } else {
          image.src = getStoryboardPlaceholderImage();
          image.alt = hasStoryboard ? label : 'Storyboard placeholder';
          image.hidden = hasStoryboard && currentStoryboard?.type === STORYBOARD_MEDIA_VIDEO;
        }
      }

      if (video){
        if (hasStoryboard && currentStoryboard.type === STORYBOARD_MEDIA_VIDEO){
          if (video.src !== currentStoryboard.url){
            try { video.pause(); } catch (err){}
            video.src = currentStoryboard.url;
            try { video.load(); } catch (err){}
          }
          video.hidden = false;
        } else {
          if (video.src){
            try { video.pause(); } catch (err){}
            video.removeAttribute('src');
            try { video.load(); } catch (err){}
          }
          video.hidden = true;
        }
      }

      counter.textContent = label;
      emptyState.textContent = hasStoryboard ? '' : config.empty;

      prevBtn.disabled = !hasStoryboard || index <= 0;
      nextBtn.disabled = !hasStoryboard || index >= storyboards.length - 1;
      prevBtn.setAttribute('aria-label', `Previous ${config.singular}`);
      nextBtn.setAttribute('aria-label', `Next ${config.singular}`);
      removeBtn.disabled = !hasStoryboard;
      removeBtn.hidden = !hasStoryboard;
      removeBtn.textContent = config.removeAction;

      if (!scene){
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        removeBtn.disabled = true;
        removeBtn.hidden = true;
      }
    }

    function normalizeStoryboardUrl(raw){
      let value = (raw || '').trim();
      if (!value) return null;
      if (/^data:image\/[a-z0-9.+-]+;base64,/i.test(value)){ return value; }
      if (!/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(value)){
        value = `https://${value}`;
      }
      try {
        const parsed = new URL(value);
        if (!/^https?:$/i.test(parsed.protocol)) return null;
        return parsed.href;
      } catch (err){
        return null;
      }
    }

    function setProjectCoverImage(url){
      if (!project) return;
      project.settings = project.settings || {};
      const normalized = (url || '').trim();
      if (project.settings.coverImageUrl === normalized) return;
      project.settings.coverImageUrl = normalized;
      bumpVersion();
      scheduleSave();
      scheduleBackup();
      renderStoryboard();
      if (storyboardMode) renderStoryboardGallery();
      updateCachedCoverImage(normalized);
      updateScriptPreview(scriptDialogSelectedId || '');
    }

    function handleApplyScriptCoverImage(){
      if (!project) return;
      const input = document.getElementById('scriptDialogCoverUrl');
      if (!input) return;
      const raw = input.value || '';
      const trimmed = raw.trim();
      if (!trimmed){
        input.value = '';
        setProjectCoverImage('');
        return;
      }
      const normalized = normalizeStoryboardUrl(trimmed);
      if (!normalized){
        alert('Enter a valid image URL (including http:// or https://).');
        input.focus();
        return;
      }
      input.value = normalized;
      setProjectCoverImage(normalized);
    }

    function handleClearScriptCoverImage(){
      const input = document.getElementById('scriptDialogCoverUrl');
      if (input) input.value = '';
      setProjectCoverImage('');
    }

    function addStoryboardEntry(scene, url, type = STORYBOARD_MEDIA_IMAGE){
      if (!scene || !url) return false;
      if (!Array.isArray(scene.storyboards)) scene.storyboards = [];
      const normalizedType = STORYBOARD_MEDIA_MODES.includes(type) ? type : STORYBOARD_MEDIA_IMAGE;
      scene.storyboards.push({ id: randomId(), url, type: normalizedType });
      refreshStoryboardPositions(scene);
      updateSceneHash(scene);
      bumpVersion();
      scheduleSave();
      scheduleBackup();
      return true;
    }

    function removeStoryboardEntry(scene, storyboardId){
      if (!scene || !storyboardId || !Array.isArray(scene.storyboards)) return false;
      const idx = scene.storyboards.findIndex(entry => entry.id === storyboardId);
      if (idx < 0) return false;
      scene.storyboards.splice(idx, 1);
      refreshStoryboardPositions(scene);
      updateSceneHash(scene);
      bumpVersion();
      scheduleSave();
      scheduleBackup();
      return true;
    }

    function stepStoryboard(delta){
      const scene = getActiveScene();
      if (!scene) return;
      const storyboards = getSceneStoryboards(scene, storyboardMediaMode);
      if (!storyboards.length) return;
      const current = getStoryboardIndex(scene.id, storyboardMediaMode);
      const next = Math.max(0, Math.min(current + delta, storyboards.length - 1));
      if (next === current) return;
      setStoryboardIndex(scene.id, next, storyboardMediaMode);
      renderStoryboard();
    }

    function handleAddStoryboard(){
      const input = document.getElementById('newStoryboardUrl');
      const scene = getActiveScene();
      if (!input || !scene) return;
      const config = getStoryboardModeConfig(storyboardMediaMode);
      const normalizedUrl = normalizeStoryboardUrl(input.value);
      if (!normalizedUrl){
        input.focus();
        alert(`Enter a valid ${config.singular} URL (including http:// or https://).`);
        return;
      }
      if (!addStoryboardEntry(scene, normalizedUrl, storyboardMediaMode)) return;
      const storyboards = getSceneStoryboards(scene, storyboardMediaMode);
      setStoryboardIndex(scene.id, Math.max(0, storyboards.length - 1), storyboardMediaMode);
      input.value = '';
      renderStoryboard();
      if (storyboardMode) renderStoryboardGallery();
    }

    function handleRemoveStoryboard(){
      const scene = getActiveScene();
      if (!scene || !Array.isArray(scene.storyboards) || !scene.storyboards.length) return;
      const current = getStoryboardIndex(scene.id, storyboardMediaMode);
      const storyboards = getSceneStoryboards(scene, storyboardMediaMode);
      const target = storyboards[current];
      if (!target) return;
      if (!removeStoryboardEntry(scene, target.id)) return;
      const nextStoryboards = getSceneStoryboards(scene, storyboardMediaMode);
      const max = Math.max(0, (nextStoryboards.length || 1) - 1);
      setStoryboardIndex(scene.id, Math.min(current, max), storyboardMediaMode);
      renderStoryboard();
      if (storyboardMode) renderStoryboardGallery();
    }

    function getStoryboardScenes(){
      return Array.isArray(project?.scenes) ? project.scenes : [];
    }

    function getStoryboardCharacters(){
      return Array.isArray(project?.catalogs?.characters) ? project.catalogs.characters : [];
    }

    function getStoryboardCharacterById(characterId){
      if (!characterId) return null;
      return getStoryboardCharacters().find(character => character.id === characterId) || null;
    }

    function getStoryboardCharacterToken(character){
      if (!character) return '';
      if (storyboardCharacterTokenCache.has(character.id)){
        return storyboardCharacterTokenCache.get(character.id);
      }
      const baseName = (character.name || 'character').trim().toUpperCase().replace(/[^A-Z0-9]+/g, '_') || 'CHARACTER';
      const sanitizedId = (character.id || '').replace(/[^a-zA-Z0-9]/g, '').slice(-6).toUpperCase() || 'ID';
      const token = `CHAR_${baseName}_${sanitizedId}`;
      storyboardCharacterTokenCache.set(character.id, token);
      return token;
    }

    function collectSceneCharacterIds(scene){
      if (!scene || !Array.isArray(scene.elements)) return [];
      const ids = new Set();
      const characters = getStoryboardCharacters();
      scene.elements.forEach(element => {
        if (!element || typeof element !== 'object') return;
        if (element.ownerId) ids.add(element.ownerId);
        else if (element.t === 'character' && typeof element.txt === 'string'){
          const name = element.txt.trim().toLowerCase();
          const match = characters.find(char => (char.name || '').trim().toLowerCase() === name);
          if (match) ids.add(match.id);
        }
      });
      return Array.from(ids);
    }

    function buildDefaultStoryboardShotPrompt(scene){
      if (!scene) return '';
      const slug = scene.slug || 'this scene';
      const snippet = getSceneSnippet(scene);
      if (snippet) return `Depict ${slug} as described: ${snippet}`;
      return `Depict ${slug} with cinematic lighting and clear staging.`;
    }

    function summarizeCharacterForPrompt(character){
      if (!character) return '';
      const details = [];
      if (character.summary) details.push(character.summary);
      if (character.ai?.prompt) details.push(character.ai.prompt);
      if (Array.isArray(character.traits) && character.traits.length){
        details.push(`Key traits: ${character.traits.join(', ')}`);
      }
      const lookUrls = [];
      if (character.looks?.portrait) lookUrls.push(character.looks.portrait);
      if (Array.isArray(character.looks?.turnarounds)) lookUrls.push(...character.looks.turnarounds.filter(Boolean));
      if (Array.isArray(character.looks?.expressions)) lookUrls.push(...character.looks.expressions.filter(Boolean));
      if (lookUrls.length) details.push(`Visual references: ${lookUrls.join(', ')}`);
      if (character.ai?.notes) details.push(character.ai.notes);
      return details.join(' ‚Ä¢ ');
    }

    function buildStoryboardPrompt(scene, shotPrompt, characters, frameCount){
      const promptParts = [];
      const projectTitle = project?.title ? `"${project.title}"` : 'this project';
      promptParts.push(`You are Gemini 2.5 Image Preview generating cinematic storyboard imagery for ${projectTitle}.`);
      promptParts.push('Use a 16:9 storyboard frame with clear silhouettes and bold lighting.');
      promptParts.push('Maintain absolute character consistency by referencing the provided handles verbatim.');
      if (Array.isArray(characters) && characters.length){
        promptParts.push('Character bible:');
        characters.forEach(character => {
          const token = getStoryboardCharacterToken(character);
          const descriptor = summarizeCharacterForPrompt(character) || 'Preserve face shape, hairstyle, outfit, and palette.';
          promptParts.push(`${token} (${character.name || 'Unnamed character'}): ${descriptor}`);
        });
      } else {
        promptParts.push('No specific characters were selected, but preserve continuity with established looks.');
      }
      if (scene?.slug) promptParts.push(`Scene heading: ${scene.slug}`);
      const snippet = getSceneSnippet(scene);
      if (snippet) promptParts.push(`Script context: ${snippet}`);
      const frameLabel = frameCount > 1 ? `${frameCount} sequential storyboard frames` : 'a single storyboard frame';
      promptParts.push(`Generate ${frameLabel} that visualize: ${shotPrompt}`);
      promptParts.push('Keep poses dynamic yet readable and ensure all referenced handles match across every frame.');
      if (frameCount > 1){
        promptParts.push('Each frame should feel like the next beat of the same moment while keeping costumes and faces identical.');
      }
      return promptParts.join('\n\n');
    }

    function getStoryboardAISelection(scene){
      if (!scene) return new Set();
      let selection = storyboardAISelections.get(scene.id);
      const availableIds = new Set(getStoryboardCharacters().map(char => char.id));
      if (selection instanceof Set){
        selection = new Set(Array.from(selection).filter(id => availableIds.has(id)));
      }
      if (!selection || selection.size === 0){
        const defaults = collectSceneCharacterIds(scene).filter(id => availableIds.has(id));
        selection = new Set(defaults);
      }
      storyboardAISelections.set(scene.id, selection);
      return selection;
    }

    function applyStoryboardAIInputState(){
      const aiAvailable = getStoryboardModeConfig(storyboardMediaMode).aiAvailable;
      const hasScene = !!storyboardAIActiveSceneId && aiAvailable;
      const promptEl = document.getElementById('storyboardAIPrompt');
      const frameEl = document.getElementById('storyboardAIFrameCount');
      if (promptEl) promptEl.disabled = !hasScene || storyboardAIGenerating;
      if (frameEl) frameEl.disabled = !hasScene || storyboardAIGenerating;
      document.querySelectorAll('#storyboardAICharacterList input[type="checkbox"]').forEach(box => {
        box.disabled = !hasScene || storyboardAIGenerating;
      });
    }

    function updateStoryboardAIGenerateButton(){
      const btn = document.getElementById('storyboardAIGenerate');
      if (!btn) return;
      const promptEl = document.getElementById('storyboardAIPrompt');
      const promptValue = promptEl ? promptEl.value.trim() : '';
      const keyReady = !!(storyboardAIConfig?.apiKey && storyboardAIConfig.apiKey.trim());
      const aiAvailable = getStoryboardModeConfig(storyboardMediaMode).aiAvailable;
      const hasScene = !!storyboardAIActiveSceneId && aiAvailable;
      btn.disabled = storyboardAIGenerating || !hasScene || !keyReady || !promptValue;
      btn.textContent = aiAvailable
        ? (storyboardAIGenerating ? 'Generating‚Ä¶' : 'Generate storyboard')
        : 'Generate storyboard';
    }

    function clampStoryboardAIFrameCount(value){
      const num = parseInt(value, 10);
      if (!Number.isFinite(num)) return 1;
      return Math.max(1, Math.min(4, num));
    }

    function setStoryboardAIStatus(state, message){
      const statusEl = document.getElementById('storyboardAIStatus');
      if (!statusEl) return;
      statusEl.dataset.state = state || '';
      statusEl.textContent = message || '';
    }

    function handleStoryboardAICharacterToggle(sceneId, characterId, checked){
      if (!sceneId || !characterId) return;
      let selection = storyboardAISelections.get(sceneId);
      if (!(selection instanceof Set)) selection = new Set();
      if (checked) selection.add(characterId);
      else selection.delete(characterId);
      storyboardAISelections.set(sceneId, selection);
      if (sceneId === storyboardAIActiveSceneId) updateStoryboardAIGenerateButton();
    }

    function renderStoryboardAIComposer(scene){
      const promptEl = document.getElementById('storyboardAIPrompt');
      const frameEl = document.getElementById('storyboardAIFrameCount');
      const listEl = document.getElementById('storyboardAICharacterList');
      if (!promptEl || !frameEl || !listEl){
        storyboardAIActiveSceneId = null;
        return;
      }

      const aiAvailable = getStoryboardModeConfig(storyboardMediaMode).aiAvailable;
      if (!aiAvailable){
        storyboardAIActiveSceneId = null;
        promptEl.value = '';
        frameEl.value = '1';
        listEl.innerHTML = '<p class="storyboard-ai-character-empty">Switch to Picture frames to generate AI images.</p>';
        applyStoryboardAIInputState();
        updateStoryboardAIGenerateButton();
        return;
      }

      storyboardAIActiveSceneId = scene?.id || null;

      if (!scene){
        promptEl.value = '';
        frameEl.value = '1';
        listEl.innerHTML = '<p class="storyboard-ai-character-empty">Add a scene to unlock AI storyboards.</p>';
        applyStoryboardAIInputState();
        updateStoryboardAIGenerateButton();
        return;
      }

      let storedPrompt = storyboardAIPrompts.get(scene.id);
      if (typeof storedPrompt !== 'string' || !storedPrompt.trim()){
        storedPrompt = buildDefaultStoryboardShotPrompt(scene);
      }
      storyboardAIPrompts.set(scene.id, storedPrompt);
      promptEl.value = storedPrompt;

      let storedCount = storyboardAIFrameCounts.get(scene.id);
      if (!Number.isFinite(storedCount)) storedCount = 1;
      storedCount = clampStoryboardAIFrameCount(storedCount);
      storyboardAIFrameCounts.set(scene.id, storedCount);
      frameEl.value = String(storedCount);

      const characters = getStoryboardCharacters();
      const selection = getStoryboardAISelection(scene);
      listEl.innerHTML = '';
      if (!characters.length){
        const empty = document.createElement('p');
        empty.className = 'storyboard-ai-character-empty';
        empty.textContent = 'Add characters in the Cast tab to keep designs consistent.';
        listEl.appendChild(empty);
      } else {
        characters.forEach(character => {
          const label = document.createElement('label');
          label.className = 'storyboard-ai-character';
          const box = document.createElement('input');
          box.type = 'checkbox';
          box.value = character.id;
          box.checked = selection.has(character.id);
          box.disabled = storyboardAIGenerating;
          box.addEventListener('change', e => handleStoryboardAICharacterToggle(scene.id, character.id, e.target.checked));
          const details = document.createElement('div');
          details.className = 'storyboard-ai-character-details';
          const name = document.createElement('strong');
          name.textContent = character.name || 'Unnamed character';
          const token = document.createElement('span');
          token.className = 'storyboard-ai-character-token';
          token.textContent = getStoryboardCharacterToken(character);
          const notes = document.createElement('span');
          notes.className = 'storyboard-ai-character-notes';
          notes.textContent = summarizeCharacterForPrompt(character) || 'Maintain this character\'s established look.';
          details.appendChild(name);
          details.appendChild(token);
          details.appendChild(notes);
          label.appendChild(box);
          label.appendChild(details);
          listEl.appendChild(label);
        });
      }

      applyStoryboardAIInputState();
      updateStoryboardAIGenerateButton();
    }

    function handleStoryboardAIPromptChange(){
      const promptEl = document.getElementById('storyboardAIPrompt');
      if (storyboardAIActiveSceneId && promptEl){
        storyboardAIPrompts.set(storyboardAIActiveSceneId, promptEl.value);
      }
      updateStoryboardAIGenerateButton();
    }

    function handleStoryboardAIFrameCountChange(){
      const frameEl = document.getElementById('storyboardAIFrameCount');
      if (!frameEl) return;
      const value = clampStoryboardAIFrameCount(frameEl.value);
      frameEl.value = String(value);
      if (storyboardAIActiveSceneId){
        storyboardAIFrameCounts.set(storyboardAIActiveSceneId, value);
      }
    }

    function setStoryboardAIGenerating(value){
      storyboardAIGenerating = !!value;
      applyStoryboardAIInputState();
      updateStoryboardAIGenerateButton();
    }

    async function requestStoryboardImages(apiKey, model, prompt, frameCount){
      const payload = {
        model: model || STORYBOARD_AI_DEFAULT_MODEL,
        prompt,
        n: clampStoryboardAIFrameCount(frameCount),
        size: '1024x576',
        response_format: 'b64_json'
      };
      let response;
      try {
        response = await fetch('https://openrouter.ai/api/v1/images', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`,
            'HTTP-Referer': window.location.origin,
            'X-Title': 'StudioOrganize Storyboard Assistant'
          },
          body: JSON.stringify(payload)
        });
      } catch (networkError){
        throw new Error('Network error contacting OpenRouter. Check your connection and try again.');
      }

      let data;
      try {
        data = await response.json();
      } catch (parseError){
        throw new Error(`Invalid response from OpenRouter (HTTP ${response.status}).`);
      }

      if (!response.ok){
        const message = data?.error?.message || data?.message || `OpenRouter request failed (HTTP ${response.status}).`;
        throw new Error(message);
      }

      const items = Array.isArray(data?.data) ? data.data : [];
      const urls = [];
      items.forEach(item => {
        if (!item) return;
        if (typeof item.url === 'string' && item.url.trim()) urls.push(item.url.trim());
        else if (typeof item.b64_json === 'string' && item.b64_json.trim()) urls.push(`data:image/png;base64,${item.b64_json.trim()}`);
        else if (typeof item.b64 === 'string' && item.b64.trim()) urls.push(`data:image/png;base64,${item.b64.trim()}`);
        else if (typeof item.image_base64 === 'string' && item.image_base64.trim()) urls.push(`data:image/png;base64,${item.image_base64.trim()}`);
      });

      if (!urls.length){
        if (data?.error?.message) throw new Error(data.error.message);
        throw new Error('OpenRouter did not return any images for this prompt. Try refining your description.');
      }

      return urls;
    }

    async function handleStoryboardAIGenerate(){
      if (!getStoryboardModeConfig(storyboardMediaMode).aiAvailable){
        setStoryboardAIStatus('error', 'AI generation is only available for picture frames.');
        return;
      }
      const apiKey = (storyboardAIConfig?.apiKey || '').trim();
      if (!apiKey){
        setStoryboardAIStatus('error', 'Enter your OpenRouter API key above to generate frames.');
        const keyInput = document.getElementById('storyboardApiKey');
        if (keyInput) keyInput.focus();
        return;
      }

      const promptEl = document.getElementById('storyboardAIPrompt');
      const frameEl = document.getElementById('storyboardAIFrameCount');
      if (!promptEl || !frameEl){
        setStoryboardAIStatus('error', 'Storyboard inputs unavailable.');
        return;
      }

      const shotPrompt = promptEl.value.trim();
      if (!shotPrompt){
        setStoryboardAIStatus('error', 'Describe the shot you want to visualize.');
        promptEl.focus();
        return;
      }

      const scenes = getStoryboardScenes();
      if (!scenes.length){
        setStoryboardAIStatus('error', 'Add a scene before generating a storyboard.');
        return;
      }

      const targetScene = scenes.find(scene => scene.id === storyboardOverlaySceneId)
        || scenes.find(scene => scene.id === activeSceneId)
        || scenes[0];
      if (!targetScene){
        setStoryboardAIStatus('error', 'Select a scene to continue.');
        return;
      }

      const frameCount = clampStoryboardAIFrameCount(frameEl.value);
      const selection = getStoryboardAISelection(targetScene);
      storyboardAISelections.set(targetScene.id, selection);
      const characters = Array.from(selection).map(id => getStoryboardCharacterById(id)).filter(Boolean);
      const fullPrompt = buildStoryboardPrompt(targetScene, shotPrompt, characters, frameCount);

      setStoryboardAIStatus('pending', 'Requesting Gemini 2.5 Image Preview‚Ä¶');
      setStoryboardAIGenerating(true);

      try {
        const images = await requestStoryboardImages(apiKey, storyboardAIConfig?.model || STORYBOARD_AI_DEFAULT_MODEL, fullPrompt, frameCount);
        const added = [];
        images.forEach(url => {
          if (addStoryboardEntry(targetScene, url, STORYBOARD_MEDIA_IMAGE)) added.push(url);
        });
        if (added.length){
          const storyboards = getSceneStoryboards(targetScene, STORYBOARD_MEDIA_IMAGE);
          setStoryboardIndex(targetScene.id, Math.max(0, storyboards.length - added.length), STORYBOARD_MEDIA_IMAGE);
          storyboardOverlaySceneId = targetScene.id;
          activeSceneId = targetScene.id;
          render();
          setStoryboardAIStatus('success', added.length === 1 ? 'Added 1 storyboard frame.' : `Added ${added.length} storyboard frames.`);
        } else {
          setStoryboardAIStatus('error', 'Images were generated but could not be added to the scene.');
        }
      } catch (err){
        console.error('Storyboard AI generation failed:', err);
        setStoryboardAIStatus('error', err?.message ? String(err.message) : 'Generation failed. Please try again.');
      } finally {
        setStoryboardAIGenerating(false);
      }
    }

    function pruneStoryboardAIState(){
      const scenes = getStoryboardScenes();
      const validSceneIds = new Set(scenes.map(scene => scene.id));
      Array.from(storyboardAIPrompts.keys()).forEach(id => {
        if (!validSceneIds.has(id)) storyboardAIPrompts.delete(id);
      });
      Array.from(storyboardAISelections.keys()).forEach(id => {
        if (!validSceneIds.has(id)) storyboardAISelections.delete(id);
      });
      Array.from(storyboardAIFrameCounts.keys()).forEach(id => {
        if (!validSceneIds.has(id)) storyboardAIFrameCounts.delete(id);
      });
      const validCharacterIds = new Set(getStoryboardCharacters().map(char => char.id));
      Array.from(storyboardCharacterTokenCache.keys()).forEach(id => {
        if (!validCharacterIds.has(id)) storyboardCharacterTokenCache.delete(id);
      });
    }

    function renderStoryboardGallery(){
      const listEl = document.getElementById('storyboardSceneList');
      const gridEl = document.getElementById('storyboardGalleryGrid');
      const emptyEl = document.getElementById('storyboardGalleryEmpty');
      const titleEl = document.getElementById('storyboardGalleryTitle');
      const metaEl = document.getElementById('storyboardGalleryMeta');
      const inputEl = document.getElementById('storyboardQuickUrl');
      const addBtn = document.getElementById('storyboardQuickAdd');
      const openBtn = document.getElementById('storyboardOpenSceneBtn');
      if (!listEl || !gridEl || !emptyEl || !titleEl || !metaEl || !inputEl || !addBtn || !openBtn){
        return;
      }

      const config = getStoryboardModeConfig(storyboardMediaMode);
      const scenes = getStoryboardScenes();
      listEl.innerHTML = '';
      gridEl.innerHTML = '';
      emptyEl.textContent = `Select a scene to start building ${config.plural}.`;

      inputEl.placeholder = config.quickPlaceholder;
      addBtn.textContent = config.addAction;

      if (!scenes.length){
        storyboardOverlaySceneId = null;
        const empty = document.createElement('p');
        empty.className = 'storyboard-sidebar-empty';
        empty.textContent = 'Add scenes to start storyboarding.';
        listEl.appendChild(empty);
        titleEl.textContent = 'No scenes yet';
        metaEl.textContent = `Add a scene to start building ${config.plural}.`;
        emptyEl.textContent = `Create a scene to begin crafting your ${config.plural}.`;
        emptyEl.hidden = false;
        inputEl.disabled = true;
        addBtn.disabled = true;
        openBtn.disabled = true;
        openBtn.textContent = 'Open in Writer';
        renderStoryboardAIComposer(null);
        setStoryboardAIStatus('', '');
        return;
      }

      if (activeSceneId && scenes.some(scene => scene.id === activeSceneId)){
        storyboardOverlaySceneId = activeSceneId;
      } else if (!storyboardOverlaySceneId || !scenes.some(scene => scene.id === storyboardOverlaySceneId)){
        storyboardOverlaySceneId = scenes[0].id;
      }

      const selectedScene = scenes.find(scene => scene.id === storyboardOverlaySceneId) || scenes[0];
      const selectedIndex = scenes.indexOf(selectedScene);

      scenes.forEach((scene, idx)=>{
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'storyboard-scene-btn' + (scene.id === selectedScene.id ? ' active' : '');
        const count = getSceneStoryboards(scene, storyboardMediaMode).length;
        const countLabel = count
          ? `${count} ${config.singular}${count === 1 ? '' : 's'}`
          : `No ${config.plural} yet`;
        btn.innerHTML = `
          <span class="storyboard-scene-btn-title">${escapeHtml(scene.slug || `Scene ${idx + 1}`)}</span>
          <span class="storyboard-scene-btn-meta">${escapeHtml(countLabel)}</span>
        `;
        btn.addEventListener('click', ()=>{
          storyboardOverlaySceneId = scene.id;
          if (activeSceneId !== scene.id){
            activeSceneId = scene.id;
            render();
          } else {
            renderStoryboardGallery();
          }
        });
        listEl.appendChild(btn);
      });

      const storyboards = getSceneStoryboards(selectedScene, storyboardMediaMode);
      const activeIndex = clampStoryboardIndex(selectedScene, storyboardMediaMode);

      titleEl.textContent = selectedScene.slug || `Scene ${selectedIndex + 1}`;
      const frameLabel = storyboards.length
        ? `${storyboards.length} storyboard ${storyboards.length === 1 ? config.singular : config.plural}`
        : `No storyboard ${config.plural} yet`;
      metaEl.textContent = `Scene ${selectedIndex + 1} ‚Ä¢ ${frameLabel}`;

      inputEl.disabled = false;
      addBtn.disabled = false;

      const viewingActive = activeSceneId === selectedScene.id;
      openBtn.disabled = viewingActive;
      openBtn.textContent = viewingActive ? 'Viewing in Writer' : 'Open in Writer';
      if (viewingActive) openBtn.setAttribute('aria-disabled', 'true');
      else openBtn.removeAttribute('aria-disabled');

      if (!storyboards.length){
        emptyEl.textContent = `Drop in your first ${config.singular} to visualize this scene.`;
        emptyEl.hidden = false;
      } else {
        emptyEl.hidden = true;
        storyboards.forEach((frame, idx)=>{
          const card = document.createElement('article');
          card.className = 'storyboard-gallery-card' + (idx === activeIndex ? ' active' : '');
          const mediaThumb = frame.type === STORYBOARD_MEDIA_VIDEO
            ? `<video src="${escapeHtml(frame.url)}" muted playsinline loop preload="metadata"></video>`
            : `<img src="${escapeHtml(frame.url)}" alt="${escapeHtml(`Storyboard ${config.singular} ${idx + 1} for ${selectedScene.slug || `Scene ${selectedIndex + 1}`}`)}" loading="lazy" />`;
          card.innerHTML = `
            <div class="storyboard-gallery-thumb">
              ${mediaThumb}
            </div>
            <div class="storyboard-gallery-card-footer">
              <span>${escapeHtml(config.singular.charAt(0).toUpperCase() + config.singular.slice(1))} ${idx + 1}</span>
              <div class="storyboard-gallery-card-actions">
                <button type="button" data-action="remove">Remove</button>
              </div>
            </div>
          `;
          card.addEventListener('click', ()=>{
            setStoryboardIndex(selectedScene.id, idx, storyboardMediaMode);
            if (activeSceneId !== selectedScene.id){
              activeSceneId = selectedScene.id;
              render();
            } else {
              renderStoryboard();
              renderStoryboardGallery();
            }
          });
          const removeBtn = card.querySelector('[data-action="remove"]');
          if (removeBtn){
            removeBtn.addEventListener('click', e=>{
              e.stopPropagation();
              if (!removeStoryboardEntry(selectedScene, frame.id)) return;
              const nextStoryboards = getSceneStoryboards(selectedScene, storyboardMediaMode);
              const nextMax = Math.max(0, nextStoryboards.length - 1);
              const currentIdx = Math.max(0, Math.min(getStoryboardIndex(selectedScene.id, storyboardMediaMode), nextMax));
              setStoryboardIndex(selectedScene.id, currentIdx, storyboardMediaMode);
              if (selectedScene.id === activeSceneId) renderStoryboard();
              renderStoryboardGallery();
            });
          }
          gridEl.appendChild(card);
        });
      }

      renderStoryboardAIComposer(selectedScene);
      if (!config.aiAvailable){
        setStoryboardAIStatus('info', 'Switch to Picture frames to generate AI images.');
      }

      openBtn.onclick = ()=>{
        if (activeSceneId !== selectedScene.id){
          activeSceneId = selectedScene.id;
          render();
        }
        setRightTab('write');
        closeStoryboardMode();
      };
    }

    function handleStoryboardQuickAdd(){
      const input = document.getElementById('storyboardQuickUrl');
      if (!input) return;
      const config = getStoryboardModeConfig(storyboardMediaMode);
      const scenes = getStoryboardScenes();
      if (!scenes.length){
        alert(`Add a scene to start building ${config.plural}.`);
        return;
      }
      const selectedScene = scenes.find(scene => scene.id === storyboardOverlaySceneId)
        || scenes.find(scene => scene.id === activeSceneId)
        || scenes[0];
      const normalizedUrl = normalizeStoryboardUrl(input.value);
      if (!normalizedUrl){
        input.focus();
        alert(`Enter a valid ${config.singular} URL (including http:// or https://).`);
        return;
      }
      if (!addStoryboardEntry(selectedScene, normalizedUrl, storyboardMediaMode)) return;
      const storyboards = getSceneStoryboards(selectedScene, storyboardMediaMode);
      setStoryboardIndex(selectedScene.id, Math.max(0, storyboards.length - 1), storyboardMediaMode);
      input.value = '';
      storyboardOverlaySceneId = selectedScene.id;
      activeSceneId = selectedScene.id;
      render();
    }

    function updateStoryboardModeUI(){
      const config = getStoryboardModeConfig(storyboardMediaMode);
      document.querySelectorAll('[data-storyboard-mode-btn]').forEach(btn => {
        const mode = btn.dataset.storyboardModeBtn;
        const active = mode === storyboardMediaMode;
        btn.classList.toggle('active', active);
        btn.setAttribute('aria-pressed', active ? 'true' : 'false');
      });
      const input = document.getElementById('newStoryboardUrl');
      if (input) input.placeholder = config.placeholder;
      const addBtn = document.getElementById('addStoryboardBtn');
      if (addBtn) addBtn.textContent = config.addAction;
      const removeBtn = document.getElementById('removeStoryboardBtn');
      if (removeBtn) removeBtn.textContent = config.removeAction;
      const quickInput = document.getElementById('storyboardQuickUrl');
      if (quickInput) quickInput.placeholder = config.quickPlaceholder;
      const quickAdd = document.getElementById('storyboardQuickAdd');
      if (quickAdd) quickAdd.textContent = config.addAction;
      const viewer = document.getElementById('storyboardViewer');
      if (viewer) viewer.dataset.mode = storyboardMediaMode;
    }

    function setStoryboardMediaMode(mode){
      const normalized = STORYBOARD_MEDIA_MODES.includes(mode) ? mode : STORYBOARD_MEDIA_IMAGE;
      if (normalized === storyboardMediaMode) return;
      storyboardMediaMode = normalized;
      saveStoryboardMediaMode(storyboardMediaMode);
      updateStoryboardModeUI();
      renderStoryboard();
      if (storyboardMode) renderStoryboardGallery();
      else renderStoryboardAIComposer(getActiveScene());
      if (!getStoryboardModeConfig(storyboardMediaMode).aiAvailable){
        setStoryboardAIStatus('info', 'Switch to Picture frames to generate AI images.');
      } else {
        setStoryboardAIStatus('', '');
      }
    }

    function updateStoryboardButton(){
      const btn = document.getElementById('storyboardModeBtn');
      if (!btn) return;
      btn.textContent = storyboardMode ? 'Exit Storyboard Lite' : 'Storyboard Lite';
      btn.setAttribute('aria-pressed', storyboardMode ? 'true' : 'false');
    }

    function openStoryboardMode(sceneId = null){
      if (timelineMode) closeTimelineMode();
      storyboardMode = true;
      document.body.classList.add('storyboard-mode');
      const overlay = document.getElementById('storyboardOverlay');
      if (overlay) overlay.setAttribute('aria-hidden', 'false');
      syncNavHeight();
      const scenes = getStoryboardScenes();
      let nextActiveId = activeSceneId;
      if (sceneId && scenes.some(scene => scene.id === sceneId)){
        nextActiveId = sceneId;
      } else if (!nextActiveId && scenes.length){
        nextActiveId = scenes[0].id;
      }
      const changed = nextActiveId && nextActiveId !== activeSceneId;
      if (nextActiveId) activeSceneId = nextActiveId;
      storyboardOverlaySceneId = activeSceneId || scenes[0]?.id || null;
      updateStoryboardButton();
      if (changed) render();
      else renderStoryboardGallery();
    }

    function closeStoryboardMode(){
      storyboardMode = false;
      document.body.classList.remove('storyboard-mode');
      const overlay = document.getElementById('storyboardOverlay');
      if (overlay) overlay.setAttribute('aria-hidden', 'true');
      storyboardOverlaySceneId = activeSceneId || storyboardOverlaySceneId || null;
      updateStoryboardButton();
    }

    function toggleStoryboardMode(){
      if (storyboardMode) closeStoryboardMode();
      else openStoryboardMode();
    }

    function renderTimeline(){
      const list = document.getElementById('timelineList');
      if (!list) return;
      list.innerHTML = '';
      const openBtn = document.createElement('button');
      openBtn.type = 'button';
      openBtn.className = 'timeline-item';
      openBtn.innerHTML = `
        <div class="timeline-bullet">‚Üó</div>
        <div class="timeline-body">
          <strong>Open Timeline Mode</strong>
          <span class="timeline-meta">Card view with drag & drop reordering</span>
        </div>`;
      openBtn.addEventListener('click', ()=> openTimelineMode());
      list.appendChild(openBtn);
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      if (!scenes.length){
        const empty = document.createElement('p');
        empty.className = 'timeline-empty';
        empty.textContent = 'No scenes yet.';
        list.appendChild(empty);
        return;
      }
      scenes.forEach((scene, idx)=>{
        const item = document.createElement('button');
        item.type = 'button';
        item.className = 'timeline-item' + (scene.id === activeSceneId ? ' active' : '');
        const beats = Array.isArray(scene.cards) ? scene.cards.length : 0;
        const snippet = getSceneSnippet(scene);
        const metaParts = [];
        metaParts.push(`Scene ${idx + 1}`);
        metaParts.push(beats ? `${beats} beat${beats === 1 ? '' : 's'}` : 'No beats tagged');
        if (snippet) metaParts.push(snippet);
        const metaText = metaParts.join(' ‚Ä¢ ');
        item.innerHTML = `
          <div class="timeline-bullet">${idx + 1}</div>
          <div class="timeline-body">
            <strong>${escapeHtml(scene.slug || '(no slug)')}</strong>
            <span class="timeline-meta">${escapeHtml(metaText)}</span>
          </div>`;
        item.addEventListener('click', ()=>{
          openTimelineMode(scene.id);
        });
        list.appendChild(item);
      });
    }

    function getSceneSnippet(scene){
      if (!scene || !Array.isArray(scene.elements)) return '';
      const text = scene.elements.map(el => (el?.txt || '')).join(' ');
      const clean = text.replace(/\s+/g, ' ').trim();
      if (!clean) return '';
      return clean.length > 160 ? `${clean.slice(0, 157)}‚Ä¶` : clean;
    }

    function renderTimelineBoard(){
      const board = document.getElementById('timelineBoard');
      if (!board) return;
      board.innerHTML = '';
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      if (!scenes.length){
        const empty = document.createElement('p');
        empty.className = 'timeline-empty';
        empty.textContent = 'No scenes yet.';
        board.appendChild(empty);
        timelineInsertIndex = 0;
        updateTimelineInsertLabel();
        return;
      }
      timelineInsertIndex = Math.max(0, Math.min(timelineInsertIndex, scenes.length));
      board.appendChild(createTimelineDropZone(0));
      scenes.forEach((scene, idx)=>{
        board.appendChild(createTimelineCard(scene, idx));
        board.appendChild(createTimelineDropZone(idx + 1));
      });
      board.querySelectorAll('.timeline-dropzone').forEach(zone=>{
        zone.classList.toggle('over', parseInt(zone.dataset.index || '0', 10) === timelineInsertIndex);
      });
      updateTimelineInsertLabel();
      if (timelinePendingPreviewId){
        const target = timelinePendingPreviewId;
        timelinePendingPreviewId = null;
        requestAnimationFrame(()=> openTimelinePreview(target));
      }
    }

    function createTimelineCard(scene, idx){
      const card = document.createElement('div');
      card.className = 'timeline-card' + (scene.id === activeSceneId ? ' active' : '');
      card.dataset.sceneId = scene.id;
      const colorMeta = getSceneColorMeta(scene);
      card.dataset.colorSource = colorMeta.source;
      card.draggable = true;
      const beats = Array.isArray(scene.cards) ? scene.cards.length : 0;
      const snippet = getSceneSnippet(scene) || 'Tap to add more detail.';
      const beatsLabel = beats ? `${beats} beat${beats === 1 ? '' : 's'}` : 'No beats yet';
      const colorTitle = colorMeta.tooltip || colorMeta.description || 'Scene color';
      const colorBorder = hexToRgba(colorMeta.textColor, 0.35);
      card.innerHTML = `
        <small>${escapeHtml(`Scene ${idx + 1}`)}</small>
        <h4>${escapeHtml(scene.slug || '(no slug)')}</h4>
        <p class="timeline-card-snippet">${escapeHtml(snippet)}</p>
        <div class="timeline-card-actions">
          <span>${escapeHtml(beatsLabel)}</span>
          <span class="timeline-card-color" title="${escapeHtml(colorTitle)}" style="background:${colorMeta.color};border-color:${colorBorder}"></span>
        </div>`;
      card.addEventListener('click', ()=>{
        if (timelineSuppressClick) return;
        openTimelinePreview(scene.id, card);
      });
      card.addEventListener('dragstart', (e)=>{
        timelineDragSceneId = scene.id;
        timelineSuppressClick = true;
        card.classList.add('dragging');
        if (e.dataTransfer){
          e.dataTransfer.effectAllowed = 'move';
          try { e.dataTransfer.setData('text/plain', scene.id); } catch(err){}
        }
      });
      card.addEventListener('dragend', ()=>{
        timelineDragSceneId = null;
        card.classList.remove('dragging');
        setTimeout(()=>{ timelineSuppressClick = false; }, 0);
        document.querySelectorAll('.timeline-dropzone.over').forEach(z=>z.classList.remove('over'));
      });
      return card;
    }

    function createTimelineDropZone(index){
      const zone = document.createElement('div');
      zone.className = 'timeline-dropzone';
      zone.dataset.index = index;
      zone.addEventListener('dragover', (e)=>{
        if (!timelineDragSceneId) return;
        e.preventDefault();
        zone.classList.add('over');
        if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
      });
      zone.addEventListener('dragleave', ()=> zone.classList.remove('over'));
      zone.addEventListener('drop', (e)=>{
        if (!timelineDragSceneId) return;
        e.preventDefault();
        zone.classList.remove('over');
        const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
        const fromIdx = scenes.findIndex(s=>s.id === timelineDragSceneId);
        let target = parseInt(zone.dataset.index || '0', 10);
        if (Number.isNaN(target) || fromIdx < 0) return;
        if (fromIdx < target) target = target - 1;
        target = Math.max(0, Math.min(target, scenes.length - 1));
        const preview = document.getElementById('timelinePreview');
        const openSceneId = preview?.dataset?.sceneId || null;
        if (openSceneId) timelinePendingPreviewId = openSceneId;
        moveScene(fromIdx, target);
      });
      const addBtn = document.createElement('button');
      addBtn.type = 'button';
      addBtn.className = 'timeline-add-btn';
      addBtn.innerHTML = '<span aria-hidden="true">Ôºã</span> Add Scene';
      addBtn.addEventListener('click', ()=>{
        prepareTimelineComposer(index);
      });
      zone.appendChild(addBtn);
      return zone;
    }

    function prepareTimelineComposer(index){
      timelineInsertIndex = Math.max(0, Math.min(index, Array.isArray(project?.scenes) ? project.scenes.length : 0));
      updateTimelineInsertLabel();
      document.querySelectorAll('.timeline-dropzone').forEach(zone=>{
        zone.classList.toggle('over', parseInt(zone.dataset.index || '0', 10) === timelineInsertIndex);
      });
      const input = document.getElementById('timelineNewSceneTitle');
      if (input){
        requestAnimationFrame(()=> input.focus());
      }
    }

    function updateTimelineInsertLabel(){
      const label = document.getElementById('timelinePositionLabel');
      if (!label) return;
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      const total = scenes.length;
      const idx = Math.max(0, Math.min(timelineInsertIndex, total));
      let text = 'Will insert at the end.';
      if (!total){
        text = 'This will become the first scene.';
      } else if (idx === 0){
        text = 'Will insert before Scene 1.';
      } else if (idx >= total){
        text = `Will insert after Scene ${total}.`;
      } else {
        text = `Will insert between Scene ${idx} and Scene ${idx + 1}.`;
      }
      label.textContent = text;
    }

    function handleTimelineAddScene(){
      const title = document.getElementById('timelineNewSceneTitle');
      const summary = document.getElementById('timelineNewSceneSummary');
      if (!title || !summary) return;
      const insertAt = Math.max(0, Math.min(timelineInsertIndex, Array.isArray(project?.scenes) ? project.scenes.length : 0));
      const scene = buildDefaultScene(title.value, summary.value);
      timelinePendingPreviewId = scene.id;
      timelineInsertIndex = insertAt + 1;
      title.value = '';
      summary.value = '';
      insertSceneAt(insertAt, scene);
      updateTimelineInsertLabel();
      requestAnimationFrame(()=>{
        const inputAgain = document.getElementById('timelineNewSceneTitle');
        if (inputAgain) inputAgain.focus();
      });
    }

    function moveScene(fromIdx, toIdx){
      if (fromIdx === toIdx) return;
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      if (fromIdx < 0 || fromIdx >= scenes.length) return;
      toIdx = Math.max(0, Math.min(toIdx, scenes.length - 1));
      const [scene] = scenes.splice(fromIdx, 1);
      scenes.splice(toIdx, 0, scene);
      timelineInsertIndex = toIdx + 1;
      const preview = document.getElementById('timelinePreview');
      const openSceneId = preview?.dataset?.sceneId || null;
      if (openSceneId) timelinePendingPreviewId = openSceneId;
      bumpVersion();
      scheduleSave();
      scheduleBackup();
      render();
    }

    function openTimelinePreview(sceneId, anchorEl){
      if (!sceneId) return;
      if (!timelineMode) openTimelineMode(sceneId);
      const preview = document.getElementById('timelinePreview');
      const titleEl = document.getElementById('timelinePreviewTitle');
      const metaEl = document.getElementById('timelinePreviewMeta');
      const bodyEl = document.getElementById('timelinePreviewBody');
      if (!preview || !titleEl || !metaEl || !bodyEl) return;
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      const scene = scenes.find(s=>s.id === sceneId);
      if (!scene) return;
      const idx = scenes.findIndex(s=>s.id === sceneId);
      const beats = Array.isArray(scene.cards) ? scene.cards.length : 0;
      const lineCount = Array.isArray(scene.elements) ? scene.elements.length : 0;
      const metaParts = [];
      if (idx >= 0) metaParts.push(`Scene ${idx + 1}`);
      if (beats) metaParts.push(`${beats} beat${beats === 1 ? '' : 's'}`);
      metaParts.push(`${lineCount} line${lineCount === 1 ? '' : 's'}`);
      titleEl.textContent = scene.slug || '(no slug)';
      metaEl.textContent = metaParts.join(' ‚Ä¢ ');
      bodyEl.innerHTML = (Array.isArray(scene.elements) ? scene.elements : [])
        .map(el => `<div class="line ${el.t}">${escapeHtml(el.txt || '')}</div>`)
        .join('') || '<div class="line action">...</div>';
      const openBtn = document.getElementById('timelinePreviewOpen');
      if (openBtn) openBtn.dataset.sceneId = scene.id;
      preview.dataset.sceneId = scene.id;
      const windowEl = document.querySelector('.timeline-window');
      const originEl = anchorEl || document.querySelector(`.timeline-card[data-scene-id="${scene.id}"]`);
      if (windowEl && originEl){
        const winRect = windowEl.getBoundingClientRect();
        const originRect = originEl.getBoundingClientRect();
        const originX = (originRect.left + originRect.width/2 - winRect.left) / winRect.width;
        const originY = (originRect.top + originRect.height/2 - winRect.top) / winRect.height;
        preview.style.setProperty('--origin-x', Math.min(Math.max(originX, 0), 1));
        preview.style.setProperty('--origin-y', Math.min(Math.max(originY, 0), 1));
      } else {
        preview.style.removeProperty('--origin-x');
        preview.style.removeProperty('--origin-y');
      }
      preview.classList.add('open');
      preview.setAttribute('aria-hidden', 'false');
    }

    function closeTimelinePreview(){
      const preview = document.getElementById('timelinePreview');
      if (!preview) return;
      preview.classList.remove('open');
      preview.setAttribute('aria-hidden', 'true');
      preview.removeAttribute('data-scene-id');
      const openBtn = document.getElementById('timelinePreviewOpen');
      if (openBtn) delete openBtn.dataset.sceneId;
    }

    function updateTimelineButton(){
      const btn = document.getElementById('timelineModeBtn');
      if (!btn) return;
      btn.textContent = timelineMode ? 'Exit Timeline' : 'Timeline';
      btn.setAttribute('aria-pressed', timelineMode ? 'true' : 'false');
    }

    function openTimelineMode(sceneId = null){
      if (storyboardMode) closeStoryboardMode();
      timelineMode = true;
      document.body.classList.add('timeline-mode');
      const overlay = document.getElementById('timelineOverlay');
      if (overlay) overlay.setAttribute('aria-hidden', 'false');
      updateTimelineButton();
      syncNavHeight();
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      if (sceneId){
        const idx = scenes.findIndex(s=>s.id === sceneId);
        timelineInsertIndex = idx >= 0 ? idx + 1 : scenes.length;
        timelinePendingPreviewId = sceneId;
      } else {
        timelineInsertIndex = scenes.length;
        timelinePendingPreviewId = null;
      }
      renderTimelineBoard();
    }

    function closeTimelineMode(){
      timelineMode = false;
      document.body.classList.remove('timeline-mode');
      const overlay = document.getElementById('timelineOverlay');
      if (overlay) overlay.setAttribute('aria-hidden', 'true');
      closeTimelinePreview();
      updateTimelineButton();
      document.querySelectorAll('.timeline-dropzone.over').forEach(z=>z.classList.remove('over'));
      timelineSuppressClick = false;
    }

    function toggleTimelineMode(){
      if (timelineMode) closeTimelineMode();
      else openTimelineMode();
    }

    function updateDeleteSceneButton(){
      const btn = document.getElementById('deleteSceneBtn');
      if (btn) btn.disabled = project.scenes.length <= 1;
    }

    /* =========================
     * Character Studio
     * =======================*/
    const CHARACTER_LOOK_LABELS = {
      portrait: 'Portrait',
      turnaround: 'Turnaround Sheet',
      expression: 'Expression Sheet'
    };

    function getCharacterById(id){
      if (!id) return null;
      const list = project?.catalogs?.characters;
      if (!Array.isArray(list)) return null;
      return list.find(c => c.id === id) || null;
    }

    function parseMultilineListInput(value){
      return normalizeList(value || '');
    }

    function parseIntegerInput(value){
      const num = parseInt(value, 10);
      return Number.isFinite(num) && num >= 0 ? num : 0;
    }

    function parseFloatInput(value){
      const num = parseFloat(value);
      return Number.isFinite(num) && num >= 0 ? Number(num.toFixed(2)) : 0;
    }

    function buildCharacterSubheading(character){
      if (!character) return '';
      const parts = [];
      if (character.role) parts.push(character.role);
      const identity = [character.pronouns, character.age].filter(Boolean).join(' ‚Ä¢ ');
      if (identity) parts.push(identity);
      if (character.archetype) parts.push(character.archetype);
      return parts.join(' ‚Äî ');
    }

    function characterSidebarMeta(character){
      if (!character) return '';
      if (character.role) return character.role;
      if (character.archetype) return character.archetype;
      const identity = [character.pronouns, character.age].filter(Boolean).join(' ‚Ä¢ ');
      if (identity) return identity;
      return 'Tap to detail profile';
    }

    function buildTraitsPreviewMarkup(character){
      const traits = Array.isArray(character?.traits) ? character.traits : [];
      if (!traits.length) return '<span class="muted-text">Add traits to see quick reference chips.</span>';
      return traits.map(trait => `<span class="character-studio-chip">${escapeHtml(trait)}</span>`).join('');
    }

    function characterLookPreviewMarkup(kind, url, character){
      const label = CHARACTER_LOOK_LABELS[kind] || 'Reference';
      const name = character?.name ? character.name : 'Character';
      if (url){
        return `<img src="${escapeHtml(url)}" alt="${escapeHtml(`${name} ${label.toLowerCase()}`)}" />`;
      }
      return `<div class="character-studio-look-empty">Add a ${escapeHtml(label.toLowerCase())} URL to preview.</div>`;
    }

    function updateCharacterPreview(kind, character){
      const overlay = document.getElementById('characterStudioOverlay');
      if (!overlay) return;
      const slot = overlay.querySelector(`[data-look-preview="${kind}"]`);
      if (!slot) return;
      let url = '';
      if (kind === 'portrait') url = (character?.looks?.portrait || '').trim();
      else if (kind === 'turnaround') url = (Array.isArray(character?.looks?.turnarounds) ? character.looks.turnarounds[0] : '') || '';
      else if (kind === 'expression') url = (Array.isArray(character?.looks?.expressions) ? character.looks.expressions[0] : '') || '';
      slot.innerHTML = characterLookPreviewMarkup(kind, url, character);
    }

    function refreshCharacterTraitsPreview(character){
      const overlay = document.getElementById('characterStudioOverlay');
      if (!overlay) return;
      const target = overlay.querySelector('[data-traits-preview]');
      if (target) target.innerHTML = buildTraitsPreviewMarkup(character);
    }

    function refreshCharacterStudioMeta(character){
      const overlay = document.getElementById('characterStudioOverlay');
      if (!overlay) return;
      const heading = overlay.querySelector('[data-character-heading]');
      if (heading) heading.textContent = character?.name ? character.name : 'Untitled Character';
      const subheading = overlay.querySelector('[data-character-subheading]');
      if (subheading){
        const text = buildCharacterSubheading(character);
        subheading.textContent = text || 'Add role, pronouns, or age details.';
      }
    }

    function escapeAttrSelector(value){
      return String(value).replace(/["\\]/g, '\\$&');
    }

    function refreshCharacterStudioListItem(id){
      const overlay = document.getElementById('characterStudioOverlay');
      if (!overlay) return;
      const item = overlay.querySelector(`[data-character-item="${escapeAttrSelector(id)}"]`);
      if (!item) return;
      const char = getCharacterById(id);
      if (!char) return;
      const title = item.querySelector('strong');
      if (title) title.textContent = char.name || 'Untitled Character';
      const meta = item.querySelector('span');
      if (meta) meta.textContent = characterSidebarMeta(char);
      item.classList.toggle('active', char.id === characterStudioState.activeId);
    }

    function updateCharacterField(id, path, value){
      const char = getCharacterById(id);
      if (!char) return;
      const before = JSON.stringify(char);
      const parts = path.split('.');
      let target = char;
      for (let i = 0; i < parts.length - 1; i++){
        const key = parts[i];
        if (typeof target[key] !== 'object' || target[key] === null) target[key] = {};
        target = target[key];
      }
      target[parts[parts.length - 1]] = value;
      const after = JSON.stringify(char);
      if (before === after) return;
      bumpVersion();
      scheduleSave();
      scheduleBackup();
      renderCatalogs();
    }

    function renderCharacterStudio(){
      const overlay = document.getElementById('characterStudioOverlay');
      if (!overlay) return;
      const listEl = overlay.querySelector('[data-character-list]');
      const detailsEl = overlay.querySelector('[data-character-details]');
      if (!listEl || !detailsEl) return;
      const characters = Array.isArray(project?.catalogs?.characters) ? project.catalogs.characters : [];
      listEl.innerHTML = '';
      if (!characters.length){
        const empty = document.createElement('div');
        empty.className = 'character-studio-empty-list';
        empty.textContent = 'No characters yet.';
        listEl.appendChild(empty);
        detailsEl.innerHTML = `
          <div class="character-studio-empty">
            <h2>No characters yet</h2>
            <p>Add a character to start building their profile, traits, and arc.</p>
          </div>`;
        return;
      }
      if (!characterStudioState.activeId || !characters.some(c => c.id === characterStudioState.activeId)){
        characterStudioState.activeId = characters[0].id;
      }
      characters.forEach(char => {
        const item = document.createElement('button');
        item.type = 'button';
        item.className = 'character-studio-list-item' + (char.id === characterStudioState.activeId ? ' active' : '');
        item.dataset.characterItem = char.id;
        item.innerHTML = `<strong>${escapeHtml(char.name || 'Untitled Character')}</strong><span>${escapeHtml(characterSidebarMeta(char))}</span>`;
        item.addEventListener('click', ()=>{
          if (characterStudioState.activeId === char.id) return;
          characterStudioState.activeId = char.id;
          renderCharacterStudio();
        });
        listEl.appendChild(item);
      });

      const active = getCharacterById(characterStudioState.activeId);
      if (!active){
        detailsEl.innerHTML = `
          <div class="character-studio-empty">
            <h2>No character selected</h2>
            <p>Choose a character from the left to start planning.</p>
          </div>`;
        return;
      }

      const traitsText = Array.isArray(active.traits) ? active.traits.join('\n') : (active.traits || '');
      const turnaroundsText = Array.isArray(active.looks?.turnarounds) ? active.looks.turnarounds.join('\n') : '';
      const expressionsText = Array.isArray(active.looks?.expressions) ? active.looks.expressions.join('\n') : '';
      const portraitUrl = (active.looks?.portrait || '').trim();
      const turnaroundPreview = (Array.isArray(active.looks?.turnarounds) ? active.looks.turnarounds[0] : '') || '';
      const expressionPreview = (Array.isArray(active.looks?.expressions) ? active.looks.expressions[0] : '') || '';
      const statsScenes = Number.isFinite(active.stats?.scenes) ? active.stats.scenes : 0;
      const statsDialogue = Number.isFinite(active.stats?.dialogue) ? active.stats.dialogue : 0;
      const statsScreenTime = Number.isFinite(active.stats?.screenTime) ? active.stats.screenTime : 0;
      const subheading = buildCharacterSubheading(active);
      const traitsPreview = buildTraitsPreviewMarkup(active);
      const aiPrompt = active.ai?.prompt || '';
      const aiNotes = active.ai?.notes || '';

      detailsEl.innerHTML = `
        <div class="character-studio-detail-header">
          <div>
            <h2 data-character-heading>${escapeHtml(active.name || 'Untitled Character')}</h2>
            <p class="muted-text" data-character-subheading>${escapeHtml(subheading || 'Add role, pronouns, or age details.')}</p>
          </div>
          <div class="character-studio-header-actions">
            <button class="character-studio-tertiary" type="button" data-character-delete>Delete Character</button>
          </div>
        </div>
        <section class="character-studio-section">
          <h3>Profile</h3>
          <p class="muted-text">Keep the essentials handy when writing.</p>
          <div class="character-studio-two-col">
            <label class="character-studio-field">
              <span>Name</span>
              <input type="text" value="${escapeHtml(active.name || '')}" data-character-field="name" placeholder="Character name" />
            </label>
            <label class="character-studio-field">
              <span>Role</span>
              <input type="text" value="${escapeHtml(active.role || '')}" data-character-field="role" placeholder="Protagonist, Antagonist..." />
            </label>
            <label class="character-studio-field">
              <span>Archetype</span>
              <input type="text" value="${escapeHtml(active.archetype || '')}" data-character-field="archetype" placeholder="e.g. Reluctant hero" />
            </label>
            <label class="character-studio-field">
              <span>Pronouns</span>
              <input type="text" value="${escapeHtml(active.pronouns || '')}" data-character-field="pronouns" placeholder="They/Them" />
            </label>
            <label class="character-studio-field">
              <span>Age</span>
              <input type="text" value="${escapeHtml(active.age || '')}" data-character-field="age" placeholder="32" />
            </label>
          </div>
          <label class="character-studio-field">
            <span>Summary</span>
            <textarea class="small" data-character-field="summary" placeholder="Logline summary">${escapeHtml(active.summary || '')}</textarea>
          </label>
        </section>
        <section class="character-studio-section">
          <h3>Stats &amp; Spotlight</h3>
          <p class="muted-text">Track how often this character appears in the script.</p>
          <div class="character-studio-stats-grid">
            <div class="character-studio-stat">
              <span class="character-studio-stat-value" data-character-stat="scenes">${escapeHtml(String(statsScenes))}</span>
              <span class="character-studio-stat-label">Scenes</span>
            </div>
            <div class="character-studio-stat">
              <span class="character-studio-stat-value" data-character-stat="dialogue">${escapeHtml(String(statsDialogue))}</span>
              <span class="character-studio-stat-label">Dialogue Lines</span>
            </div>
            <div class="character-studio-stat">
              <span class="character-studio-stat-value" data-character-stat="screenTime">${escapeHtml(String(statsScreenTime))}</span>
              <span class="character-studio-stat-label">Estimated Minutes</span>
            </div>
          </div>
          <div class="character-studio-two-col">
            <label class="character-studio-field">
              <span>Total scenes</span>
              <input type="number" min="0" value="${escapeHtml(String(statsScenes))}" data-character-field="stats.scenes" />
            </label>
            <label class="character-studio-field">
              <span>Dialogue lines</span>
              <input type="number" min="0" value="${escapeHtml(String(statsDialogue))}" data-character-field="stats.dialogue" />
            </label>
            <label class="character-studio-field">
              <span>Screen time (minutes)</span>
              <input type="number" min="0" step="0.1" value="${escapeHtml(String(statsScreenTime))}" data-character-field="stats.screenTime" />
            </label>
          </div>
        </section>
        <section class="character-studio-section">
          <h3>Traits &amp; Personality</h3>
          <p class="muted-text">List defining qualities, habits, and secrets.</p>
          <div class="character-studio-traits-preview" data-traits-preview>${traitsPreview}</div>
          <label class="character-studio-field">
            <span>Traits (one per line)</span>
            <textarea data-character-field="traits" placeholder="Resilient&#10;Impulsive&#10;Secret romantic">${escapeHtml(traitsText)}</textarea>
          </label>
        </section>
        <section class="character-studio-section">
          <h3>Background &amp; Family</h3>
          <div class="character-studio-two-col">
            <label class="character-studio-field">
              <span>Background story</span>
              <textarea data-character-field="background" placeholder="Origin story, formative experiences">${escapeHtml(active.background || '')}</textarea>
            </label>
            <label class="character-studio-field">
              <span>Family tree / relationships</span>
              <textarea data-character-field="familyTree" placeholder="Parents, siblings, key relationships">${escapeHtml(active.familyTree || '')}</textarea>
            </label>
          </div>
        </section>
        <section class="character-studio-section">
          <h3>Character Arc</h3>
          <p class="muted-text">Map how the character transforms across the story.</p>
          <div class="character-studio-two-col">
            <label class="character-studio-field">
              <span>Setup</span>
              <textarea data-character-field="arc.setup" placeholder="Who are they at the beginning?">${escapeHtml(active.arc?.setup || '')}</textarea>
            </label>
            <label class="character-studio-field">
              <span>Development</span>
              <textarea data-character-field="arc.development" placeholder="Challenges, midpoint, reversals">${escapeHtml(active.arc?.development || '')}</textarea>
            </label>
            <label class="character-studio-field">
              <span>Resolution</span>
              <textarea data-character-field="arc.resolution" placeholder="Where do they end up?">${escapeHtml(active.arc?.resolution || '')}</textarea>
            </label>
          </div>
        </section>
        <section class="character-studio-section">
          <h3>Lookbook</h3>
          <p class="muted-text">Collect portrait, turnaround, and expression references.</p>
          <div class="character-studio-two-col">
            <label class="character-studio-field">
              <span>Portrait URL</span>
              <input type="url" data-character-field="looks.portrait" value="${escapeHtml(portraitUrl)}" placeholder="https://..." />
            </label>
            <label class="character-studio-field">
              <span>Turnarounds (one per line)</span>
              <textarea data-character-field="looks.turnarounds" class="small" placeholder="Link to turnaround sheets">${escapeHtml(turnaroundsText)}</textarea>
            </label>
            <label class="character-studio-field">
              <span>Expression sheets (one per line)</span>
              <textarea data-character-field="looks.expressions" class="small" placeholder="Link to expressions">${escapeHtml(expressionsText)}</textarea>
            </label>
          </div>
          <div class="character-studio-look-grid">
            <div class="character-studio-look-card" data-look-preview="portrait">
              <span class="character-studio-look-label">Portrait</span>
              ${characterLookPreviewMarkup('portrait', portraitUrl, active)}
            </div>
            <div class="character-studio-look-card" data-look-preview="turnaround">
              <span class="character-studio-look-label">Turnaround</span>
              ${characterLookPreviewMarkup('turnaround', turnaroundPreview, active)}
            </div>
            <div class="character-studio-look-card" data-look-preview="expression">
              <span class="character-studio-look-label">Expressions</span>
              ${characterLookPreviewMarkup('expression', expressionPreview, active)}
            </div>
          </div>
        </section>
        <section class="character-studio-section">
          <h3>AI Concepting</h3>
          <p class="muted-text">Draft prompts for StudioOrganize AI or export for other tools.</p>
          <label class="character-studio-field">
            <span>AI prompt</span>
            <textarea data-character-field="ai.prompt" placeholder="Describe the character's look, vibe, and scene">${escapeHtml(aiPrompt)}</textarea>
          </label>
          <label class="character-studio-field">
            <span>Notes / references</span>
            <textarea data-character-field="ai.notes" class="small" placeholder="Shot list, wardrobe callouts, artist references">${escapeHtml(aiNotes)}</textarea>
          </label>
          <div class="character-studio-ai-actions">
            <button type="button" data-character-ai-generate>Save prompt &amp; prep AI render</button>
            <span class="character-studio-status" data-ai-status></span>
          </div>
        </section>
      `;

      bindCharacterStudioFields(detailsEl, active);
    }

    function bindCharacterStudioFields(container, active){
      if (!container || !active) return;
      const id = active.id;
      const aiStatus = container.querySelector('[data-ai-status]');
      const clearAiStatus = ()=>{
        if (aiStatus){
          aiStatus.textContent = '';
          aiStatus.removeAttribute('data-state');
        }
      };

      const nameInput = container.querySelector('[data-character-field="name"]');
      if (nameInput){
        nameInput.addEventListener('input', e=>{
          updateCharacterField(id, 'name', e.target.value);
          refreshCharacterStudioListItem(id);
          refreshCharacterStudioMeta(active);
          updateCharacterPreview('portrait', active);
          updateCharacterPreview('turnaround', active);
          updateCharacterPreview('expression', active);
        });
      }

      const roleInput = container.querySelector('[data-character-field="role"]');
      if (roleInput){
        roleInput.addEventListener('input', e=>{
          updateCharacterField(id, 'role', e.target.value.trim());
          refreshCharacterStudioListItem(id);
          refreshCharacterStudioMeta(active);
        });
      }

      const archetypeInput = container.querySelector('[data-character-field="archetype"]');
      if (archetypeInput){
        archetypeInput.addEventListener('input', e=>{
          updateCharacterField(id, 'archetype', e.target.value.trim());
          refreshCharacterStudioListItem(id);
          refreshCharacterStudioMeta(active);
        });
      }

      const pronounInput = container.querySelector('[data-character-field="pronouns"]');
      if (pronounInput){
        pronounInput.addEventListener('input', e=>{
          updateCharacterField(id, 'pronouns', e.target.value.trim());
          refreshCharacterStudioListItem(id);
          refreshCharacterStudioMeta(active);
        });
      }

      const ageInput = container.querySelector('[data-character-field="age"]');
      if (ageInput){
        ageInput.addEventListener('input', e=>{
          updateCharacterField(id, 'age', e.target.value.trim());
          refreshCharacterStudioListItem(id);
          refreshCharacterStudioMeta(active);
        });
      }

      const summaryInput = container.querySelector('[data-character-field="summary"]');
      if (summaryInput){
        summaryInput.addEventListener('input', e=>{
          updateCharacterField(id, 'summary', e.target.value);
        });
      }

      const scenesInput = container.querySelector('[data-character-field="stats.scenes"]');
      if (scenesInput){
        scenesInput.addEventListener('input', e=>{
          const value = parseIntegerInput(e.target.value);
          updateCharacterField(id, 'stats.scenes', value);
          const statEl = container.querySelector('[data-character-stat="scenes"]');
          if (statEl) statEl.textContent = value;
        });
      }

      const dialogueInput = container.querySelector('[data-character-field="stats.dialogue"]');
      if (dialogueInput){
        dialogueInput.addEventListener('input', e=>{
          const value = parseIntegerInput(e.target.value);
          updateCharacterField(id, 'stats.dialogue', value);
          const statEl = container.querySelector('[data-character-stat="dialogue"]');
          if (statEl) statEl.textContent = value;
        });
      }

      const screenTimeInput = container.querySelector('[data-character-field="stats.screenTime"]');
      if (screenTimeInput){
        screenTimeInput.addEventListener('input', e=>{
          const value = parseFloatInput(e.target.value);
          updateCharacterField(id, 'stats.screenTime', value);
          const statEl = container.querySelector('[data-character-stat="screenTime"]');
          if (statEl) statEl.textContent = value;
        });
      }

      const traitsInput = container.querySelector('[data-character-field="traits"]');
      if (traitsInput){
        traitsInput.addEventListener('input', e=>{
          const list = parseMultilineListInput(e.target.value);
          updateCharacterField(id, 'traits', list);
          refreshCharacterTraitsPreview(active);
        });
      }

      const backgroundInput = container.querySelector('[data-character-field="background"]');
      if (backgroundInput){
        backgroundInput.addEventListener('input', e=>{
          updateCharacterField(id, 'background', e.target.value);
        });
      }

      const familyInput = container.querySelector('[data-character-field="familyTree"]');
      if (familyInput){
        familyInput.addEventListener('input', e=>{
          updateCharacterField(id, 'familyTree', e.target.value);
        });
      }

      const arcSetupInput = container.querySelector('[data-character-field="arc.setup"]');
      if (arcSetupInput){
        arcSetupInput.addEventListener('input', e=>{
          updateCharacterField(id, 'arc.setup', e.target.value);
        });
      }

      const arcDevInput = container.querySelector('[data-character-field="arc.development"]');
      if (arcDevInput){
        arcDevInput.addEventListener('input', e=>{
          updateCharacterField(id, 'arc.development', e.target.value);
        });
      }

      const arcResolutionInput = container.querySelector('[data-character-field="arc.resolution"]');
      if (arcResolutionInput){
        arcResolutionInput.addEventListener('input', e=>{
          updateCharacterField(id, 'arc.resolution', e.target.value);
        });
      }

      const portraitInput = container.querySelector('[data-character-field="looks.portrait"]');
      if (portraitInput){
        portraitInput.addEventListener('input', e=>{
          const value = e.target.value.trim();
          updateCharacterField(id, 'looks.portrait', value);
          updateCharacterPreview('portrait', active);
        });
      }

      const turnaroundsInput = container.querySelector('[data-character-field="looks.turnarounds"]');
      if (turnaroundsInput){
        turnaroundsInput.addEventListener('input', e=>{
          const list = parseMultilineListInput(e.target.value);
          updateCharacterField(id, 'looks.turnarounds', list);
          updateCharacterPreview('turnaround', active);
        });
      }

      const expressionsInput = container.querySelector('[data-character-field="looks.expressions"]');
      if (expressionsInput){
        expressionsInput.addEventListener('input', e=>{
          const list = parseMultilineListInput(e.target.value);
          updateCharacterField(id, 'looks.expressions', list);
          updateCharacterPreview('expression', active);
        });
      }

      const promptInput = container.querySelector('[data-character-field="ai.prompt"]');
      if (promptInput){
        promptInput.addEventListener('input', e=>{
          updateCharacterField(id, 'ai.prompt', e.target.value);
          clearAiStatus();
        });
      }

      const notesInput = container.querySelector('[data-character-field="ai.notes"]');
      if (notesInput){
        notesInput.addEventListener('input', e=>{
          updateCharacterField(id, 'ai.notes', e.target.value);
          clearAiStatus();
        });
      }

      const aiButton = container.querySelector('[data-character-ai-generate]');
      if (aiButton){
        aiButton.addEventListener('click', ()=>{
          const prompt = (active.ai?.prompt || '').trim();
          if (!prompt){
            if (aiStatus){
              aiStatus.textContent = 'Add an AI prompt to generate concept art.';
              aiStatus.dataset.state = 'warning';
            }
            return;
          }
          if (aiStatus){
            aiStatus.textContent = 'Prompt saved! Connect to StudioOrganize AI to generate character images.';
            aiStatus.dataset.state = 'ready';
          }
        });
      }

      const deleteBtn = container.querySelector('[data-character-delete]');
      if (deleteBtn){
        deleteBtn.addEventListener('click', ()=>{
          const name = active.name || 'this character';
          const ok = confirm(`Delete ${name}? This will remove their notes and stats.`);
          if (!ok) return;
          const currentId = active.id;
          removeCharacter(currentId);
          const characters = Array.isArray(project?.catalogs?.characters) ? project.catalogs.characters : [];
          if (characters.length){
            characterStudioState.activeId = characters[0].id;
          } else {
            characterStudioState.activeId = null;
          }
          renderCharacterStudio();
        });
      }
    }

    function openCharacterStudio(characterId = null){
      const overlay = document.getElementById('characterStudioOverlay');
      if (!overlay) return;
      if (timelineMode) closeTimelineMode();
      characterStudioState.open = true;
      if (characterId) characterStudioState.activeId = characterId;
      overlay.setAttribute('aria-hidden', 'false');
      document.body.classList.add('character-studio-mode');
      renderCharacterStudio();
      const windowEl = overlay.querySelector('.character-studio-window');
      if (windowEl && typeof windowEl.focus === 'function'){
        windowEl.focus();
      }
    }

    function closeCharacterStudio(){
      const overlay = document.getElementById('characterStudioOverlay');
      if (!overlay) return;
      characterStudioState.open = false;
      overlay.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('character-studio-mode');
      const trigger = document.getElementById('openCharacterStudioBtn');
      if (trigger && typeof trigger.focus === 'function') trigger.focus();
    }

    /* =========================
     * Catalog helpers
     * =======================*/
    function addCharacter(name){
      const trimmed = (name || '').trim();
      if (!trimmed) return null;
      project.catalogs = project.catalogs || {};
      project.catalogs.characters = project.catalogs.characters || [];
      const character = createCharacterData(trimmed);
      project.catalogs.characters.push(character);
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
      return character;
    }

    function removeCharacter(id){
      project.catalogs = project.catalogs || {};
      project.catalogs.characters = (project.catalogs.characters || []).filter(c=>c.id !== id);
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
    }

    function addLocation(name){
      const trimmed = (name || '').trim();
      if (!trimmed) return;
      project.catalogs = project.catalogs || {};
      project.catalogs.locations = project.catalogs.locations || [];
      project.catalogs.locations.push({ id: randomId(), name: trimmed });
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
    }

    function removeLocation(id){
      project.catalogs = project.catalogs || {};
      project.catalogs.locations = (project.catalogs.locations || []).filter(l=>l.id !== id);
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
    }

    function addSoundCue(text){
      const scene = getActiveScene();
      if (!scene) return;
      const trimmed = (text || '').trim();
      if (!trimmed) return;
      scene.sounds = scene.sounds || [];
      scene.sounds.push({ id: randomId(), cue: trimmed });
      updateSceneHash(scene);
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
    }

    function removeSoundCue(id){
      const scene = getActiveScene();
      if (!scene) return;
      scene.sounds = (scene.sounds || []).filter(s=>s.id !== id);
      updateSceneHash(scene);
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
    }

    function setSceneSlugPart(kind, value){
      const input = document.getElementById('sceneSlug');
      const scene = getActiveScene();
      if (!input || !scene) return;
      const upperValue = (value || '').toUpperCase();
      let slug = (input.value || scene.slug || '').toUpperCase();
      if (kind === 'prefix'){
        slug = slug.replace(/^(INT\.|EXT\.|INT-EXT\.|INT\/EXT\.)\s*/, '');
        slug = slug.replace(/^\s+/, '');
        slug = `${upperValue} ${slug}`.trim();
      } else if (kind === 'suffix'){
        slug = slug.replace(/\s*-\s*(DAY|NIGHT)$/i, '').trim();
        slug = slug ? `${slug} - ${upperValue}` : upperValue;
      }
      slug = slug.replace(/\s+/g, ' ').trim();
      input.value = slug;
      input.dispatchEvent(new Event('input', { bubbles: true }));
    }

    /* =========================
     * Scene helpers
     * =======================*/
    function getActiveScene(){ return project.scenes.find(s=>s.id===activeSceneId); }
    function buildDefaultScene(slug, summary){
      const trimmedSlug = typeof slug === 'string' ? slug.trim() : '';
      const trimmedSummary = typeof summary === 'string' ? summary.trim() : '';
      const scene = {
        id: randomId(),
        slug: trimmedSlug || 'EXT. NEW PLACE - DAY',
        cards: [],
        elements: [],
        color: DEFAULT_SCENE_COLOR,
        colorSource: SCENE_COLOR_SOURCE_AUTO,
        notes: '',
        sounds: [],
        storyboards: [],
        metadata: { sceneColorSource: SCENE_COLOR_SOURCE_AUTO, sceneTagState: { locationType: '', timeOfDay: '', custom: [] } }
      };
      if (trimmedSummary){
        scene.elements = trimmedSummary
          .split(/\n+/)
          .map(line => line.trim())
          .filter(Boolean)
          .map(line => createSceneElement('action', line));
      }
      if (!scene.elements.length){
        scene.elements = [createSceneElement('action', '...')];
      }
      return scene;
    }
    function sanitizeSceneCustomTags(tags){
      const list = Array.isArray(tags) ? tags : [];
      const seen = new Set();
      const normalized = [];
      for (const tag of list){
        const trimmed = typeof tag === 'string' ? tag.trim() : '';
        if (!trimmed) continue;
        const upper = trimmed.toUpperCase();
        if (seen.has(upper)) continue;
        seen.add(upper);
        normalized.push(upper);
        if (normalized.length >= SCENE_TAG_MAX_CUSTOM) break;
      }
      return normalized;
    }
    function getSceneTagState(scene){
      if (!scene || typeof scene !== 'object') return { locationType: '', timeOfDay: '', custom: [] };
      if (!scene.metadata || typeof scene.metadata !== 'object') scene.metadata = {};
      const raw = scene.metadata.sceneTagState && typeof scene.metadata.sceneTagState === 'object' ? scene.metadata.sceneTagState : {};
      const locationType = typeof raw.locationType === 'string' ? raw.locationType : '';
      const timeOfDay = typeof raw.timeOfDay === 'string' ? raw.timeOfDay : '';
      const custom = sanitizeSceneCustomTags(raw.custom);
      scene.metadata.sceneTagState = { locationType, timeOfDay, custom: [...custom] };
      return { locationType, timeOfDay, custom: [...custom] };
    }
    function getSceneNameTags(scene){
      const state = getSceneTagState(scene);
      const tags = [];
      if (state.locationType) tags.push(state.locationType);
      if (state.timeOfDay) tags.push(state.timeOfDay);
      state.custom.forEach(tag => tags.push(tag));
      return tags;
    }
    function arraysEqual(a, b){
      if (a === b) return true;
      if (!Array.isArray(a) || !Array.isArray(b)) return false;
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++){
        if (a[i] !== b[i]) return false;
      }
      return true;
    }
    function updateSceneTagState(scene, updates){
      if (!scene) return;
      const current = getSceneTagState(scene);
      const next = {
        locationType: updates && Object.prototype.hasOwnProperty.call(updates, 'locationType') ? (updates.locationType || '') : current.locationType,
        timeOfDay: updates && Object.prototype.hasOwnProperty.call(updates, 'timeOfDay') ? (updates.timeOfDay || '') : current.timeOfDay,
        custom: updates && Object.prototype.hasOwnProperty.call(updates, 'custom') ? sanitizeSceneCustomTags(updates.custom) : current.custom
      };
      if (next.locationType === current.locationType && next.timeOfDay === current.timeOfDay && arraysEqual(next.custom, current.custom)){
        return;
      }
      if (!scene.metadata || typeof scene.metadata !== 'object') scene.metadata = {};
      scene.metadata.sceneTagState = { locationType: next.locationType, timeOfDay: next.timeOfDay, custom: [...next.custom] };
      updateSceneHash(scene);
      bumpVersion();
      scheduleSave();
      scheduleBackup();
      render();
    }
    function addSceneCustomTag(scene, value){
      if (!scene) return;
      const trimmed = typeof value === 'string' ? value.trim() : '';
      if (!trimmed) return;
      const upper = trimmed.toUpperCase();
      const state = getSceneTagState(scene);
      if (state.custom.length >= SCENE_TAG_MAX_CUSTOM) return;
      if (state.custom.includes(upper)) return;
      const next = [...state.custom, upper];
      updateSceneTagState(scene, { custom: next });
    }
    function removeSceneCustomTag(scene, value){
      if (!scene) return;
      const trimmed = typeof value === 'string' ? value.trim() : '';
      if (!trimmed) return;
      const upper = trimmed.toUpperCase();
      const state = getSceneTagState(scene);
      const next = state.custom.filter(tag => tag !== upper);
      updateSceneTagState(scene, { custom: next });
    }
    function buildSceneCardPopoverHtml(scene){
      const state = getSceneTagState(scene);
      const locationButtons = SCENE_LOCATION_TYPES.map(option => {
        const value = option.value;
        const pressed = state.locationType === value ? 'true' : 'false';
        const title = option.label || option.value;
        return `<button type="button" class="scene-card-chip" data-scene-location-option="${escapeHtml(value)}" aria-pressed="${pressed}" title="${escapeHtml(title)}">${escapeHtml(option.value)}</button>`;
      }).join('');
      const timeButtons = SCENE_TIME_OF_DAY_OPTIONS.map(option => {
        const value = option.value;
        const pressed = state.timeOfDay === value ? 'true' : 'false';
        return `<button type="button" class="scene-card-chip" data-scene-time-option="${escapeHtml(value)}" aria-pressed="${pressed}">${escapeHtml(option.label)}</button>`;
      }).join('');
      const customTags = state.custom.length
        ? state.custom.map(tag => `<button type="button" class="scene-card-chip" data-role="remove" data-scene-remove-custom="${escapeHtml(tag)}" aria-label="Remove tag ${escapeHtml(tag)}"><span>${escapeHtml(tag)}</span><span aria-hidden="true">√ó</span></button>`).join('')
        : '<span class="scene-card-chip" data-empty="true">No custom tags yet</span>';
      const inputId = `scene-custom-tag-${scene.id}`;
      const disableAdd = state.custom.length >= SCENE_TAG_MAX_CUSTOM;
      const customPlaceholder = disableAdd ? 'Tag limit reached' : 'e.g. FLASHBACK';
      return `
        <div class="scene-card-popover-section">
          <p class="scene-card-popover-title">Scene type</p>
          <div class="scene-card-chip-row" data-scene-location-row>${locationButtons}</div>
        </div>
        <div class="scene-card-popover-section">
          <p class="scene-card-popover-title">Time of day</p>
          <div class="scene-card-chip-row" data-scene-time-row>${timeButtons}</div>
        </div>
        <div class="scene-card-popover-section">
          <p class="scene-card-popover-title">Custom tags</p>
          <div class="scene-card-popover-actions">
            <input type="text" id="${escapeHtml(inputId)}" data-scene-custom-input placeholder="${escapeHtml(customPlaceholder)}" maxlength="24" autocomplete="off" />
            <button type="button" data-scene-add-custom ${disableAdd ? 'disabled' : ''} title="${escapeHtml(disableAdd ? 'Maximum of four custom tags saved per scene' : 'Add custom tag')}">Add</button>
          </div>
          <div class="scene-card-chip-row" data-scene-custom-row>${customTags}</div>
        </div>`;
    }
    function setupSceneCardPopover(popover, scene){
      if (!popover || !scene) return;
      const state = getSceneTagState(scene);
      const handleLocationToggle = (value)=>{
        const current = getSceneTagState(scene);
        const nextValue = current.locationType === value ? '' : value;
        updateSceneTagState(scene, { locationType: nextValue });
      };
      popover.querySelectorAll('[data-scene-location-option]').forEach(btn => {
        btn.addEventListener('click', event => {
          event.stopPropagation();
          event.preventDefault();
          handleLocationToggle(btn.dataset.sceneLocationOption || '');
        });
      });
      const handleTimeToggle = (value)=>{
        const current = getSceneTagState(scene);
        const nextValue = current.timeOfDay === value ? '' : value;
        updateSceneTagState(scene, { timeOfDay: nextValue });
      };
      popover.querySelectorAll('[data-scene-time-option]').forEach(btn => {
        btn.addEventListener('click', event => {
          event.stopPropagation();
          event.preventDefault();
          handleTimeToggle(btn.dataset.sceneTimeOption || '');
        });
      });
      popover.querySelectorAll('[data-scene-remove-custom]').forEach(btn => {
        btn.addEventListener('click', event => {
          event.stopPropagation();
          event.preventDefault();
          removeSceneCustomTag(scene, btn.dataset.sceneRemoveCustom || '');
        });
      });
      const input = popover.querySelector('[data-scene-custom-input]');
      const addBtn = popover.querySelector('[data-scene-add-custom]');
      const submitInput = ()=>{
        if (!input) return;
        addSceneCustomTag(scene, input.value || '');
        input.value = '';
      };
      if (addBtn){
        addBtn.disabled = state.custom.length >= SCENE_TAG_MAX_CUSTOM;
        addBtn.addEventListener('click', event => {
          event.stopPropagation();
          event.preventDefault();
          submitInput();
        });
      }
      if (input){
        input.disabled = state.custom.length >= SCENE_TAG_MAX_CUSTOM;
        input.addEventListener('click', event => event.stopPropagation());
        input.addEventListener('keydown', event => {
          if (event.key === 'Enter'){
            event.preventDefault();
            submitInput();
            return;
          }
          if (event.key === 'Escape'){
            event.preventDefault();
            event.stopPropagation();
            scenePopoverOpenId = null;
            render();
            return;
          }
          event.stopPropagation();
        });
      }
    }
    function ensureScenePopoverDismissBound(){
      if (scenePopoverDismissBound) return;
      document.addEventListener('click', event => {
        if (!scenePopoverOpenId) return;
        const target = event.target instanceof Element ? event.target : null;
        if (target && (target.closest('.scene-card-popover') || (target.closest('.scene-card') && target.closest('.scene-card').dataset.sceneId === scenePopoverOpenId))){
          return;
        }
        cancelScenePopoverClickTimer();
        scenePopoverOpenId = null;
        render();
      });
      scenePopoverDismissBound = true;
    }

    function cancelScenePopoverClickTimer(){
      if (scenePopoverClickTimer){
        clearTimeout(scenePopoverClickTimer);
        scenePopoverClickTimer = null;
      }
    }
    function insertSceneAt(index, scene){
      project.scenes = Array.isArray(project.scenes) ? project.scenes : [];
      project._hashes = project._hashes || { scene: {} };
      const clamped = Math.max(0, Math.min(index, project.scenes.length));
      project.scenes.splice(clamped, 0, scene);
      project._hashes.scene[scene.id] = hashString(stableSceneString(scene));
      STORYBOARD_MEDIA_MODES.forEach(mode => setStoryboardIndex(scene.id, 0, mode));
      activeSceneId = scene.id;
      bumpVersion();
      render();
      scheduleSave(); scheduleBackup();
    }
    function addScene(){
      const scene = buildDefaultScene();
      insertSceneAt(project.scenes.length, scene);
    }
    function deleteScene(id){
      const idx = project.scenes.findIndex(s=>s.id===id);
      if (idx >= 0) {
        project.scenes.splice(idx,1);
        delete project._hashes.scene[id];
        STORYBOARD_MEDIA_MODES.forEach(mode => deleteStoryboardIndex(id, mode));
        if (!project.scenes.length){
          addScene();
          return;
        }
        if (activeSceneId === id) activeSceneId = project.scenes[0]?.id || null;
        bumpVersion(); render(); scheduleSave(); scheduleBackup();
      }
    }
    function updateSceneHash(scene){
      project._hashes = project._hashes || { scene: {} };
      refreshStoryboardPositions(scene);
      project._hashes.scene[scene.id] = hashString(stableSceneString(scene));
    }

    /* =========================
     * Counters & Utilities
     * =======================*/
    function updateCounters(){
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      const text = scenes.flatMap(s=>s.elements.map(e=>e.txt)).join(' ');
      const words = (text.match(/\b\w+\b/g)||[]).length;
      const lines = scenes.reduce((acc,s)=>acc + s.elements.length, 0);
      const pages = Math.max(1, Math.round(lines / 55));
      document.getElementById('counter').textContent = `${pages} pages ‚Ä¢ ${words} words`;
      const sceneCountEl = document.getElementById('statSceneCount');
      if (sceneCountEl) sceneCountEl.textContent = scenes.length;
      const pageEl = document.getElementById('statPageCount');
      if (pageEl) pageEl.textContent = pages;
      const wordEl = document.getElementById('statWordCount');
      if (wordEl) wordEl.textContent = words;
      const lineEl = document.getElementById('statLineCount');
      if (lineEl) lineEl.textContent = lines;
      updatePageViewControls({ skipScroll: pageViewMode !== 'pages' });
    }
    function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;' }[m])); }

    /* Theme */
    function applyTheme(){
      const fallback = (typeof window.getSiteTheme === 'function') ? window.getSiteTheme() : (document.documentElement.dataset.theme || 'dark');
      const theme = project.settings.theme || fallback || 'dark';
      project.settings.theme = theme;
      if (typeof window.setSiteTheme === 'function'){
        window.setSiteTheme(theme);
      } else {
        document.documentElement.dataset.theme = theme;
        document.documentElement.style.colorScheme = theme;
      }
    }

    /* =========================
     * Editor interactions
     * =======================*/
    const editorEl = document.getElementById('editor');
    const editorStageEl = document.getElementById('editorStage');
    const editorScrollEl = document.getElementById('editorScroll');
    const scriptViewModeButtons = Array.from(document.querySelectorAll('[data-script-view-mode]'));
    const scriptControlsEl = document.getElementById('scriptControls');
    const pageViewNavEl = document.getElementById('pageViewNav');
    const pageViewLabelEl = document.getElementById('pageViewLabel');
    const pageViewPrevBtn = document.getElementById('pageViewPrev');
    const pageViewNextBtn = document.getElementById('pageViewNext');
    const PAGE_VIEW_HEIGHT = Math.round((29.7 / 2.54) * 96);
    const PAGE_VIEW_WIDTH = Math.round((21 / 2.54) * 96);
    let pageViewMode = 'scroll';
    let pageViewIndex = 0;
    let lastSavedViewMode = null;
    let lastSavedViewPage = null;
    let syncingPageScroll = false;
    if (scriptControlsEl){
      if (!scriptControlsEl.dataset.visible) scriptControlsEl.dataset.visible = 'true';
      const hasCoarsePointer = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
      if (!hasCoarsePointer){
        let hideTimer = null;
        let pointerNearby = false;
        const HIDE_DELAY = 500;
        const NEAR_DISTANCE = 160;

        const setControlsVisible = visible => {
          const current = scriptControlsEl.dataset.visible !== 'false';
          if (visible === current) return;
          scriptControlsEl.dataset.visible = visible ? 'true' : 'false';
        };

        const scheduleHide = () => {
          if (hideTimer) window.clearTimeout(hideTimer);
          hideTimer = window.setTimeout(()=>{
            const hasFocus = scriptControlsEl.contains(document.activeElement);
            const hovering = scriptControlsEl.matches(':hover');
            if (!pointerNearby && !hovering && !hasFocus){
              setControlsVisible(false);
            }
          }, HIDE_DELAY);
        };

        const handlePointerProximity = event => {
          if (!scriptControlsEl.offsetParent) return;
          const rect = scriptControlsEl.getBoundingClientRect();
          if (!rect || (!rect.width && !rect.height)) return;
          const { clientX, clientY } = event;
          const within = clientX >= rect.left - NEAR_DISTANCE && clientX <= rect.right + NEAR_DISTANCE && clientY >= rect.top - NEAR_DISTANCE && clientY <= rect.bottom + NEAR_DISTANCE;
          if (within){
            if (!pointerNearby){
              pointerNearby = true;
              if (hideTimer){
                window.clearTimeout(hideTimer);
                hideTimer = null;
              }
            }
            setControlsVisible(true);
          } else if (pointerNearby){
            pointerNearby = false;
            scheduleHide();
          }
        };

        document.addEventListener('mousemove', handlePointerProximity, { passive:true });
        scriptControlsEl.addEventListener('mouseenter', ()=>{
          pointerNearby = true;
          if (hideTimer){
            window.clearTimeout(hideTimer);
            hideTimer = null;
          }
          setControlsVisible(true);
        });
        scriptControlsEl.addEventListener('mouseleave', ()=>{
          pointerNearby = false;
          scheduleHide();
        });
        scriptControlsEl.addEventListener('focusin', ()=>{
          pointerNearby = true;
          if (hideTimer){
            window.clearTimeout(hideTimer);
            hideTimer = null;
          }
          setControlsVisible(true);
        });
        scriptControlsEl.addEventListener('focusout', ()=>{
          const hasFocus = scriptControlsEl.contains(document.activeElement);
          if (!hasFocus){
            pointerNearby = false;
            scheduleHide();
          }
        });

        window.setTimeout(()=>{
          if (!scriptControlsEl.matches(':hover') && !scriptControlsEl.contains(document.activeElement)){
            pointerNearby = false;
            setControlsVisible(false);
          }
        }, 2000);
      } else {
        scriptControlsEl.dataset.visible = 'true';
      }
    }
    if (editorStageEl){
      editorStageEl.style.setProperty('--page-height', `${PAGE_VIEW_HEIGHT}px`);
      editorStageEl.style.setProperty('--page-width', `${PAGE_VIEW_WIDTH}px`);
    }
    function applyPageViewSettingsToProject(){
      if (!project) return;
      project.settings = project.settings || {};
      project.settings.scriptViewMode = pageViewMode;
      project.settings.scriptViewPage = pageViewIndex;
    }
    function persistPageViewSettings(){
      if (!project) return;
      applyPageViewSettingsToProject();
      if (pageViewMode === lastSavedViewMode && pageViewIndex === lastSavedViewPage) return;
      saveLocal(project);
      lastSavedViewMode = pageViewMode;
      lastSavedViewPage = pageViewIndex;
    }
    function refreshPageViewToggle(){
      if (editorStageEl) editorStageEl.dataset.viewMode = (pageViewMode === 'pages') ? 'pages' : 'scroll';
      if (pageViewNavEl) pageViewNavEl.hidden = pageViewMode !== 'pages';
      scriptViewModeButtons.forEach(btn => {
        const mode = btn.dataset.scriptViewMode === 'pages' ? 'pages' : 'scroll';
        const isActive = mode === pageViewMode;
        btn.classList.toggle('active', isActive);
        btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      });
    }
    function getPageViewTotal(){
      if (!editorEl) return 1;
      const height = Math.max(editorEl.scrollHeight, editorEl.offsetHeight);
      return Math.max(1, Math.ceil(height / PAGE_VIEW_HEIGHT));
    }
    function syncPageViewScroll(opts = {}){
      if (!editorScrollEl) return;
      const target = pageViewIndex * PAGE_VIEW_HEIGHT;
      if (Math.abs(editorScrollEl.scrollTop - target) < 1) return;
      syncingPageScroll = true;
      if (opts.smooth){
        editorScrollEl.scrollTo({ top: target, behavior: 'smooth' });
      } else {
        editorScrollEl.scrollTo({ top: target });
      }
      window.setTimeout(()=>{ syncingPageScroll = false; }, opts.smooth ? 320 : 0);
    }
    function updatePageViewControls(opts = {}){
      const total = getPageViewTotal();
      if (pageViewIndex >= total) pageViewIndex = total - 1;
      if (pageViewIndex < 0) pageViewIndex = 0;
      applyPageViewSettingsToProject();
      if (pageViewLabelEl){
        const current = total ? pageViewIndex + 1 : 1;
        pageViewLabelEl.textContent = `Page ${current} of ${total}`;
      }
      if (pageViewPrevBtn) pageViewPrevBtn.disabled = pageViewIndex <= 0;
      if (pageViewNextBtn) pageViewNextBtn.disabled = pageViewIndex >= total - 1;
      if (pageViewMode === 'pages' && !opts.skipScroll){
        syncPageViewScroll(opts);
      }
    }
    function setPageViewMode(mode){
      const normalized = mode === 'pages' ? 'pages' : 'scroll';
      if (normalized === pageViewMode) return;
      pageViewMode = normalized;
      refreshPageViewToggle();
      updatePageViewControls();
      persistPageViewSettings();
    }
    function setPageViewIndex(index, opts = {}){
      const total = getPageViewTotal();
      const clamped = Math.max(0, Math.min(index, total - 1));
      if (!opts.force && clamped === pageViewIndex){
        if (opts.ensureVisible && pageViewMode === 'pages' && !opts.skipScroll){
          syncPageViewScroll(opts);
        }
        return;
      }
      pageViewIndex = clamped;
      updatePageViewControls(opts);
      if (opts.persist) persistPageViewSettings();
      else applyPageViewSettingsToProject();
    }
    function applyScriptViewSettingsFromProject(){
      if (!project || !project.settings) return;
      pageViewMode = project.settings.scriptViewMode === 'pages' ? 'pages' : 'scroll';
      const storedPage = Math.max(0, Math.floor(project.settings.scriptViewPage || 0));
      pageViewIndex = storedPage;
      lastSavedViewMode = project.settings.scriptViewMode || pageViewMode;
      lastSavedViewPage = storedPage;
      refreshPageViewToggle();
      updatePageViewControls({ skipScroll: pageViewMode !== 'pages' });
    }
    function ensureSelectionPageVisible(){
      if (pageViewMode !== 'pages' || !editorEl || !editorScrollEl) return;
      const sel = window.getSelection();
      if (!sel || sel.rangeCount === 0) return;
      const range = sel.getRangeAt(0);
      if (!editorEl.contains(range.commonAncestorContainer)) return;
      const editorRect = editorEl.getBoundingClientRect();
      const scrollTop = editorScrollEl.scrollTop;
      let rect = range.getBoundingClientRect();
      if (!rect || (!rect.height && !rect.width)){
        const tempRange = range.cloneRange();
        const marker = document.createElement('span');
        marker.textContent = '\u200b';
        tempRange.insertNode(marker);
        rect = marker.getBoundingClientRect();
        if (marker.parentNode) marker.parentNode.removeChild(marker);
      }
      if (!rect) return;
      const offset = (rect.top - editorRect.top) + scrollTop;
      if (!isFinite(offset)) return;
      const nextIndex = Math.max(0, Math.floor(offset / PAGE_VIEW_HEIGHT));
      if (nextIndex !== pageViewIndex){
        setPageViewIndex(nextIndex, { smooth:false, persist:false, force:true });
      }
    }
    if (scriptViewModeButtons.length){
      scriptViewModeButtons.forEach(btn => {
        btn.addEventListener('click', ()=> setPageViewMode(btn.dataset.scriptViewMode));
      });
    }
    if (pageViewPrevBtn){
      pageViewPrevBtn.addEventListener('click', ()=> setPageViewIndex(pageViewIndex - 1, { smooth:true, persist:true }));
    }
    if (pageViewNextBtn){
      pageViewNextBtn.addEventListener('click', ()=> setPageViewIndex(pageViewIndex + 1, { smooth:true, persist:true }));
    }
    if (editorScrollEl){
      editorScrollEl.addEventListener('scroll', ()=>{
        if (pageViewMode !== 'pages' || syncingPageScroll) return;
        const index = Math.round(editorScrollEl.scrollTop / PAGE_VIEW_HEIGHT);
        if (index !== pageViewIndex){
          setPageViewIndex(index, { smooth:false, persist:false, skipScroll:true, force:true });
        }
      });
    }
    document.addEventListener('selectionchange', ensureSelectionPageVisible);
    refreshPageViewToggle();
    const selectionMenuEl = document.getElementById('selectionMenu');
    const selectionMenuCharactersSection = selectionMenuEl?.querySelector('[data-selection-characters-section]') || null;
    const selectionMenuCharactersList = selectionMenuEl?.querySelector('[data-selection-characters]') || null;
    const selectionMenuAdvancedToggle = selectionMenuEl?.querySelector('[data-selection-advanced-toggle]') || null;
    const selectionMenuAdvanced = selectionMenuEl?.querySelector('[data-selection-advanced]') || null;
    const selectionMenuTypeTrigger = selectionMenuEl?.querySelector('[data-selection-type-trigger]') || null;
    const selectionTypeMenuEl = document.getElementById('selectionTypeMenu');
    const selectionTypeCharactersSection = selectionTypeMenuEl?.querySelector('[data-type-characters-section]') || null;
    const selectionTypeCharactersList = selectionTypeMenuEl?.querySelector('[data-type-characters]') || null;
    const LINE_TYPE_CLASSES = ['slug','action','dialogue','character','parenthetical','transition','exposition'];
    let selectionMenuTargetLine = null;
    let selectionMenuFrame = null;
    let selectionTypeMenuFrame = null;

    function getCharacterNameById(id){
      if (!id || !project || !project.catalogs) return '';
      const list = Array.isArray(project.catalogs.characters) ? project.catalogs.characters : [];
      const match = list.find(char => char.id === id);
      return match?.name || '';
    }

    function applyLineTypeClass(node){
      if (!node) return;
      let type = node.dataset.t || 'action';
      if (!LINE_TYPE_CLASSES.includes(type)) type = 'action';
      node.dataset.t = type;
      node.classList.add('line');
      LINE_TYPE_CLASSES.forEach(cls => {
        if (cls !== type) node.classList.remove(cls);
      });
      node.classList.add(type);
    }

    function updateLineTagLabel(node){
      if (!node) return;
      const tags = [];
      const ownerId = node.dataset.owner || '';
      if (ownerId){
        const name = getCharacterNameById(ownerId) || 'Character';
        node.dataset.ownerLabel = name;
        tags.push(name);
      } else {
        delete node.dataset.ownerLabel;
      }
      const part = node.dataset.storyPart || '';
      if (part){
        const label = STORY_PART_LABELS[part] || part;
        node.dataset.storyPartLabel = label;
        tags.push(label);
      } else {
        delete node.dataset.storyPartLabel;
      }
      const beat = node.dataset.storyBeat || '';
      if (beat){
        const label = STORY_BEAT_LABELS[beat] || beat;
        node.dataset.storyBeatLabel = label;
        tags.push(label);
      } else {
        delete node.dataset.storyBeatLabel;
      }
      if (tags.length){
        node.dataset.tagLabel = tags.join(' ‚Ä¢ ');
      } else {
        delete node.dataset.tagLabel;
      }
    }

    function updateAllLineTagLabels(){
      if (!editorEl) return;
      editorEl.querySelectorAll('.line').forEach(updateLineTagLabel);
    }

    function updateSelectionMenuCharacters(){
      if (!selectionMenuEl && !selectionTypeMenuEl) return;
      const characters = Array.isArray(project?.catalogs?.characters) ? project.catalogs.characters : [];
      if (selectionMenuCharactersList) selectionMenuCharactersList.innerHTML = '';
      if (selectionTypeCharactersList) selectionTypeCharactersList.innerHTML = '';
      if (!characters.length){
        if (selectionMenuCharactersSection) selectionMenuCharactersSection.hidden = true;
        if (selectionTypeCharactersSection) selectionTypeCharactersSection.hidden = true;
        refreshSelectionMenuState();
        refreshSelectionTypeMenuState();
        return;
      }
      characters.forEach(char => {
        if (selectionMenuCharactersList){
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.dataset.menuOwner = char.id || '';
          btn.textContent = char.name || 'Unnamed';
          selectionMenuCharactersList.appendChild(btn);
        }
        if (selectionTypeCharactersList){
          const typeBtn = document.createElement('button');
          typeBtn.type = 'button';
          typeBtn.dataset.typeCharacter = char.id || '';
          typeBtn.textContent = char.name || 'Unnamed';
          selectionTypeCharactersList.appendChild(typeBtn);
        }
      });
      if (selectionMenuCharactersList){
        const clearBtn = document.createElement('button');
        clearBtn.type = 'button';
        clearBtn.dataset.menuOwner = '';
        clearBtn.textContent = 'Clear';
        selectionMenuCharactersList.appendChild(clearBtn);
      }
      if (selectionMenuCharactersSection) selectionMenuCharactersSection.hidden = false;
      if (selectionTypeCharactersSection) selectionTypeCharactersSection.hidden = false;
      refreshSelectionMenuState();
      refreshSelectionTypeMenuState();
    }

    function refreshSelectionMenuState(){
      if (!selectionMenuEl || !selectionMenuTargetLine) return;
      const type = selectionMenuTargetLine.dataset.t || 'action';
      selectionMenuEl.querySelectorAll('[data-menu-line-type]').forEach(btn => {
        const isActive = btn.dataset.menuLineType === type;
        btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        btn.classList.toggle('active', isActive);
      });
      const part = selectionMenuTargetLine.dataset.storyPart || '';
      selectionMenuEl.querySelectorAll('[data-menu-story-part]').forEach(btn => {
        const value = btn.dataset.menuStoryPart || '';
        const isActive = value ? value === part : !part;
        btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        btn.classList.toggle('active', isActive);
      });
      const beat = selectionMenuTargetLine.dataset.storyBeat || '';
      selectionMenuEl.querySelectorAll('[data-menu-act]').forEach(btn => {
        const value = btn.dataset.menuAct || '';
        const isActive = value ? value === beat : !beat;
        btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        btn.classList.toggle('active', isActive);
      });
      if (selectionMenuCharactersList){
        const owner = selectionMenuTargetLine.dataset.owner || '';
        const isNote = selectionMenuTargetLine.dataset.t === 'exposition';
        selectionMenuCharactersList.querySelectorAll('button[data-menu-owner]').forEach(btn => {
          const value = btn.dataset.menuOwner || '';
          const isActive = value ? value === owner : (!owner && !isNote);
          btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
          btn.classList.toggle('active', isActive);
        });
      }
      refreshSelectionTypeMenuState();
    }

    function refreshSelectionTypeMenuState(){
      if (!selectionTypeMenuEl) return;
      const owner = selectionMenuTargetLine?.dataset?.owner || '';
      const isNote = selectionMenuTargetLine?.dataset?.t === 'exposition';
      if (selectionTypeCharactersList){
        selectionTypeCharactersList.querySelectorAll('button[data-type-character]').forEach(btn => {
          const value = btn.dataset.typeCharacter || '';
          const isActive = !!selectionMenuTargetLine && value ? value === owner : (!owner && !isNote && !!selectionMenuTargetLine);
          btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
          btn.classList.toggle('active', isActive);
        });
      }
      const clearBtn = selectionTypeMenuEl.querySelector('button[data-type-character=""]');
      if (clearBtn){
        const clearActive = !!selectionMenuTargetLine && !owner && !isNote;
        clearBtn.setAttribute('aria-pressed', clearActive ? 'true' : 'false');
        clearBtn.classList.toggle('active', clearActive);
      }
      const noteBtn = selectionTypeMenuEl.querySelector('button[data-type-note]');
      if (noteBtn){
        const noteActive = !!selectionMenuTargetLine && isNote;
        noteBtn.setAttribute('aria-pressed', noteActive ? 'true' : 'false');
        noteBtn.classList.toggle('active', noteActive);
      }
    }

    function hideSelectionMenu(){
      if (!selectionMenuEl) return;
      selectionMenuEl.setAttribute('hidden', '');
      selectionMenuEl.style.top = '';
      selectionMenuEl.style.left = '';
      selectionMenuEl.style.opacity = '';
      selectionMenuEl.style.visibility = '';
      selectionMenuTargetLine = null;
      hideSelectionTypeMenu();
    }

    function positionSelectionMenu(rect){
      if (!selectionMenuEl) return;
      selectionMenuEl.removeAttribute('hidden');
      selectionMenuEl.style.visibility = 'hidden';
      selectionMenuEl.style.opacity = '0';
      requestAnimationFrame(()=>{
        const menuRect = selectionMenuEl.getBoundingClientRect();
        let top = rect.top - menuRect.height - 12;
        if (top < 16){
          top = rect.bottom + 12;
        }
        let left = rect.left + (rect.width / 2) - (menuRect.width / 2);
        left = Math.max(16, Math.min(left, window.innerWidth - menuRect.width - 16));
        selectionMenuEl.style.top = `${Math.round(top)}px`;
        selectionMenuEl.style.left = `${Math.round(left)}px`;
        selectionMenuEl.style.visibility = 'visible';
        selectionMenuEl.style.opacity = '1';
        repositionSelectionTypeMenu();
      });
    }

    function hideSelectionTypeMenu(){
      if (!selectionTypeMenuEl || !selectionMenuTypeTrigger) return;
      if (selectionTypeMenuFrame) cancelAnimationFrame(selectionTypeMenuFrame);
      selectionTypeMenuFrame = null;
      selectionMenuTypeTrigger.setAttribute('aria-expanded', 'false');
      selectionTypeMenuEl.setAttribute('hidden', '');
      selectionTypeMenuEl.style.top = '';
      selectionTypeMenuEl.style.left = '';
      selectionTypeMenuEl.style.opacity = '';
      selectionTypeMenuEl.style.visibility = '';
    }

    function positionSelectionTypeMenu(rect){
      if (!selectionTypeMenuEl || !selectionMenuTypeTrigger) return;
      if (selectionTypeMenuFrame) cancelAnimationFrame(selectionTypeMenuFrame);
      selectionTypeMenuEl.removeAttribute('hidden');
      selectionTypeMenuEl.style.visibility = 'hidden';
      selectionTypeMenuEl.style.opacity = '0';
      selectionTypeMenuFrame = requestAnimationFrame(()=>{
        selectionTypeMenuFrame = null;
        const menuRect = selectionTypeMenuEl.getBoundingClientRect();
        let top = rect.bottom + 8;
        if (top + menuRect.height > window.innerHeight - 16){
          top = rect.top - menuRect.height - 8;
        }
        if (top < 16) top = 16;
        let left = rect.left + (rect.width / 2) - (menuRect.width / 2);
        left = Math.max(16, Math.min(left, window.innerWidth - menuRect.width - 16));
        selectionTypeMenuEl.style.top = `${Math.round(top)}px`;
        selectionTypeMenuEl.style.left = `${Math.round(left)}px`;
        selectionTypeMenuEl.style.visibility = 'visible';
        selectionTypeMenuEl.style.opacity = '1';
      });
    }

    function repositionSelectionTypeMenu(){
      if (!selectionTypeMenuEl || !selectionMenuTypeTrigger) return;
      if (selectionMenuTypeTrigger.getAttribute('aria-expanded') !== 'true') return;
      const rect = selectionMenuTypeTrigger.getBoundingClientRect();
      positionSelectionTypeMenu(rect);
    }

    function handleSelectionChange(){
      selectionMenuFrame = null;
      if (!selectionMenuEl || !editorEl) return;
      const sel = window.getSelection();
      if (!sel || sel.rangeCount === 0 || sel.isCollapsed){
        hideSelectionMenu();
        return;
      }
      const range = sel.getRangeAt(0);
      if (!editorEl.contains(range.commonAncestorContainer)){
        hideSelectionMenu();
        return;
      }
      const rect = range.getBoundingClientRect();
      if (!rect || (!rect.width && !rect.height)){
        hideSelectionMenu();
        return;
      }
      const line = getActiveLineNode();
      if (!line){
        hideSelectionMenu();
        return;
      }
      selectionMenuTargetLine = line;
      refreshSelectionMenuState();
      positionSelectionMenu(rect);
    }

    function handleSelectionMenuClick(event){
      if (!selectionMenuTargetLine) return;
      const button = event.target.closest('button');
      if (!button) return;
      event.preventDefault();
      const sel = window.getSelection();
      if (button.dataset.menuLineType){
        const type = button.dataset.menuLineType;
        selectionMenuTargetLine.dataset.t = type;
        applyLineTypeClass(selectionMenuTargetLine);
      }
      if (button.hasAttribute('data-menu-story-part')){
        const value = button.dataset.menuStoryPart || '';
        if (value) selectionMenuTargetLine.dataset.storyPart = value;
        else delete selectionMenuTargetLine.dataset.storyPart;
      }
      if (button.hasAttribute('data-menu-act')){
        const value = button.dataset.menuAct || '';
        if (value) selectionMenuTargetLine.dataset.storyBeat = value;
        else delete selectionMenuTargetLine.dataset.storyBeat;
      }
      if (button.hasAttribute('data-menu-owner')){
        const value = button.dataset.menuOwner || '';
        if (value) selectionMenuTargetLine.dataset.owner = value;
        else delete selectionMenuTargetLine.dataset.owner;
      }
      updateLineTagLabel(selectionMenuTargetLine);
      refreshSelectionMenuState();
      syncActiveScene(false);
      if (sel && sel.rangeCount){
        const rect = sel.getRangeAt(0).getBoundingClientRect();
        positionSelectionMenu(rect);
      }
      repositionSelectionTypeMenu();
    }

    function handleSelectionTypeMenuClick(event){
      if (!selectionMenuTargetLine) return;
      const button = event.target.closest('button');
      if (!button) return;
      event.preventDefault();
      const isNoteActive = selectionMenuTargetLine.dataset.t === 'exposition';
      if (button.hasAttribute('data-type-character')){
        const value = button.dataset.typeCharacter || '';
        if (value) selectionMenuTargetLine.dataset.owner = value;
        else delete selectionMenuTargetLine.dataset.owner;
        if (isNoteActive){
          selectionMenuTargetLine.dataset.t = 'action';
          applyLineTypeClass(selectionMenuTargetLine);
        }
      }
      if (button.hasAttribute('data-type-note')){
        if (isNoteActive){
          selectionMenuTargetLine.dataset.t = 'action';
        } else {
          selectionMenuTargetLine.dataset.t = 'exposition';
          delete selectionMenuTargetLine.dataset.owner;
        }
        applyLineTypeClass(selectionMenuTargetLine);
      }
      updateLineTagLabel(selectionMenuTargetLine);
      refreshSelectionMenuState();
      syncActiveScene(false);
      repositionSelectionTypeMenu();
    }

    if (selectionMenuEl){
      selectionMenuEl.addEventListener('pointerdown', e => e.preventDefault());
      selectionMenuEl.addEventListener('click', handleSelectionMenuClick);
    }
    if (selectionMenuAdvancedToggle && selectionMenuAdvanced){
      selectionMenuAdvancedToggle.addEventListener('click', ()=>{
        const expanded = selectionMenuAdvancedToggle.getAttribute('aria-expanded') === 'true';
        const next = !expanded;
        selectionMenuAdvancedToggle.setAttribute('aria-expanded', next ? 'true' : 'false');
        if (next) selectionMenuAdvanced.removeAttribute('hidden');
        else selectionMenuAdvanced.setAttribute('hidden', '');
      });
    }
    if (selectionMenuTypeTrigger){
      selectionMenuTypeTrigger.addEventListener('click', event => {
        event.preventDefault();
        if (!selectionTypeMenuEl) return;
        const isOpen = selectionMenuTypeTrigger.getAttribute('aria-expanded') === 'true';
        if (isOpen){
          hideSelectionTypeMenu();
          return;
        }
        if (selectionTypeCharactersList && !selectionTypeCharactersList.children.length){
          updateSelectionMenuCharacters();
        }
        selectionMenuTypeTrigger.setAttribute('aria-expanded', 'true');
        refreshSelectionTypeMenuState();
        positionSelectionTypeMenu(selectionMenuTypeTrigger.getBoundingClientRect());
      });
    }
    if (selectionTypeMenuEl){
      selectionTypeMenuEl.addEventListener('pointerdown', e => e.preventDefault());
      selectionTypeMenuEl.addEventListener('click', handleSelectionTypeMenuClick);
    }
    document.addEventListener('selectionchange', ()=>{
      if (selectionMenuFrame) cancelAnimationFrame(selectionMenuFrame);
      selectionMenuFrame = requestAnimationFrame(handleSelectionChange);
    });
    document.addEventListener('pointerdown', e => {
      if (!selectionMenuEl) return;
      if (selectionMenuEl.contains(e.target)) return;
      if (selectionTypeMenuEl && selectionTypeMenuEl.contains(e.target)) return;
      if (selectionMenuTypeTrigger && selectionMenuTypeTrigger.contains(e.target)) return;
      if (editorEl && editorEl.contains(e.target)) return;
      hideSelectionMenu();
    });
    window.addEventListener('resize', hideSelectionMenu);
    document.addEventListener('scroll', hideSelectionMenu, true);

    function getActiveLineNode(){
      const sel = window.getSelection();
      if (!sel || !sel.anchorNode) return null;
      let n = sel.anchorNode.nodeType === 3 ? sel.anchorNode.parentElement : sel.anchorNode;
      return n?.closest?.('.line') || null;
    }
    function markActiveLine(){
      document.querySelectorAll('#editor .line.active').forEach(el=>el.classList.remove('active'));
      const line = getActiveLineNode();
      if (line) line.classList.add('active');
    }
    function centerActiveLine(){
      const editor = document.getElementById('editor');
      const line = getActiveLineNode();
      if (!editor || !line) return;
      const rect = line.getBoundingClientRect();
      const parentRect = editor.getBoundingClientRect();
      const lineMid = rect.top + rect.height/2;
      const parentMid = parentRect.top + parentRect.height/2;
      const delta = lineMid - parentMid;
      editor.scrollTop += delta;
    }

    function placeCaret(node){
      if (!node) return;
      const editor = document.getElementById('editor');
      if (editor) editor.focus();
      const range = document.createRange();
      range.selectNodeContents(node);
      range.collapse(false);
      const sel = window.getSelection();
      if (!sel) return;
      sel.removeAllRanges();
      sel.addRange(range);
    }

    function insertLine(type, preset=''){
      const editor = document.getElementById('editor');
      if (!editor) return;
      const node = document.createElement('div');
      node.dataset.t = type;
      applyLineTypeClass(node);
      let text = preset || '';
      if (type === 'character' && text) text = text.toUpperCase();
      if (text) node.textContent = text;
      else node.innerHTML = '<br>';
      delete node.dataset.owner;
      delete node.dataset.storyPart;
      delete node.dataset.storyBeat;
      updateLineTagLabel(node);
      const active = getActiveLineNode();
      if (active && active.parentElement === editor) active.after(node);
      else editor.appendChild(node);
      placeCaret(node);
      syncActiveScene(false);
      markActiveLine();
      if (document.body.classList.contains('focus-mode')) centerActiveLine();
    }

    document.getElementById('editor').addEventListener('input', ()=>{
      syncActiveScene();
      markActiveLine();
      if (document.body.classList.contains('focus-mode')) centerActiveLine();
    });

    document.getElementById('editor').addEventListener('keydown', (e)=>{
      if (e.key === 'Enter') {
        setTimeout(()=>{
          syncActiveScene();
          markActiveLine();
          if (document.body.classList.contains('focus-mode')) centerActiveLine();
        }, 0);
      }
    });

    document.getElementById('editor').addEventListener('click', ()=>{
      markActiveLine();
      if (document.body.classList.contains('focus-mode')) centerActiveLine();
    });

    /* Auto type-detection */
    function autoDetectTypes(){
      const nodes = Array.from(document.querySelectorAll('#editor .line'));
      nodes.forEach(n=>{
        const text = (n.textContent||'').trim();
        let t = n.dataset.t;
        if (/^(INT|EXT|INT\/EXT|INT-EXT)\./i.test(text)) t = 'slug';
        else if (/^[A-Z0-9 .'-]{2,}$/.test(text) && text.length < 40) t = 'character';
        else if (/^\(.+\)$/.test(text)) t = 'parenthetical';
        else if (/^(CUT TO:|FADE OUT\.?|FADE IN\.?|SMASH CUT:|DISSOLVE TO:)/i.test(text)) t = 'transition';
        else if (!t || ['slug','character','parenthetical','transition'].includes(t)) t = 'action';
        n.dataset.t = t;
        applyLineTypeClass(n);
      });
    }

    /* =========================
     * Notes + meta bindings
     * =======================*/
    document.querySelectorAll('[data-tab-btn]').forEach(btn=>{
      btn.addEventListener('click', ()=> setRightTab(btn.dataset.tabBtn));
    });
    setupSaveMenu();
    setupExportMenu();
    setupStoryboardMenu();
    document.querySelectorAll('[data-slug-prefix]').forEach(btn=>{
      btn.addEventListener('click', ()=> setSceneSlugPart('prefix', btn.dataset.slugPrefix));
    });
    document.querySelectorAll('[data-slug-suffix]').forEach(btn=>{
      btn.addEventListener('click', ()=> setSceneSlugPart('suffix', btn.dataset.slugSuffix));
    });
    document.querySelectorAll('[data-line-type]').forEach(btn=>{
      btn.addEventListener('click', ()=> insertLine(btn.dataset.lineType));
    });
    const deleteSceneBtn = document.getElementById('deleteSceneBtn');
    if (deleteSceneBtn){
      deleteSceneBtn.addEventListener('click', ()=>{
        if (project.scenes.length <= 1) return;
        const scene = getActiveScene();
        const ok = confirm(`Delete scene "${scene?.slug || 'Untitled Scene'}"?`);
        if (ok) deleteScene(activeSceneId);
      });
    }
    const addCharacterBtn = document.getElementById('addCharacterBtn');
    if (addCharacterBtn){
      addCharacterBtn.addEventListener('click', ()=>{
        const input = document.getElementById('newCharacterName');
        const value = input.value;
        addCharacter(value);
        const fresh = document.getElementById('newCharacterName');
        if (fresh){ fresh.value = ''; fresh.focus(); }
      });
    }
    const characterStudioBtn = document.getElementById('openCharacterStudioBtn');
    if (characterStudioBtn){
      characterStudioBtn.addEventListener('click', ()=> openCharacterStudio());
    }
    const characterStudioOverlay = document.getElementById('characterStudioOverlay');
    if (characterStudioOverlay){
      characterStudioOverlay.addEventListener('click', e=>{
        if (e.target === characterStudioOverlay) closeCharacterStudio();
      });
    }
    const characterStudioClose = document.getElementById('characterStudioClose');
    if (characterStudioClose){
      characterStudioClose.addEventListener('click', ()=> closeCharacterStudio());
    }
    const characterStudioAddBtn = document.getElementById('characterStudioAddBtn');
    if (characterStudioAddBtn){
      characterStudioAddBtn.addEventListener('click', ()=>{
        const created = addCharacter('New Character');
        if (!created) return;
        characterStudioState.activeId = created.id;
        renderCharacterStudio();
        const nameField = document.querySelector('#characterStudioOverlay [data-character-field="name"]');
        if (nameField){
          requestAnimationFrame(()=>{
            nameField.focus();
            if (typeof nameField.select === 'function') nameField.select();
          });
        }
      });
    }
    const addSetBtn = document.getElementById('addSetBtn');
    if (addSetBtn){
      addSetBtn.addEventListener('click', ()=>{
        const input = document.getElementById('newSetName');
        const value = input.value;
        addLocation(value);
        const fresh = document.getElementById('newSetName');
        if (fresh){ fresh.value = ''; fresh.focus(); }
      });
    }
    const addSoundBtn = document.getElementById('addSoundBtn');
    if (addSoundBtn){
      addSoundBtn.addEventListener('click', ()=>{
        const input = document.getElementById('newSoundCue');
        const value = input.value;
        addSoundCue(value);
        const fresh = document.getElementById('newSoundCue');
        if (fresh){ fresh.value = ''; fresh.focus(); }
      });
    }
    const storyboardBtn = document.getElementById('storyboardModeBtn');
    if (storyboardBtn){
      updateStoryboardButton();
      storyboardBtn.addEventListener('click', ()=>{
        toggleStoryboardMode();
        setStoryboardMenuOpen(false);
      });
    }
    const storyboardOverlayEl = document.getElementById('storyboardOverlay');
    if (storyboardOverlayEl){
      storyboardOverlayEl.addEventListener('click', e=>{
        if (e.target === storyboardOverlayEl) closeStoryboardMode();
      });
    }
    const storyboardOverlayClose = document.getElementById('storyboardOverlayClose');
    if (storyboardOverlayClose){
      storyboardOverlayClose.addEventListener('click', ()=> closeStoryboardMode());
    }
    const storyboardQuickAddBtn = document.getElementById('storyboardQuickAdd');
    if (storyboardQuickAddBtn){
      storyboardQuickAddBtn.addEventListener('click', ()=> handleStoryboardQuickAdd());
    }
    const storyboardQuickInput = document.getElementById('storyboardQuickUrl');
    if (storyboardQuickInput){
      storyboardQuickInput.addEventListener('keydown', e=>{
        if (e.key === 'Enter'){
          e.preventDefault();
          handleStoryboardQuickAdd();
        }
      });
    }
    document.querySelectorAll('[data-storyboard-mode-btn]').forEach(btn => {
      btn.addEventListener('click', ()=> setStoryboardMediaMode(btn.dataset.storyboardModeBtn));
    });
    const storyboardApiKeyInput = document.getElementById('storyboardApiKey');
    if (storyboardApiKeyInput){
      storyboardApiKeyInput.value = storyboardAIConfig?.apiKey || '';
      storyboardApiKeyInput.addEventListener('input', e=>{
        storyboardAIConfig.apiKey = e.target.value;
        saveStoryboardAIConfig();
        updateStoryboardAIGenerateButton();
      });
    }
    const storyboardModelSelect = document.getElementById('storyboardModel');
    if (storyboardModelSelect){
      storyboardModelSelect.value = storyboardAIConfig?.model || STORYBOARD_AI_DEFAULT_MODEL;
      storyboardModelSelect.addEventListener('change', e=>{
        storyboardAIConfig.model = e.target.value || STORYBOARD_AI_DEFAULT_MODEL;
        saveStoryboardAIConfig();
      });
    }
    const storyboardAIPromptInput = document.getElementById('storyboardAIPrompt');
    if (storyboardAIPromptInput){
      storyboardAIPromptInput.addEventListener('input', ()=> handleStoryboardAIPromptChange());
    }
    const storyboardAIFrameInput = document.getElementById('storyboardAIFrameCount');
    if (storyboardAIFrameInput){
      storyboardAIFrameInput.addEventListener('input', ()=> handleStoryboardAIFrameCountChange());
      storyboardAIFrameInput.addEventListener('change', ()=> handleStoryboardAIFrameCountChange());
    }
    const storyboardAIGenerateBtn = document.getElementById('storyboardAIGenerate');
    if (storyboardAIGenerateBtn){
      storyboardAIGenerateBtn.addEventListener('click', ()=> handleStoryboardAIGenerate());
    }
    applyStoryboardAIInputState();
    updateStoryboardAIGenerateButton();
    const timelineBtn = document.getElementById('timelineModeBtn');
    if (timelineBtn){
      updateTimelineButton();
      timelineBtn.addEventListener('click', ()=> toggleTimelineMode());
    }
    const timelineOverlayEl = document.getElementById('timelineOverlay');
    if (timelineOverlayEl){
      timelineOverlayEl.addEventListener('click', (e)=>{
        if (e.target === timelineOverlayEl) closeTimelineMode();
      });
    }
    const timelineOverlayClose = document.getElementById('timelineOverlayClose');
    if (timelineOverlayClose){
      timelineOverlayClose.addEventListener('click', ()=> closeTimelineMode());
    }
    const timelineAddBtn = document.getElementById('timelineAddSceneBtn');
    if (timelineAddBtn){
      timelineAddBtn.addEventListener('click', ()=> handleTimelineAddScene());
    }
    const timelinePreviewCloseBtn = document.getElementById('timelinePreviewClose');
    if (timelinePreviewCloseBtn){
      timelinePreviewCloseBtn.addEventListener('click', ()=> closeTimelinePreview());
    }
    const timelinePreviewOpenBtn = document.getElementById('timelinePreviewOpen');
    if (timelinePreviewOpenBtn){
      timelinePreviewOpenBtn.addEventListener('click', ()=>{
        const sceneId = timelinePreviewOpenBtn.dataset.sceneId;
        if (!sceneId) return;
        activeSceneId = sceneId;
        setRightTab('write');
        closeTimelineMode();
        render();
      });
    }
    const timelinePreviewLayer = document.getElementById('timelinePreview');
    if (timelinePreviewLayer){
      timelinePreviewLayer.addEventListener('click', (e)=>{
        if (e.target === timelinePreviewLayer) closeTimelinePreview();
      });
    }

    document.addEventListener('keydown', e=>{
      if (e.key === 'Escape'){
        if (sceneInlineRenameId){
          cancelSceneInlineRename(sceneInlineRenameId);
          return;
        }
        if (scenePopoverOpenId){
          scenePopoverOpenId = null;
          render();
          return;
        }
        if (characterStudioState.open){
          closeCharacterStudio();
          return;
        }
        if (storyboardMode){
          closeStoryboardMode();
          return;
        }
      }
    });

    setupTimelineDockInteractions();
    setupFocusHudInteractions();

    const scriptDialogCancel = document.getElementById('scriptDialogCancel');
    if (scriptDialogCancel){
      scriptDialogCancel.addEventListener('click', ()=> closeScriptDialog());
    }
    const scriptDialogClose = document.getElementById('scriptDialogClose');
    if (scriptDialogClose){
      scriptDialogClose.addEventListener('click', ()=> closeScriptDialog());
    }
    const scriptDialogBackdrop = document.querySelector('#scriptDialog [data-close-script]');
    if (scriptDialogBackdrop){
      scriptDialogBackdrop.addEventListener('click', ()=> closeScriptDialog());
    }
    const scriptDialogLoad = document.getElementById('scriptDialogLoad');
    if (scriptDialogLoad){
      scriptDialogLoad.addEventListener('click', ()=> handleScriptLoad());
    }
    const scriptDialogSave = document.getElementById('scriptDialogSave');
    if (scriptDialogSave){
      scriptDialogSave.addEventListener('click', ()=> handleScriptDialogSave());
    }
    const scriptDialogCreate = document.getElementById('scriptDialogCreate');
    if (scriptDialogCreate){
      scriptDialogCreate.addEventListener('click', ()=> handleScriptDialogCreate());
    }
    const scriptSelect = document.getElementById('scriptSelect');
    if (scriptSelect){
      scriptSelect.addEventListener('change', e=> updateScriptPreview(e.target.value));
    }
    const scriptDialogNewTitle = document.getElementById('scriptDialogNewTitle');
    if (scriptDialogNewTitle){
      scriptDialogNewTitle.addEventListener('input', ()=>{
        const status = document.getElementById('scriptDialogStatus');
        if (status && status.textContent){
          status.textContent = '';
        }
        updateScriptDialogLoadState();
      });
      scriptDialogNewTitle.addEventListener('keydown', e=>{
        if (e.key === 'Enter'){
          e.preventDefault();
          handleScriptDialogCreate();
        }
      });
    }

    const scriptDialogCoverApply = document.getElementById('scriptDialogApplyCover');
    if (scriptDialogCoverApply){
      scriptDialogCoverApply.addEventListener('click', ()=> handleApplyScriptCoverImage());
    }
    const scriptDialogCoverClear = document.getElementById('scriptDialogClearCover');
    if (scriptDialogCoverClear){
      scriptDialogCoverClear.addEventListener('click', ()=> handleClearScriptCoverImage());
    }
    const scriptDialogCoverInput = document.getElementById('scriptDialogCoverUrl');
    if (scriptDialogCoverInput){
      scriptDialogCoverInput.addEventListener('keydown', e=>{
        if (e.key === 'Enter'){
          e.preventDefault();
          handleApplyScriptCoverImage();
        }
      });
    }

    applyActiveTabUI();

    const currentScriptTitleInput = document.getElementById('scriptDialogCurrentTitle');
    if (currentScriptTitleInput){
      currentScriptTitleInput.addEventListener('input', e=>{
        project.title = e.target.value;
        document.getElementById('title').textContent = project.title || 'Untitled Project';
        const currentNameEl = document.getElementById('scriptDialogCurrentName');
        if (currentNameEl) currentNameEl.textContent = project.title || 'Untitled Script';
        bumpVersion(); scheduleSave(); scheduleBackup();
      });
    }
    document.getElementById('projectNotes').addEventListener('input', e=>{
      project.notes = e.target.value; bumpVersion(); scheduleSave(); scheduleBackup();
    });
    document.getElementById('sceneSlug').addEventListener('input', e=>{
      const s = getActiveScene(); if (!s) return;
      s.slug = e.target.value; bumpVersion(); updateSceneHash(s); render(); scheduleSave(); scheduleBackup();
    });
    document.getElementById('sceneColor').addEventListener('input', e=>{
      const s = getActiveScene(); if (!s) return;
      const normalized = normalizeSceneColor(e.target.value);
      s.colorSource = SCENE_COLOR_SOURCE_CUSTOM;
      s.color = normalized;
      if (s.metadata && typeof s.metadata === 'object') s.metadata.sceneColorSource = s.colorSource;
      e.target.value = normalized;
      bumpVersion(); updateSceneHash(s); render(); scheduleSave(); scheduleBackup();
    });
    const sceneColorAutoBtn = document.getElementById('sceneColorAutoBtn');
    if (sceneColorAutoBtn){
      sceneColorAutoBtn.addEventListener('click', ()=>{
        const s = getActiveScene(); if (!s) return;
        s.colorSource = SCENE_COLOR_SOURCE_AUTO;
        s.color = DEFAULT_SCENE_COLOR;
        if (s.metadata && typeof s.metadata === 'object') s.metadata.sceneColorSource = s.colorSource;
        bumpVersion(); updateSceneHash(s); render(); scheduleSave(); scheduleBackup();
      });
    }
    const storyboardPrevBtn = document.getElementById('storyboardPrev');
    if (storyboardPrevBtn){
      storyboardPrevBtn.addEventListener('click', ()=> stepStoryboard(-1));
    }
    const storyboardNextBtn = document.getElementById('storyboardNext');
    if (storyboardNextBtn){
      storyboardNextBtn.addEventListener('click', ()=> stepStoryboard(1));
    }
    const storyboardRemoveBtn = document.getElementById('removeStoryboardBtn');
    if (storyboardRemoveBtn){
      storyboardRemoveBtn.addEventListener('click', ()=> handleRemoveStoryboard());
    }
    const storyboardAddBtn = document.getElementById('addStoryboardBtn');
    if (storyboardAddBtn){
      storyboardAddBtn.addEventListener('click', ()=> handleAddStoryboard());
    }
    const storyboardInput = document.getElementById('newStoryboardUrl');
    if (storyboardInput){
      storyboardInput.addEventListener('keydown', e=>{
        if (e.key === 'Enter'){
          e.preventDefault();
          handleAddStoryboard();
        }
      });
    }
    document.getElementById('smartFormat').addEventListener('change', e=>{
      project.settings.smartFormat = (e.target.value === 'true');
      bumpVersion(); scheduleSave();
    });
    document.addEventListener('themechange', e=>{
      const nextTheme = e.detail?.theme;
      if (!nextTheme || !project) return;
      if (project.settings.theme !== nextTheme){
        project.settings.theme = nextTheme;
        bumpVersion(); scheduleSave();
      }
    });

    /* =========================
     * Export / Print
     * =======================*/
    function exportFountain(){
      let out = `Title: ${project.title||''}\n\n`;
      project.scenes.forEach(s=>{
        if (s.slug) out += s.slug.toUpperCase() + '\n';
        s.elements.forEach(el=>{
          if (el.t==='character') out += '\n' + el.txt.toUpperCase() + '\n';
          else if (el.t==='parenthetical') out += '('+el.txt+')\n';
          else if (el.t==='dialogue') out += el.txt + '\n';
          else if (el.t==='transition') out += '\n> '+el.txt.toUpperCase()+'\n';
          else out += '\n'+el.txt+'\n';
        });
        out += '\n';
      });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([out], {type:'text/plain'}));
      a.download = (project.title||'script') + '.fountain';
      a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    }
    const SCRIPT_LINES_PER_PAGE = 55;

    function sanitizePrintableUrl(url){
      const raw = typeof url === 'string' ? url.trim() : '';
      if (!raw) return '';
      try {
        const parsed = new URL(raw, window.location.origin);
        if (!/^https?:$/i.test(parsed.protocol)) return '';
        return parsed.href;
      } catch (err){
        return '';
      }
    }

    function estimateScenePageCount(scene){
      if (!scene || !Array.isArray(scene.elements)) return 1;
      const lineCount = scene.elements.length || 0;
      return Math.max(1, Math.ceil(lineCount / SCRIPT_LINES_PER_PAGE));
    }

    function buildPrintableSceneToc(scenes){
      const entries = [];
      let pageCounter = 1;
      scenes.forEach((scene, index) => {
        const pages = estimateScenePageCount(scene);
        const start = pageCounter;
        const end = start + pages - 1;
        entries.push({
          number: index + 1,
          heading: scene.slug || `Scene ${index + 1}`,
          pageStart: start,
          pageEnd: end
        });
        pageCounter = end + 1;
      });
      return entries;
    }

    function printableScriptLine(element){
      const normalized = normalizeSceneElement(element);
      const type = (normalized.t || 'action').toLowerCase();
      let text = normalized.txt || '';
      if (!text){
        return '<div class="print-script-line spacer">&nbsp;</div>';
      }
      if (type === 'slug' || type === 'transition' || type === 'character'){
        text = text.toUpperCase();
      }
      const safeText = escapeHtml(text);
      const className = `print-script-line ${escapeHtml(type)}`;
      return `<div class="${className}">${safeText}</div>`;
    }

    function buildPrintableScript(scenes){
      if (!scenes.length){
        return '<p class="print-empty">No scenes yet.</p>';
      }
      return scenes.map(scene => {
        const lines = Array.isArray(scene.elements) ? scene.elements.map(printableScriptLine).join('') : '';
        return `<section class="print-script-scene">${lines}</section>`;
      }).join('<div class="print-scene-separator"></div>');
    }

    function buildPrintableCharacters(characters){
      if (!characters.length){
        return '<p class="print-empty">No characters documented.</p>';
      }
      return characters.map(character => {
        const metaParts = [];
        if (character.role) metaParts.push(character.role);
        if (character.pronouns) metaParts.push(character.pronouns);
        if (character.age) metaParts.push(`Age ${character.age}`);
        if (character.archetype) metaParts.push(character.archetype);
        const meta = metaParts.length ? `<p class="print-character-meta">${escapeHtml(metaParts.join(' ‚Ä¢ '))}</p>` : '';
        const summary = character.summary ? `<p class="print-character-summary">${escapeHtml(character.summary)}</p>` : '';
        const traits = Array.isArray(character.traits) && character.traits.length
          ? `<ul class="print-character-traits">${character.traits.map(trait => `<li>${escapeHtml(trait)}</li>`).join('')}</ul>`
          : '';
        const stats = character.stats || {};
        const statsItems = [];
        if (Number.isFinite(Number(stats.scenes)) && Number(stats.scenes) > 0) statsItems.push(`<span>Scenes: ${escapeHtml(String(stats.scenes))}</span>`);
        if (Number.isFinite(Number(stats.dialogue)) && Number(stats.dialogue) > 0) statsItems.push(`<span>Dialogue lines: ${escapeHtml(String(stats.dialogue))}</span>`);
        if (Number.isFinite(Number(stats.screenTime)) && Number(stats.screenTime) > 0) statsItems.push(`<span>Screen time: ${escapeHtml(String(stats.screenTime))} min</span>`);
        const statsMarkup = statsItems.length ? `<p class="print-character-stats">${statsItems.join(' ‚Ä¢ ')}</p>` : '';
        const turnaroundUrl = Array.isArray(character.looks?.turnarounds) && character.looks.turnarounds.length
          ? sanitizePrintableUrl(character.looks.turnarounds[0])
          : '';
        const turnaround = turnaroundUrl
          ? `<div class="print-character-turnaround"><img src="${escapeHtml(turnaroundUrl)}" alt="${escapeHtml(character.name ? `${character.name} turnaround` : 'Character turnaround')}" loading="lazy" /></div>`
          : '';
        return `
          <article class="print-character-card">
            <div class="print-character-body">
              <h3>${escapeHtml(character.name || 'Untitled Character')}</h3>
              ${meta}
              ${summary}
              ${statsMarkup}
              ${traits}
            </div>
            ${turnaround}
          </article>`;
      }).join('');
    }

    function buildPrintableStoryboard(entries){
      if (!entries.length){
        return '<p class="print-empty">No storyboard frames yet.</p>';
      }
      return `<div class="print-storyboard-grid">${entries.map(entry => {
        const caption = entry.sceneNumber
          ? `Scene ${entry.sceneNumber}${entry.sceneSlug ? ` ‚Ä¢ ${entry.sceneSlug}` : ''}`
          : (entry.sceneSlug || 'Storyboard');
        const reference = entry.index ? `${caption} ‚Ä¢ Shot ${entry.index}` : caption;
        if (entry.type === STORYBOARD_MEDIA_VIDEO){
          const urlText = entry.displayUrl ? `<span>${escapeHtml(entry.displayUrl)}</span>` : '<span>Clip URL unavailable</span>';
          return `
            <figure class="print-storyboard-card">
              <div class="print-storyboard-video">Video clip reference<br />${urlText}</div>
              <figcaption>${escapeHtml(reference)}</figcaption>
            </figure>`;
        }
        return `
          <figure class="print-storyboard-card">
            <img src="${escapeHtml(entry.url)}" alt="${escapeHtml(reference)}" loading="lazy" />
            <figcaption>${escapeHtml(reference)}</figcaption>
          </figure>`;
      }).join('')}</div>`;
    }

    function buildPrintableDocument(){
      const title = project?.title?.trim() || 'Untitled Project';
      const coverImage = sanitizePrintableUrl(project?.settings?.coverImageUrl);
      const scenes = Array.isArray(project?.scenes) ? project.scenes.map(scene => ({
        ...scene,
        elements: Array.isArray(scene.elements) ? scene.elements.map(normalizeSceneElement) : []
      })) : [];
      const tocEntries = buildPrintableSceneToc(scenes);
      const characters = Array.isArray(project?.catalogs?.characters)
        ? project.catalogs.characters.map(normalizeCharacter)
        : [];
      const storyboardEntries = scenes.flatMap((scene, index) => {
        const storyboards = getSceneStoryboards(scene);
        return storyboards.map((entry, storyboardIndex) => {
          const sanitizedUrl = sanitizePrintableUrl(entry.url);
          const isVideo = entry.type === STORYBOARD_MEDIA_VIDEO;
          if (!isVideo && !sanitizedUrl) return null;
          const displayUrl = sanitizedUrl || entry.url || '';
          if (!displayUrl) return null;
          return {
            url: sanitizedUrl || displayUrl,
            displayUrl,
            type: entry.type,
            sceneNumber: index + 1,
            sceneSlug: scene.slug || `Scene ${index + 1}`,
            index: storyboardIndex + 1
          };
        }).filter(Boolean);
      });

      const tocMarkup = tocEntries.length
        ? `<table class="print-toc-table">
            <thead>
              <tr>
                <th scope="col">Scene</th>
                <th scope="col">Heading</th>
                <th scope="col">Pages</th>
              </tr>
            </thead>
            <tbody>
              ${tocEntries.map(entry => {
                const pageLabel = entry.pageStart === entry.pageEnd
                  ? String(entry.pageStart)
                  : `${entry.pageStart}‚Äì${entry.pageEnd}`;
                return `<tr>
                  <td>${escapeHtml(String(entry.number))}</td>
                  <td>${escapeHtml(entry.heading)}</td>
                  <td>${escapeHtml(pageLabel)}</td>
                </tr>`;
              }).join('')}
            </tbody>
          </table>`
        : '<p class="print-empty">No scenes available for table of contents.</p>';

      const scriptMarkup = buildPrintableScript(scenes);
      const characterMarkup = buildPrintableCharacters(characters);
      const storyboardMarkup = buildPrintableStoryboard(storyboardEntries);

      return `<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>${escapeHtml(title)} ‚Äî Export</title>
    <style>
      @page { size: 8.5in 11in; margin: 1in; }
      body { margin: 0; font-family: 'Courier Prime', 'Courier New', Courier, monospace; color: #111; background: #fff; }
      .print-document { margin: 0; padding: 0; }
      .print-section { page-break-after: always; padding: 0; box-sizing: border-box; }
      .print-section:last-child { page-break-after: auto; }
      .print-title-page { min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; gap: 24px; }
      .print-title-page h1 { font-size: 36px; letter-spacing: 1px; margin: 0; text-transform: uppercase; }
      .print-title-page img { max-width: 60%; height: auto; border: 1px solid #d0d0d0; border-radius: 8px; }
      .print-toc { padding: 48px; }
      .print-toc h2 { font-size: 20px; margin: 0 0 24px; text-transform: uppercase; letter-spacing: 1px; }
      .print-toc-table { width: 100%; border-collapse: collapse; font-size: 12pt; }
      .print-toc-table th, .print-toc-table td { padding: 8px 10px; border-bottom: 1px solid #d0d0d0; text-align: left; }
      .print-toc-table th { text-transform: uppercase; font-size: 11pt; letter-spacing: .8px; }
      .print-empty { font-size: 12pt; color: #777; }
      .print-script { padding: 48px 54px; }
      .print-script-line { font-size: 12pt; margin: 0 0 12pt; white-space: pre-wrap; }
      .print-script-line.slug { margin-left: 0; font-weight: 600; }
      .print-script-line.action, .print-script-line.exposition { margin-left: 0; margin-right: 0; }
      .print-script-line.character { margin-left: 3in; margin-right: 1.5in; font-weight: 600; }
      .print-script-line.parenthetical { margin-left: 2.5in; margin-right: 2in; font-style: italic; }
      .print-script-line.dialogue { margin-left: 2in; margin-right: 2in; }
      .print-script-line.transition { text-align: right; margin-right: 0; font-weight: 600; }
      .print-script-line.note { margin-left: 1in; margin-right: 1in; font-style: italic; }
      .print-script-line.spacer { min-height: 12pt; }
      .print-script-scene { margin-bottom: 24pt; }
      .print-scene-separator { height: 24pt; }
      .print-blank-page { min-height: 100vh; display: flex; align-items: center; justify-content: center; color: #c0c0c0; font-style: italic; }
      .print-characters { padding: 48px; display: flex; flex-direction: column; gap: 24px; }
      .print-characters h2 { font-size: 20px; margin: 0; text-transform: uppercase; letter-spacing: 1px; }
      .print-character-card { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; border: 1px solid #d8d8d8; border-radius: 12px; padding: 20px; }
      .print-character-card h3 { margin: 0 0 8px; font-size: 16pt; text-transform: uppercase; }
      .print-character-meta { margin: 0 0 12px; font-size: 11pt; color: #444; }
      .print-character-summary { margin: 0 0 12px; font-size: 12pt; line-height: 1.5; }
      .print-character-stats { margin: 0 0 12px; font-size: 11pt; color: #444; }
      .print-character-traits { margin: 0; padding-left: 18px; font-size: 11pt; line-height: 1.4; }
      .print-character-turnaround { display: flex; align-items: center; justify-content: center; }
      .print-character-turnaround img { max-width: 100%; height: auto; border: 1px solid #d0d0d0; border-radius: 8px; }
      .print-storyboard { padding: 48px; }
      .print-storyboard h2 { font-size: 20px; margin: 0 0 24px; text-transform: uppercase; letter-spacing: 1px; }
      .print-storyboard-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 20px; }
      .print-storyboard-card { margin: 0; }
      .print-storyboard-card img { width: 100%; height: auto; border: 1px solid #d0d0d0; border-radius: 8px; }
      .print-storyboard-video { width: 100%; min-height: 140px; border: 1px dashed #d0d0d0; border-radius: 8px; background: #f8f8f8; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; font-size: 11pt; padding: 12px; }
      .print-storyboard-video span { display: block; margin-top: 6px; font-size: 9pt; word-break: break-all; color: #555; }
      .print-storyboard-card figcaption { margin-top: 8px; font-size: 10pt; text-align: center; }
    </style>
  </head>
  <body>
    <div class="print-document">
      <section class="print-section print-title-page">
        <h1>${escapeHtml(title)}</h1>
        ${coverImage ? `<img src="${escapeHtml(coverImage)}" alt="${escapeHtml(title)} cover" />` : ''}
      </section>
      <section class="print-section print-toc">
        <h2>Table of Contents</h2>
        ${tocMarkup}
      </section>
      <section class="print-section print-script">
        ${scriptMarkup}
      </section>
      <section class="print-section print-blank-page">
        <span>This page intentionally left blank.</span>
      </section>
      <section class="print-section print-characters">
        <h2>Characters</h2>
        ${characterMarkup}
      </section>
      <section class="print-section print-storyboard">
        <h2>Storyboard</h2>
        ${storyboardMarkup}
      </section>
    </div>
  </body>
</html>`;
    }

    function printPDF(){
      const html = buildPrintableDocument();
      const printWindow = window.open('', '_blank');
      if (!printWindow){
        alert('Allow pop-ups to export your PDF.');
        return;
      }
      try {
        printWindow.opener = null;
      } catch (err) {
        console.warn('Unable to clear opener on print window:', err);
      }
      printWindow.document.open();
      printWindow.document.write(html);
      printWindow.document.close();
      const triggerPrint = ()=>{
        try {
          printWindow.focus();
          printWindow.print();
        } catch (err){
          console.error('Print failed', err);
        }
      };
      if (printWindow.document.readyState === 'complete'){
        setTimeout(triggerPrint, 250);
      } else {
        printWindow.addEventListener('load', ()=> setTimeout(triggerPrint, 250));
      }
    }

    /* =========================
     * Smart backup (delta/full)
     * =======================*/
    function buildDeltaOrFull(){
      const metaSig = metaSignature(project);
      const metaChanged = metaSig !== lastSerializedMetaHash;

      const known = project._hashes?.scene || {};
      const currentIds = new Set(project.scenes.map(s=>s.id));
      const upserts = [];
      const deletes = [];

      for (const s of project.scenes) {
        const hNow = hashString(stableSceneString(s));
        const hWas = known[s.id];
        if (!hWas || hWas !== hNow) upserts.push(s);
      }
      for (const oldId of Object.keys(known)) {
        if (!currentIds.has(oldId)) deletes.push(oldId);
      }

      const delta = {
        projectId: project.projectId,
        version: project.version,
        meta: metaChanged ? { title: project.title, settings: project.settings, notes: project.notes } : undefined,
        upserts: upserts.length ? upserts : undefined,
        deletes: deletes.length ? deletes : undefined
      };
      const deltaStr = JSON.stringify(delta);
      const deltaBytes = new Blob([deltaStr]).size;

      const needFull =
        project._deltaCountSinceFull >= FULL_SNAPSHOT_EVERY ||
        deltaBytes > MAX_DELTA_BYTES ||
        (project._lastBackedUpVersion === 0);

      if (needFull) {
        const fullData = structuredClone(project);
        delete fullData._hashes;
        delete fullData._lastBackedUpVersion;
        delete fullData._deltaCountSinceFull;
        const fullStr = JSON.stringify(fullData);
        const fullBytes = new Blob([fullStr]).size;
        return { kind: 'full', bytes: fullBytes, data: fullData, metaSig };
      } else {
        return { kind: 'delta', bytes: deltaBytes, data: delta, metaSig };
      }
    }

    const DEFAULT_SCENE_COLOR = '#5FA8FF';
    const SCENE_COLOR_SOURCE_AUTO = 'auto';
    const SCENE_COLOR_SOURCE_CUSTOM = 'custom';

    const STRIPBOARD_COLOR_RULES = [
      {
        id: 'flashback',
        color: '#FFEAB6',
        textColor: '#92400E',
        label: 'Flashback',
        detail: 'Flashback sequence palette',
        test: info => info.isFlashback
      },
      {
        id: 'dream',
        color: '#E3DDFD',
        textColor: '#4338CA',
        label: 'Dream / Vision',
        detail: 'Dream or imagined sequence',
        test: info => info.isDream
      },
      {
        id: 'montage',
        color: '#FFE5F1',
        textColor: '#9D174D',
        label: 'Montage',
        detail: 'Montage sequence highlight',
        test: info => info.isMontage
      },
      {
        id: 'int-ext-day',
        color: '#E8E7FF',
        textColor: '#312E81',
        label: 'Int./Ext. Day',
        detail: 'Stripboard palette (INT/EXT day)',
        test: info => info.interior && info.exterior && info.timeGroup === 'DAY'
      },
      {
        id: 'int-ext-night',
        color: '#F3D1FF',
        textColor: '#86198F',
        label: 'Int./Ext. Night',
        detail: 'Stripboard palette (INT/EXT night)',
        test: info => info.interior && info.exterior && info.timeGroup === 'NIGHT'
      },
      {
        id: 'int-day',
        color: '#F8F4E6',
        textColor: '#1F2937',
        label: 'Interior Day',
        detail: 'Stripboard palette (INT. day)',
        test: info => info.interior && !info.exterior && info.timeGroup === 'DAY'
      },
      {
        id: 'int-night',
        color: '#FFF4CC',
        textColor: '#92400E',
        label: 'Interior Night',
        detail: 'Stripboard palette (INT. night)',
        test: info => info.interior && !info.exterior && info.timeGroup === 'NIGHT'
      },
      {
        id: 'ext-day',
        color: '#E1F8E5',
        textColor: '#065F46',
        label: 'Exterior Day',
        detail: 'Stripboard palette (EXT. day)',
        test: info => info.exterior && !info.interior && info.timeGroup === 'DAY'
      },
      {
        id: 'ext-night',
        color: '#CFE0FF',
        textColor: '#1E3A8A',
        label: 'Exterior Night',
        detail: 'Stripboard palette (EXT. night)',
        test: info => info.exterior && !info.interior && info.timeGroup === 'NIGHT'
      },
      {
        id: 'dawn-dusk',
        color: '#FFDDE1',
        textColor: '#9F1239',
        label: 'Dawn / Dusk',
        detail: 'Stripboard palette (dawn/dusk)',
        test: info => info.timeGroup === 'DAWN_DUSK'
      },
      {
        id: 'continuous',
        color: '#FBE7FF',
        textColor: '#86198F',
        label: 'Continuous',
        detail: 'Continuous time callout',
        test: info => info.timeGroup === 'CONTINUOUS'
      }
    ];

    function normalizeSceneColor(color){
      if (typeof color !== 'string') return DEFAULT_SCENE_COLOR;
      const trimmed = color.trim();
      if (!trimmed) return DEFAULT_SCENE_COLOR;
      const hexMatch = trimmed.match(/^#?([0-9a-f]{6})$/i);
      if (!hexMatch) return DEFAULT_SCENE_COLOR;
      return `#${hexMatch[1].toUpperCase()}`;
    }

    function classifySceneHeading(scene){
      const slug = typeof scene?.slug === 'string' ? scene.slug.trim() : '';
      const upperSlug = slug.toUpperCase();
      const prefixMatch = slug.match(/^(INT\.\/EXT\.|INT-EXT\.|INT\/EXT\.|INT\.|EXT\.)\s*/i);
      const prefix = prefixMatch ? prefixMatch[1].toUpperCase() : '';
      const interior = prefix.includes('INT');
      const exterior = prefix.includes('EXT');
      const { location, timeOfDay } = parseSceneSlugParts(slug);
      const timeContext = `${(timeOfDay || '').toUpperCase()} ${upperSlug}`;
      const isFlashback = /FLASH\s*BACK|FLASHBACK/.test(timeContext);
      const isDream = /(DREAM|IMAGIN|VISION|HALLUCIN|FANTASY)/.test(timeContext);
      const isMontage = /MONTAGE/.test(timeContext);
      let timeGroup = null;
      if (/(DAWN|SUNRISE|SUNSET|DUSK|TWILIGHT|GOLDEN HOUR|EVENING)/.test(timeContext)) timeGroup = 'DAWN_DUSK';
      else if (/(CONTINUOUS|CONT\.|SAME TIME|CONTINUED)/.test(timeContext)) timeGroup = 'CONTINUOUS';
      else if (/(NIGHT|MIDNIGHT|LATE NIGHT|AFTER DARK)/.test(timeContext)) timeGroup = 'NIGHT';
      else if (/(DAY|MORNING|AFTERNOON|NOON|A\.M\.|AM|SUNLIT)/.test(timeContext)) timeGroup = 'DAY';
      if (!timeGroup && /(PM|P\.M\.)/.test(timeContext)) timeGroup = 'NIGHT';
      if (!timeGroup && /(AM|A\.M\.)/.test(timeContext)) timeGroup = 'DAY';
      return {
        slug,
        interior,
        exterior,
        location: location || '',
        timeGroup,
        isFlashback,
        isDream,
        isMontage
      };
    }

    function hashToHue(str){
      const input = (typeof str === 'string' && str.trim()) ? str.trim() : 'DEFAULT';
      let hash = 0;
      for (let i = 0; i < input.length; i++){
        hash = (hash * 31 + input.charCodeAt(i)) >>> 0;
      }
      return hash % 360;
    }

    function hslToHex(h, s, l){
      const hue = ((h % 360) + 360) % 360;
      const sat = Math.max(0, Math.min(100, s)) / 100;
      const light = Math.max(0, Math.min(100, l)) / 100;
      const chroma = (1 - Math.abs(2 * light - 1)) * sat;
      const hp = hue / 60;
      const x = chroma * (1 - Math.abs((hp % 2) - 1));
      let r1 = 0, g1 = 0, b1 = 0;
      if (hp >= 0 && hp < 1){ r1 = chroma; g1 = x; }
      else if (hp >= 1 && hp < 2){ r1 = x; g1 = chroma; }
      else if (hp >= 2 && hp < 3){ g1 = chroma; b1 = x; }
      else if (hp >= 3 && hp < 4){ g1 = x; b1 = chroma; }
      else if (hp >= 4 && hp < 5){ r1 = x; b1 = chroma; }
      else if (hp >= 5 && hp < 6){ r1 = chroma; b1 = x; }
      const m = light - chroma / 2;
      const toHex = (value) => Math.round((value + m) * 255).toString(16).padStart(2, '0');
      return `#${toHex(r1)}${toHex(g1)}${toHex(b1)}`.toUpperCase();
    }

    function hexToRgb(hex){
      const match = /^#?([0-9A-F]{6})$/i.exec(typeof hex === 'string' ? hex.trim() : '');
      if (!match) return { r: 0, g: 0, b: 0 };
      const value = parseInt(match[1], 16);
      return { r: (value >> 16) & 255, g: (value >> 8) & 255, b: value & 255 };
    }

    function getContrastingTextColor(hex){
      const { r, g, b } = hexToRgb(hex);
      const toLinear = (channel) => {
        const norm = channel / 255;
        return norm <= 0.03928 ? norm / 12.92 : Math.pow((norm + 0.055) / 1.055, 2.4);
      };
      const luminance = 0.2126 * toLinear(r) + 0.7152 * toLinear(g) + 0.0722 * toLinear(b);
      return luminance > 0.55 ? '#0F172A' : '#F8FAFC';
    }

    function hexToRgba(hex, alpha){
      const { r, g, b } = hexToRgb(hex);
      const clamped = Math.max(0, Math.min(1, Number.isFinite(alpha) ? alpha : 1));
      return `rgba(${r}, ${g}, ${b}, ${clamped})`;
    }

    function buildLocationPalette(location, fallbackKey){
      const key = (typeof location === 'string' && location.trim()) ? location.trim() : '';
      const basis = key || (typeof fallbackKey === 'string' ? fallbackKey.trim() : 'DEFAULT');
      const hue = hashToHue(basis || 'DEFAULT');
      const color = hslToHex(hue, 45, 68);
      const textColor = getContrastingTextColor(color);
      const detail = key ? `Keyed to ‚Äú${location.trim()}‚Äù` : 'Keyed to scene heading';
      const label = key ? 'Location palette' : 'Default palette';
      return { color, textColor, label, detail };
    }

    function computeAutoSceneColor(scene){
      const info = classifySceneHeading(scene);
      for (const rule of STRIPBOARD_COLOR_RULES){
        try {
          if (rule.test(info)){
            const normalized = normalizeSceneColor(rule.color);
            return {
              color: normalized,
              textColor: rule.textColor || getContrastingTextColor(normalized),
              label: rule.label,
              detail: rule.detail,
              source: SCENE_COLOR_SOURCE_AUTO
            };
          }
        } catch (err) {
          continue;
        }
      }
      if (info.timeGroup === 'DAY'){
        const color = '#DBF0FF';
        return { color, textColor: '#075985', label: 'Daylight', detail: 'Generic daylight palette', source: SCENE_COLOR_SOURCE_AUTO };
      }
      if (info.timeGroup === 'NIGHT'){
        const color = '#C7D2FE';
        return { color, textColor: '#1D4ED8', label: 'Night', detail: 'Generic night palette', source: SCENE_COLOR_SOURCE_AUTO };
      }
      if (info.timeGroup === 'DAWN_DUSK'){
        const color = '#FFE5F0';
        return { color, textColor: '#9D174D', label: 'Dawn / Dusk', detail: 'Generic twilight palette', source: SCENE_COLOR_SOURCE_AUTO };
      }
      if (info.timeGroup === 'CONTINUOUS'){
        const color = '#EDE9FE';
        return { color, textColor: '#5B21B6', label: 'Continuous', detail: 'Continuous action', source: SCENE_COLOR_SOURCE_AUTO };
      }
      const palette = buildLocationPalette(info.location, scene?.slug || scene?.id || 'SCENE');
      return { color: palette.color, textColor: palette.textColor, label: palette.label, detail: palette.detail, source: SCENE_COLOR_SOURCE_AUTO };
    }

    function getSceneColorMeta(scene){
      if (!scene){
        const color = DEFAULT_SCENE_COLOR;
        const textColor = getContrastingTextColor(color);
        return {
          color,
          textColor,
          label: 'Default palette',
          detail: 'No scene selected',
          source: SCENE_COLOR_SOURCE_AUTO,
          sourceLabel: 'Auto',
          description: 'Default palette',
          tooltip: 'Default palette'
        };
      }
      const source = scene.colorSource === SCENE_COLOR_SOURCE_CUSTOM ? SCENE_COLOR_SOURCE_CUSTOM : SCENE_COLOR_SOURCE_AUTO;
      if (source === SCENE_COLOR_SOURCE_CUSTOM){
        const normalized = normalizeSceneColor(scene.color);
        const textColor = getContrastingTextColor(normalized);
        return {
          color: normalized,
          textColor,
          label: 'Custom color',
          detail: 'Manually selected',
          source: SCENE_COLOR_SOURCE_CUSTOM,
          sourceLabel: 'Custom',
          description: 'Custom color ‚Ä¢ manually selected',
          tooltip: 'Custom color'
        };
      }
      const autoMeta = computeAutoSceneColor(scene);
      const normalizedColor = normalizeSceneColor(autoMeta.color);
      const textColor = autoMeta.textColor || getContrastingTextColor(normalizedColor);
      const detail = autoMeta.detail || 'Auto color';
      const label = autoMeta.label || 'Auto color';
      const description = detail ? `${label} ‚Ä¢ ${detail}` : label;
      const tooltip = detail ? `${label} ‚Äî ${detail}` : label;
      return {
        color: normalizedColor,
        textColor,
        label,
        detail,
        source: SCENE_COLOR_SOURCE_AUTO,
        sourceLabel: 'Auto',
        description,
        tooltip
      };
    }

    function parseSceneSlugParts(slug){
      if (!slug) return { location: null, timeOfDay: null };
      const trimmed = String(slug).trim();
      if (!trimmed) return { location: null, timeOfDay: null };
      const prefixMatch = trimmed.match(/^(INT\.|EXT\.|INT\/EXT\.|INT-EXT\.)\s*(.*)$/i);
      const remainder = prefixMatch ? prefixMatch[2] || '' : trimmed;
      const parts = remainder.split(/\s*-\s*/);
      let location = parts.length ? parts[0].trim() : '';
      const timeOfDay = parts.length > 1 ? parts.slice(1).join(' - ').trim() : '';
      location = location || (prefixMatch ? remainder.trim() : trimmed);
      return {
        location: location || null,
        timeOfDay: timeOfDay || null
      };
    }

    function sceneToSupabaseRow(scene, index, ownerId){
      const { location, timeOfDay } = parseSceneSlugParts(scene.slug || '');
      const safeCards = Array.isArray(scene.cards) ? structuredClone(scene.cards) : [];
      const safeElements = Array.isArray(scene.elements) ? structuredClone(scene.elements) : [];
      const safeSounds = Array.isArray(scene.sounds) ? structuredClone(scene.sounds) : [];
      const safeStoryboards = getSceneStoryboards(scene);
      const characters = Array.isArray(project?.catalogs?.characters)
        ? project.catalogs.characters.map(char => ({ id: char.id || null, name: char.name || '' }))
        : [];
      const locations = Array.isArray(project?.catalogs?.locations)
        ? project.catalogs.locations.map(loc => ({ id: loc.id || null, name: loc.name || '' }))
        : [];
      const colorMeta = getSceneColorMeta(scene);
      const normalizedColor = normalizeSceneColor(colorMeta.color);
      if (scene.colorSource === SCENE_COLOR_SOURCE_CUSTOM){
        const manual = normalizeSceneColor(scene.color);
        if (scene.color !== manual) scene.color = manual;
      } else if (scene.color !== DEFAULT_SCENE_COLOR){
        scene.color = DEFAULT_SCENE_COLOR;
      }
      if (!scene.metadata || typeof scene.metadata !== 'object') scene.metadata = {};
      scene.metadata.sceneColorSource = scene.colorSource || SCENE_COLOR_SOURCE_AUTO;
      return {
        id: scene.id,
        owner_id: ownerId,
        project_id: project.projectId,
        slug: scene.slug || null,
        title: scene.title || location || scene.slug || `Scene ${index + 1}`,
        synopsis: scene.notes || null,
        scene_number: index + 1,
        script_order: index,
        color: normalizedColor,
        location,
        time_of_day: timeOfDay,
        cards: safeCards,
        elements: safeElements,
        sounds: safeSounds,
        metadata: {
          notes: scene.notes || '',
          projectTitle: project.title || '',
          projectNotes: project.notes || '',
          projectVersion: project.version || 0,
          projectUpdatedAt: project.updatedAt || Date.now(),
          settings: {
            theme: project.settings?.theme || null,
            smartFormat: typeof project.settings?.smartFormat === 'boolean' ? project.settings.smartFormat : null
          },
          catalogs: { characters, locations },
          storyboards: safeStoryboards,
          sceneColorSource: scene.colorSource || SCENE_COLOR_SOURCE_AUTO,
          sceneAutoColorLabel: colorMeta.label,
          sceneAutoColorDetail: colorMeta.detail
        }
      };
    }

    function sceneStoryboardsToRows(scene, ownerId){
      const storyboards = getSceneStoryboards(scene);
      return storyboards.map(entry => ({
        id: entry.id,
        owner_id: ownerId,
        project_id: project.projectId,
        scene_id: scene.id,
        position: entry.position,
        image_url: entry.url
      }));
    }

    async function backupToSupabase(supabase, { userInitiated = false } = {}){
      if (!project || !Array.isArray(project.scenes)){
        if (userInitiated) alert('No project loaded to back up yet.');
        return false;
      }
      try {
        const session = await getSupabaseSession(supabase);
        if (!session || !session.user){
          if (userInitiated) alert('Sign in to back up your project to the cloud.');
          return false;
        }
        const ownerId = session.user.id;
        ensureProjectShape();
        const scenes = project.scenes.map((scene, index) => sceneToSupabaseRow(scene, index, ownerId));
        const storyboardRows = project.scenes.flatMap(scene => sceneStoryboardsToRows(scene, ownerId));

        const { error: deleteError } = await supabase
          .from('scenes')
          .delete()
          .eq('owner_id', ownerId)
          .eq('project_id', project.projectId);
        if (deleteError) throw deleteError;

        let storyboardTableAvailable = true;
        const { error: storyboardDeleteError } = await supabase
          .from('scene_storyboards')
          .delete()
          .eq('owner_id', ownerId)
          .eq('project_id', project.projectId);
        if (storyboardDeleteError){
          if (isTableMissingError(storyboardDeleteError)) storyboardTableAvailable = false;
          else throw storyboardDeleteError;
        }

        if (scenes.length){
          const { error: upsertError } = await supabase
            .from('scenes')
            .upsert(scenes, { onConflict: 'id' });
          if (upsertError) throw upsertError;
        }

        if (storyboardRows.length && storyboardTableAvailable){
          const { error: storyboardUpsertError } = await supabase
            .from('scene_storyboards')
            .upsert(storyboardRows, { onConflict: 'id' });
          if (storyboardUpsertError && !isTableMissingError(storyboardUpsertError)) throw storyboardUpsertError;
        }

        project._hashes.scene = {};
        project.scenes.forEach(s => {
          project._hashes.scene[s.id] = hashString(stableSceneString(s));
        });
        project._lastBackedUpVersion = project.version;
        project._deltaCountSinceFull = 0;
        lastSerializedMetaHash = metaSignature(project);
        await saveLocal(project);

        console.info('Backed up project to Supabase.');
        return true;
      } catch (err) {
        if (userInitiated) alert('Backup failed. Please try again.');
        console.error('Supabase backup failed:', err);
        return false;
      }
    }

    async function saveActiveSceneToSupabase(){
      const supabase = window.supabaseClient;
      const saveSceneBtn = document.getElementById('saveSceneBtn');
      const saveSceneMenuAction = document.getElementById('saveSceneMenuAction');
      const saveMenu = document.getElementById('saveMenu');
      if (saveMenu) saveMenu.classList.remove('open');
      if (saveSceneBtn) saveSceneBtn.setAttribute('aria-expanded', 'false');
      if (!supabase){
        alert('Supabase is still initializing. Please try again in a moment.');
        setSaveSceneStatus('error', 'Supabase unavailable');
        return;
      }
      if (!project || !Array.isArray(project.scenes) || !project.scenes.length){
        alert('No project loaded to save.');
        setSaveSceneStatus('error', 'Nothing to save');
        return;
      }
      const sceneIndex = project.scenes.findIndex(s => s.id === activeSceneId);
      if (sceneIndex < 0){
        alert('Select a scene before saving.');
        setSaveSceneStatus('error', 'No scene selected');
        return;
      }

      setSaveSceneStatus('saving', 'Saving‚Ä¶');
      if (saveSceneMenuAction) saveSceneMenuAction.disabled = true;

      try {
        const session = await getSupabaseSession(supabase);
        if (!session || !session.user){
          setSaveSceneStatus('error', 'Sign in required');
          alert('Sign in to save your scene to the cloud.');
          return;
        }
        ensureProjectShape();
        const scene = project.scenes[sceneIndex];
        const ownerId = session.user.id;
        const row = sceneToSupabaseRow(scene, sceneIndex, ownerId);
        const { error } = await supabase
          .from('scenes')
          .upsert(row, { onConflict: 'id' });
        if (error) throw error;

        const storyboardRows = sceneStoryboardsToRows(scene, ownerId);
        let storyboardTableAvailable = true;
        try {
          const { error: deleteStoryboardsError } = await supabase
            .from('scene_storyboards')
            .delete()
            .eq('owner_id', ownerId)
            .eq('scene_id', row.id);
          if (deleteStoryboardsError && !isTableMissingError(deleteStoryboardsError)) throw deleteStoryboardsError;
          if (storyboardRows.length){
            const { error: upsertStoryboardsError } = await supabase
              .from('scene_storyboards')
              .upsert(storyboardRows, { onConflict: 'id' });
            if (upsertStoryboardsError && !isTableMissingError(upsertStoryboardsError)) throw upsertStoryboardsError;
          }
        } catch (storyboardSaveError){
          if (isTableMissingError(storyboardSaveError)){
            storyboardTableAvailable = false;
          } else {
            throw storyboardSaveError;
          }
        }

        const { data: fetchedRow, error: fetchError } = await supabase
          .from('scenes')
          .select('id, owner_id, project_id, slug, title, synopsis, scene_number, script_order, color, location, time_of_day, cards, elements, sounds, metadata')
          .eq('owner_id', ownerId)
          .eq('id', row.id)
          .maybeSingle();
        if (fetchError) throw fetchError;
        if (!fetchedRow) throw new Error('Saved scene not found for verification.');

        let remoteStoryboardRows = [];
        if (storyboardTableAvailable){
          try {
            const { data: storyboardData, error: storyboardFetchError } = await supabase
              .from('scene_storyboards')
              .select('id, image_url, position')
              .eq('owner_id', ownerId)
              .eq('scene_id', row.id)
              .order('position', { ascending: true });
            if (storyboardFetchError && !isTableMissingError(storyboardFetchError)) throw storyboardFetchError;
            if (!storyboardFetchError) remoteStoryboardRows = Array.isArray(storyboardData) ? storyboardData : [];
          } catch (storyboardFetchError){
            if (isTableMissingError(storyboardFetchError)){
              storyboardTableAvailable = false;
            } else {
              throw storyboardFetchError;
            }
          }
        }

        const localSnapshot = sanitizeSceneRow(row);
        if (storyboardTableAvailable){
          localSnapshot.storyboards = sanitizeStoryboardStateForComparison(scene);
        }
        const remoteSnapshot = sanitizeSceneRow(fetchedRow);
        if (storyboardTableAvailable){
          remoteSnapshot.storyboards = sanitizeStoryboardRowForComparison(remoteStoryboardRows);
        }
        if (!scenesMatch(localSnapshot, remoteSnapshot)){
          console.error('Supabase verification mismatch:', { localSnapshot, remoteSnapshot });
          throw new Error('Saved scene verification failed.');
        }

        updateSceneHash(scene);
        lastSerializedMetaHash = metaSignature(project);
        await saveLocal(project);

        console.info('Saved active scene to Supabase.');
        setSaveSceneStatus('success', 'Saved!');
      } catch (err) {
        setSaveSceneStatus('error', 'Save failed. Please try again.');
        alert('Saving scene failed. Please try again.');
        console.error('Supabase scene save failed:', err);
      } finally {
        if (saveSceneMenuAction) saveSceneMenuAction.disabled = false;
      }
    }

    function scheduleSave(){
      clearTimeout(saveTimer);
      saveTimer = setTimeout(async ()=>{
        await saveLocal(project);
      }, 500);
    }

    function scheduleBackup(){
      clearTimeout(backupTimer);
      backupTimer = setTimeout(()=> backupSmart(false), BACKUP_IDLE_MS);
    }

    async function backupSmart(userInitiated = false){
      const supabase = window.supabaseClient;
      if (supabase){
        const saved = await backupToSupabase(supabase, { userInitiated });
        if (saved) return;
      } else if (userInitiated) {
        alert('Backup is still initializing. Please try again in a moment.');
      }

      // In Apps Script context this will exist; in canvas preview it won't.
      if (!(window.google && google.script && google.script.run)) return;
      const pack = buildDeltaOrFull();

      google.script.run
        .withSuccessHandler(res=>{
          if (pack.kind === 'full') project._deltaCountSinceFull = 0;
          else project._deltaCountSinceFull = (project._deltaCountSinceFull || 0) + 1;

          project._lastBackedUpVersion = project.version;
          lastSerializedMetaHash = pack.metaSig || lastSerializedMetaHash;

          if (pack.kind === 'full') {
            project._hashes.scene = {};
            project.scenes.forEach(s=>{
              project._hashes.scene[s.id] = hashString(stableSceneString(s));
            });
          } else {
            (pack.data.upserts || []).forEach(s=>{
              project._hashes.scene[s.id] = hashString(stableSceneString(s));
            });
            (pack.data.deletes || []).forEach(id=> delete project._hashes.scene[id]);
          }
          saveLocal(project);
        })
        .withFailureHandler(err=>{
          console.error('Backup failed:', err);
        })
        .SW_backupProjectDelta({
          projectId: project.projectId,
          version: project.version,
          kind: pack.kind,
          bytes: pack.bytes,
          data: pack.data
        });
    }

    function backupNow(){
      clearTimeout(backupTimer);
      backupSmart(true);
    }

    /* =========================
     * Restore (client-side)
     * =======================*/
    function openRestore(){
      if (!(window.google && google.script && google.script.run)) { alert('Restore unavailable outside Apps Script.'); return; }
      google.script.run
        .withSuccessHandler(rows=>{
          if (!rows || !rows.length){ alert('No backups found.'); return; }
          const preview = rows.slice(0, 20).map((r,i)=> `${i}. ${r.kind.toUpperCase()} ‚Ä¢ v${r.version} ‚Ä¢ ${r.timestamp}`).join('\n');
          const choice = prompt('Choose entry # (0..19):\n' + preview, '0');
          const idx = Number(choice);
          if (isNaN(idx) || idx < 0 || idx >= Math.min(20, rows.length)) return;
          const subset = rows.slice(0, idx+1); // 0 is newest
          let fullIdx = -1;
          for (let i = subset.length-1; i >= 0; i--) {
            if (subset[i].kind === 'full'){ fullIdx = i; break; }
          }
          if (fullIdx === -1){ alert('No full snapshot found in selection window. Try choosing an older entry.'); return; }
          let state = JSON.parse(subset[fullIdx].payloadJSON);
          for (let i = fullIdx-1; i >= 0; i--){
            const entry = subset[i];
            if (entry.kind === 'delta') applyDeltaClient(state, JSON.parse(entry.payloadJSON));
          }
          project = state;
          ensureProjectShape();
          storyboardIndexState.clear();
          (project.scenes || []).forEach(scene => {
            STORYBOARD_MEDIA_MODES.forEach(mode => setStoryboardIndex(scene.id, 0, mode));
          });
          project._hashes = { scene: {} };
          project.scenes.forEach(s => project._hashes.scene[s.id] = hashString(stableSceneString(s)));
          project._lastBackedUpVersion = project.version || 0;
          project._deltaCountSinceFull = 0;
          lastSerializedMetaHash = metaSignature(project);
          saveLocal(project);
          activeSceneId = project.scenes[0]?.id || null;
          render();
          alert('Restored to version ' + (project.version || '?'));
        })
        .withFailureHandler(err=> alert('Failed to load backups: ' + err))
        .SW_loadBackups(project.projectId, 200);
    }

    function applyDeltaClient(state, delta){
      if (delta.meta) {
        if (Object.prototype.hasOwnProperty.call(delta.meta, 'title')) state.title = delta.meta.title;
        if (Object.prototype.hasOwnProperty.call(delta.meta, 'notes')) state.notes = delta.meta.notes;
        if (delta.meta.settings) state.settings = Object.assign({}, state.settings || {}, delta.meta.settings);
      }
      const byId = new Map((state.scenes||[]).map(s => [s.id, s]));
      (delta.upserts || []).forEach(s => byId.set(s.id, s));
      (delta.deletes || []).forEach(id => byId.delete(id));
      state.scenes = Array.from(byId.values());
      if (typeof delta.version === 'number') state.version = Math.max(state.version || 0, delta.version);
    }

    /* =========================
     * Timeline Dock
     * =======================*/
    function setupTimelineDockInteractions(){
      const dock = document.getElementById('timelineDock');
      const handle = document.getElementById('timelineDockHandle');
      if (!dock || !handle) return;
      handle.addEventListener('click', ()=>{
        if (!project) return;
        project.settings = project.settings || {};
        project.settings.timelineDockPinned = !project.settings.timelineDockPinned;
        saveLocal(project);
        syncTimelineDockState(true);
      });
      dock.addEventListener('pointerenter', ()=>{
        timelineHovering = true;
        showTimelineDock();
      });
      dock.addEventListener('pointerleave', ()=>{
        timelineHovering = false;
        scheduleTimelineHide();
      });
      dock.addEventListener('focusin', ()=>{
        timelineHovering = true;
        showTimelineDock();
      });
      dock.addEventListener('focusout', event => {
        if (event.relatedTarget && dock.contains(event.relatedTarget)) return;
        timelineHovering = false;
        scheduleTimelineHide();
      });
    }

    function showTimelineDock(){
      const dock = document.getElementById('timelineDock');
      const handle = document.getElementById('timelineDockHandle');
      if (!dock || !handle) return;
      dock.classList.remove('floating-hidden');
      handle.setAttribute('aria-expanded', 'true');
      clearTimeout(timelineHideTimer);
      timelineHideTimer = null;
    }

    function scheduleTimelineHide(){
      if (timelinePinned) return;
      clearTimeout(timelineHideTimer);
      timelineHideTimer = setTimeout(()=>{
        if (timelinePinned || timelineHovering) return;
        const dock = document.getElementById('timelineDock');
        const handle = document.getElementById('timelineDockHandle');
        if (dock) dock.classList.add('floating-hidden');
        if (handle) handle.setAttribute('aria-expanded', 'false');
        timelineHideTimer = null;
      }, TIMELINE_HIDE_DELAY);
    }

    function syncTimelineDockState(forceReveal){
      const dock = document.getElementById('timelineDock');
      const handle = document.getElementById('timelineDockHandle');
      timelinePinned = !!project?.settings?.timelineDockPinned;
      lastTimelinePinned = timelinePinned;
      if (handle){
        handle.setAttribute('aria-pressed', timelinePinned ? 'true' : 'false');
        handle.setAttribute('aria-label', timelinePinned ? 'Click to float story timelines' : 'Click to pin story timelines');
        handle.title = timelinePinned ? 'Click to float story timelines' : 'Click to pin story timelines';
      }
      if (!dock) return;
      dock.classList.toggle('pinned', timelinePinned);
      dock.classList.toggle('floating', !timelinePinned);
      if (timelinePinned){
        showTimelineDock();
      } else {
        if (forceReveal) showTimelineDock();
        if (!timelineHovering) scheduleTimelineHide();
      }
    }

    /* =========================
     * Focus Mode
     * =======================*/
    const HUD_HIDE_DELAY = 5000;
    let hudPinned = false;
    let hudHideTimer = null;
    let hudHovering = false;

    function setupFocusHudInteractions(){
      const dock = document.getElementById('focusHudDock');
      const handle = document.getElementById('focusHudHandle');
      if (!dock || !handle) return;
      handle.addEventListener('click', ()=>{
        if (!project) return;
        project.settings = project.settings || {};
        project.settings.focusHudPinned = !project.settings.focusHudPinned;
        saveLocal(project);
        syncFocusHudState();
      });
      handle.addEventListener('focus', ()=>{
        if (!document.body.classList.contains('focus-mode')) return;
        showHud();
      });
      handle.addEventListener('blur', ()=>{
        if (!document.body.classList.contains('focus-mode')) return;
        scheduleHudHide();
      });
      dock.addEventListener('pointerenter', ()=>{
        if (!document.body.classList.contains('focus-mode')) return;
        hudHovering = true;
        showHud();
      });
      dock.addEventListener('pointerleave', ()=>{
        if (!document.body.classList.contains('focus-mode')) return;
        hudHovering = false;
        scheduleHudHide();
      });
      dock.addEventListener('focusin', ()=>{
        if (!document.body.classList.contains('focus-mode')) return;
        hudHovering = true;
        showHud();
      });
      dock.addEventListener('focusout', (e)=>{
        if (!document.body.classList.contains('focus-mode')) return;
        if (e.relatedTarget && dock.contains(e.relatedTarget)) return;
        hudHovering = false;
        scheduleHudHide();
      });
      window.addEventListener('resize', ()=>{
        if (typeof requestAnimationFrame === 'function') requestAnimationFrame(updateHudHandleWidth);
        else updateHudHandleWidth();
      });
    }

    function showHud(){
      const dock = document.getElementById('focusHudDock');
      if (!dock) return;
      dock.classList.remove('floating-hidden');
      clearTimeout(hudHideTimer);
      hudHideTimer = null;
      if (typeof requestAnimationFrame === 'function') requestAnimationFrame(updateHudHandleWidth);
      else updateHudHandleWidth();
    }

    function scheduleHudHide(){
      if (hudPinned) return;
      clearTimeout(hudHideTimer);
      hudHideTimer = setTimeout(()=>{
        if (hudPinned) return;
        const dock = document.getElementById('focusHudDock');
        if (dock) dock.classList.add('floating-hidden');
        hudHideTimer = null;
      }, HUD_HIDE_DELAY);
    }

    function updateHudHandleWidth(){
      const handle = document.getElementById('focusHudHandle');
      const hud = document.getElementById('focusHud');
      if (!handle || !hud) return;
      if (hudPinned){
        const width = hud.offsetWidth;
        if (width) handle.style.width = width + 'px';
      } else {
        handle.style.width = '';
      }
    }

    function syncFocusHudState(){
      const dock = document.getElementById('focusHudDock');
      const handle = document.getElementById('focusHudHandle');
      hudPinned = !!project?.settings?.focusHudPinned;
      if (handle){
        handle.setAttribute('aria-pressed', hudPinned ? 'true' : 'false');
        handle.setAttribute('aria-label', hudPinned ? 'Click to float focus controls' : 'Click to pin focus controls');
        handle.title = hudPinned ? 'Click to float focus controls' : 'Click to pin focus controls';
      }
      if (!dock) return;
      dock.classList.toggle('pinned', hudPinned);
      dock.classList.toggle('floating', !hudPinned);
      if (!document.body.classList.contains('focus-mode')){
        clearTimeout(hudHideTimer);
        hudHideTimer = null;
        dock.classList.remove('floating-hidden');
        hudHovering = false;
        updateHudHandleWidth();
        return;
      }
      showHud();
      if (hudPinned){
        clearTimeout(hudHideTimer);
        hudHideTimer = null;
      } else if (!hudHovering) scheduleHudHide();
      else {
        clearTimeout(hudHideTimer);
        hudHideTimer = null;
      }
      updateHudHandleWidth();
    }

    function applyFocusModeUI(){
      const focused = !!project?.settings?.focus;
      document.body.classList.toggle('focus-mode', focused);
      const btn = document.getElementById('focusBtn');
      if (btn) btn.textContent = focused ? 'Exit Focus' : 'Focus';
      updateHud();
      markActiveLine();
      if (focused) centerActiveLine();
      syncNavHeight();
      syncTimelineDockState();
      syncFocusHudState();
    }
    function toggleFocus(){
      project.settings = project.settings || {};
      project.settings.focus = !project.settings.focus;
      saveLocal(project);
      applyFocusModeUI();
    }
    function updateHud(){
      const hudC = document.getElementById('hudCounter');
      const hudSel = document.getElementById('hudScenePicker');
      if (hudC) hudC.textContent = document.getElementById('counter')?.textContent || '';
      if (hudSel){
        hudSel.innerHTML = '';
        project.scenes.forEach((s, i)=>{
          const opt = document.createElement('option');
          opt.value = s.id;
          opt.textContent = `${String(i+1).padStart(2,'0')} ‚Ä¢ ${s.slug || '(no slug)'}`;
          if (s.id === activeSceneId) opt.selected = true;
          hudSel.appendChild(opt);
        });
      }
      if (typeof requestAnimationFrame === 'function') requestAnimationFrame(updateHudHandleWidth);
      else updateHudHandleWidth();
    }
    function pickSceneFromHud(sceneId){
      if (!sceneId) return;
      activeSceneId = sceneId;
      render();
      const hudSel = document.getElementById('hudScenePicker');
      if (hudSel) hudSel.value = sceneId;
      markActiveLine();
      if (document.body.classList.contains('focus-mode')) centerActiveLine();
    }

    /* =========================
     * Pomodoro (Focus HUD)
     * =======================*/
    const POMO_DEFAULTS = { workMin: 25, breakMin: 5, autoStartBreak: true, autoStartWork: false };
    let pomo = { running: false, mode: 'work', endAt: 0, remainingMs: 25*60*1000, _timerId: null };

    function ensurePomodoroSettings(){
      project.settings = project.settings || {};
      project.settings.pomodoro = Object.assign({}, POMO_DEFAULTS, project.settings.pomodoro || {});
      if (!pomo || typeof pomo.remainingMs !== 'number') {
        pomo = {
          running: false, mode: 'work', endAt: 0,
          remainingMs: project.settings.pomodoro.workMin * 60 * 1000,
          _timerId: null
        };
      }
    }
    function fmtMMSS(ms){
      ms = Math.max(0, ms|0);
      const s = Math.round(ms/1000);
      const mm = String(Math.floor(s/60)).padStart(2,'0');
      const ss = String(s%60).padStart(2,'0');
      return `${mm}:${ss}`;
    }
    function updatePomodoroUI(){
      const dial = document.getElementById('pomoTime');
      const modeEl = document.getElementById('pomoMode');
      const ring = dial?.parentElement;
      const tog = document.getElementById('pomoToggle');
      if (!dial || !modeEl || !ring || !tog) return;

      dial.textContent = fmtMMSS(pomo.remainingMs);
      modeEl.textContent = pomo.mode === 'work' ? 'Work' : 'Break';

      const total = (pomo.mode === 'work'
        ? project.settings.pomodoro.workMin
        : project.settings.pomodoro.breakMin) * 60 * 1000;
      const pct = 100 * (1 - (pomo.remainingMs / total));
      ring.style.setProperty('--pct', Math.max(0, Math.min(100, pct)));

      tog.textContent = pomo.running ? 'Pause' : 'Start';

      project._pomoState = { running: pomo.running, mode: pomo.mode, remainingMs: pomo.remainingMs, endAt: pomo.endAt };
      saveLocal(project);
    }
    function startPomodoroTick(){
      stopPomodoroTick();
      pomo.running = true;
      if (pomo.endAt <= Date.now()) pomo.endAt = Date.now() + pomo.remainingMs;
      pomo._timerId = setInterval(()=>{
        const now = Date.now();
        pomo.remainingMs = Math.max(0, pomo.endAt - now);
        updatePomodoroUI();
        if (pomo.remainingMs <= 0) {
          stopPomodoroTick();
          onPomodoroEnd();
        }
      }, 250);
      updatePomodoroUI();
    }
    function stopPomodoroTick(){
      pomo.running = false;
      if (pomo._timerId) clearInterval(pomo._timerId);
      pomo._timerId = null;
      if (pomo.endAt > 0) pomo.remainingMs = Math.max(0, pomo.endAt - Date.now());
      updatePomodoroUI();
    }
    function togglePomodoro(){ if (pomo.running) stopPomodoroTick(); else startPomodoroTick(); }
    function resetPomodoro(){
      const mins = (pomo.mode === 'work' ? project.settings.pomodoro.workMin : project.settings.pomodoro.breakMin);
      pomo.remainingMs = mins * 60 * 1000; pomo.endAt = 0; updatePomodoroUI();
    }
    function switchPomodoroMode(nextMode){
      pomo.mode = nextMode;
      const mins = (pomo.mode === 'work' ? project.settings.pomodoro.workMin : project.settings.pomodoro.breakMin);
      pomo.remainingMs = mins * 60 * 1000; pomo.endAt = 0; updatePomodoroUI();
    }
    function beep(){
      try{
        const ctx = new (window.AudioContext||window.webkitAudioContext)();
        const o = ctx.createOscillator(); const g = ctx.createGain();
        o.type = 'sine'; o.frequency.value = 880; o.connect(g); g.connect(ctx.destination);
        g.gain.setValueAtTime(0.001, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime + 0.01);
        o.start();
        setTimeout(()=>{ g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.05); o.stop(ctx.currentTime + 0.08); }, 180);
      }catch(e){}
    }
    function onPomodoroEnd(){
      beep();
      if (pomo.mode === 'work') {
        switchPomodoroMode('break');
        if (project.settings.pomodoro.autoStartBreak) startPomodoroTick();
      } else {
        switchPomodoroMode('work');
        if (project.settings.pomodoro.autoStartWork) startPomodoroTick();
      }
    }

    /* =========================
     * Shortcuts
     * =======================*/
    document.addEventListener('keydown', (e)=>{
      if (e.key === 'Escape'){
        const dialog = document.getElementById('scriptDialog');
        if (dialog && dialog.classList.contains('open')){
          e.preventDefault();
          closeScriptDialog();
          return;
        }
        if (storyboardMode){
          e.preventDefault();
          closeStoryboardMode();
          return;
        }
      }
      if (e.key === 'Escape' && timelineMode){
        const previewOpen = document.getElementById('timelinePreview')?.classList.contains('open');
        if (previewOpen) closeTimelinePreview();
        else closeTimelineMode();
        return;
      }
      const cmd = e.metaKey || e.ctrlKey;
      if (cmd && e.key.toLowerCase() === 'k') { e.preventDefault(); toggleFocus(); return; }
      if (cmd && e.key === ';') { e.preventDefault(); togglePomodoro(); return; }
      if (cmd && e.key === "'") { e.preventDefault(); resetPomodoro(); return; }
    });

    /* =========================
     * Versioning helpers
     * =======================*/
    function bumpVersion(){ project.version = (project.version || 0) + 1; project.updatedAt = Date.now(); }

    /* =========================
     * Self-tests (basic) ‚Äî won't change user data
     * =======================*/
    function runSelfTests(){
      try {
        // Theme switch test
        const prevTheme = project.settings.theme;
        project.settings.theme = 'light'; applyTheme();
        const lightBg = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim();
        console.assert(lightBg === '#f7f9fc', 'Light theme var not applied');
        project.settings.theme = 'dark'; applyTheme();
        const darkBg = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim();
        console.assert(darkBg === '#0b0f14', 'Dark theme var not applied');
        // Build delta/full doesn't throw
        const pack = buildDeltaOrFull();
        console.assert(pack && (pack.kind==='delta'||pack.kind==='full'), 'buildDeltaOrFull returned invalid kind');
        // Focus HUD exists
        console.assert(document.getElementById('focusHud'), 'focusHud missing');
        console.log('Self-tests passed');
      } catch (err) {
        console.error('Self-tests failed', err);
      }
    }

    /* =========================
     * Bootstrap
     * =======================*/
    (async function init(){
      await openDB();

      // Load last project if exists
      const lastId = getLastProjectId();
      if (lastId) {
        const loaded = await loadLocal(lastId);
        if (loaded) {
          project = loaded;
          lastTimelinePinned = null;
          ensureProjectShape();
          storyboardIndexState.clear();
          (project.scenes || []).forEach(scene => {
            STORYBOARD_MEDIA_MODES.forEach(mode => setStoryboardIndex(scene.id, 0, mode));
          });
          activeSceneId = project.scenes?.[0]?.id || null;
        } else {
          newProject();
          await saveLocal(project);
        }
      } else {
        newProject();
        await saveLocal(project);
      }

      project.settings = project.settings || {};
      if (typeof project.settings.focus === 'undefined') project.settings.focus = false;
      if (typeof project.settings.focusHudPinned === 'undefined') project.settings.focusHudPinned = false;
      if (typeof project.settings.timelineDockPinned === 'undefined') project.settings.timelineDockPinned = true;

      ensurePomodoroSettings();
      if (project._pomoState) {
        pomo = Object.assign({}, pomo, project._pomoState);
        if (!['work','break'].includes(pomo.mode)) pomo.mode = 'work';
      }

      lastSerializedMetaHash = metaSignature(project);
      timelineInsertIndex = Array.isArray(project?.scenes) ? project.scenes.length : 0;
      render();
      applyFocusModeUI();
      updatePomodoroUI();
      setTimeout(runSelfTests, 0);
    })();
    </script>
  </main>

  <footer class="footer">
    <div class="footer__grid">
      <div><strong>StudioOrganize</strong></div>
      <div>
        <a href="mailto:support@studioorganize.com">support@studioorganize.com</a><br/>
        <span class="muted">¬© <span id="y"></span> StudioOrganize</span>
      </div>
    </div>
  </footer>
  <script type="module" src="/assets/main.js"></script>
</body>
</html>
