<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Screenplay Writing — StudioOrganize</title>
  <link rel="stylesheet" href="/assets/styles.css"/>
  <link rel="icon" type="image/webp" href="/assets/img/studioorganizeFavicon.webp"/>
</head>
<body>
  <header class="nav">
    <div class="brand-with-logo">
      <a class="brand" href="/">StudioOrganize</a>
      <img class="brand-with-logo__badge" src="/assets/img/screenplay_writer1.webp" alt="Screenplay Writer app logo" />
    </div>
    <nav class="menu">
      <a class="menu__link" href="/">Home</a>
      <div class="dropdown">
        <button class="dropbtn" type="button">Products</button>
        <div class="dropdown-content">
          <a href="/products/#online">Subscribe &amp; save it online</a>
          <a href="/products/#sheets">Google Sheets — keep the database yourself</a>
        </div>
      </div>
      <div class="dropdown">
        <button class="dropbtn" type="button">Use Cases</button>
        <div class="dropdown-content">
          <a href="/use-cases/">All Use Cases</a>
          <a href="/use-cases/generate-ideas.html">Generate Ideas</a>
          <a href="/use-cases/screenplay.html">Screenplay Script</a>
          <a href="/use-cases/character-design.html">Character Design</a>
          <a href="/use-cases/set-design.html">Set / Production Design</a>
        </div>
      </div>
      <a class="menu__link" href="/about.html">About</a>
      <a class="menu__link" href="/faq.html">FAQ</a>
      <button class="theme-toggle" type="button" data-theme-toggle aria-pressed="false">Toggle theme</button>
      <button class="menu__cta" type="button" data-open-auth="signup" aria-haspopup="dialog" data-auth-cta>Sign up / Log in</button>
    <div class="account-menu" data-account-menu hidden>
      <button class="account-menu__toggle" type="button" data-account-toggle aria-expanded="false">
        <span class="account-menu__label" data-account-label>Account</span>
        <svg class="account-menu__icon" width="12" height="12" viewBox="0 0 12 12" aria-hidden="true" focusable="false">
          <path d="M2.47 4.97a.75.75 0 0 1 1.06 0L6 7.44l2.47-2.47a.75.75 0 1 1 1.06 1.06L6.53 9.03a.75.75 0 0 1-1.06 0L2.47 6.03a.75.75 0 0 1 0-1.06Z" fill="currentColor" />
        </svg>
      </button>
      <div class="account-menu__dropdown" data-account-dropdown>
        <a class="account-menu__item" href="/creative-hub.html">Creative Hub</a>
        <a class="account-menu__item" href="/account.html">My subscription</a>
        <button class="account-menu__item account-menu__logout" type="button" data-account-logout>Log out</button>
      </div>
    </div>
    </nav>
  </header>

  <main class="section">
    <style>
      html,body{height:100%; font-family: ui-sans-serif,system-ui,Segoe UI,Roboto,Arial}
      body{color:var(--ink); --nav-height:72px;}
      main.section{flex:1; display:flex; flex-direction:column; width:100%; max-width:none; padding:0; margin:0;}
      .app{display:grid; grid-template-rows:56px 1fr; flex:1; min-height:0; transition:transform .35s ease}
      .topbar{display:flex; align-items:center; gap:12px; padding:8px 12px; background:var(--panel); border-bottom:1px solid var(--ring)}
      .topbar h1{font-size:16px; font-weight:600; margin:0 8px 0 0}
      .spacer{flex:1}
      .btn{background:var(--chip); color:var(--ink); border:1px solid var(--ring); border-radius:10px; padding:8px 12px; cursor:pointer}
      .btn[data-tab-btn].active{background:var(--acc); border-color:var(--acc); color:var(--active-tab-text); font-weight:600}
      .topbar-group{display:flex; gap:6px; align-items:center}
      .btn-menu{position:relative}
      .btn-menu-list{display:none; position:absolute; right:0; top:calc(100% + 6px); min-width:180px; background:var(--panel); border:1px solid var(--ring); border-radius:12px; box-shadow:0 18px 40px rgba(0,0,0,0.4); padding:6px; z-index:30; flex-direction:column; gap:6px}
      .btn-menu.open .btn-menu-list{display:flex}
      .btn-menu-list button{background:var(--chip); border:1px solid var(--ring); border-radius:10px; padding:8px 10px; text-align:left; color:var(--ink); cursor:pointer}
      .btn-menu-list button:hover{border-color:var(--acc)}
      .layout{display:grid; grid-template-columns:280px 1fr 320px; gap:10px; padding:10px; min-height:0}
      .panel{background:var(--panel); border:1px solid var(--ring); border-radius:14px; overflow:hidden; display:flex; flex-direction:column; min-height:0}
      .panel h2{font-size:13px; font-weight:600; letter-spacing:.4px; color:var(--muted); margin:10px 12px}
      .scenes{overflow:auto; padding:8px}
      .scene-card{background:var(--card); border:1px solid var(--ring); border-radius:12px; padding:10px; margin-bottom:8px; cursor:pointer}
      .scene-card.active{outline:2px solid var(--acc)}
      .scene-card small{color:var(--muted)}
      .editor{padding:0; display:flex; flex-direction:column; min-height:0}
      .editor-area{flex:1; overflow:auto; padding:16px 20px; line-height:1.6; font-size:15px; white-space:pre-wrap; outline:none; direction:ltr; writing-mode:horizontal-tb; unicode-bidi:plaintext}
      .line{margin:6px 0}
      .line.slug{letter-spacing:.4px; font-weight:700}
      .line.character{text-transform:uppercase; margin-top:14px; margin-bottom:2px}
      .line.parenthetical{margin-left:30px; font-style:italic}
      .line.dialogue{margin-left:30px; max-width:60ch}
      .line.transition{text-align:right; letter-spacing:.2px}
      .notes{padding:8px; display:flex; flex-direction:column; gap:8px; overflow:auto}
      textarea, input, select{background:var(--field); color:var(--ink); border:1px solid var(--ring); border-radius:10px; padding:8px; width:100%}
      .row{display:flex; gap:8px}
      .counter{font-size:12px; color:var(--muted)}
      .tab-header{display:flex; padding:8px; gap:6px; background:var(--chip); border-bottom:1px solid var(--ring)}
      .tab-btn{flex:1; background:var(--chip); border:1px solid var(--ring); border-radius:10px; padding:8px 10px; font-size:12px; color:var(--ink); cursor:pointer; letter-spacing:.3px; text-transform:uppercase}
      .tab-btn.active{background:var(--acc); border-color:var(--acc); color:var(--active-tab-text); font-weight:600}
      .tab-panels{flex:1; display:flex; flex-direction:column; min-height:0}
      .tab-panel{display:none; flex-direction:column; flex:1; padding:12px; gap:12px; overflow:auto}
      .tab-panel.active{display:flex}
      .tab-panel h3{margin:0; font-size:12px; letter-spacing:.4px; color:var(--muted); text-transform:uppercase}
      .panel-footer{padding:12px; border-top:1px solid var(--ring); display:flex; flex-direction:column; gap:10px; background:var(--panel)}
      .panel-footer h2{margin:0; font-size:13px; font-weight:600; letter-spacing:.4px; color:var(--muted); text-transform:uppercase}
      .timeline-list{display:flex; flex-direction:column; gap:10px}
      .timeline-item{display:flex; gap:10px; align-items:flex-start; padding:10px; border:1px solid var(--ring); border-radius:12px; background:var(--chip); cursor:pointer; transition:background .2s, border-color .2s; font:inherit; color:inherit; text-align:left}
      .timeline-item:hover{border-color:var(--acc)}
      .timeline-item.active{background:var(--acc); border-color:var(--acc); color:var(--active-tab-text)}
      .timeline-item.active .timeline-bullet{background:var(--active-tab-text); color:var(--panel)}
      .timeline-bullet{width:26px; height:26px; border-radius:999px; background:var(--ring); color:var(--muted); display:flex; align-items:center; justify-content:center; font-size:12px; font-weight:600}
      .timeline-item:focus{outline:none}
      .timeline-item:focus-visible{outline:2px solid var(--acc); outline-offset:2px}
      .timeline-body{display:flex; flex-direction:column; gap:4px}
      .timeline-meta{font-size:11px; color:var(--muted)}
      .timeline-item.active .timeline-meta{color:var(--active-tab-text)}
      .timeline-empty{font-size:12px; color:var(--muted)}
      body.timeline-mode{overflow:hidden;}
      #timelineOverlay{
        position:fixed; left:0; right:0; bottom:0; top:var(--nav-height, 72px);
        background:rgba(10,12,18,0.78);
        backdrop-filter:blur(16px);
        display:none; align-items:flex-start; justify-content:center;
        padding:24px clamp(16px, 4vw, 48px) 32px; z-index:400;
      }
      body.timeline-mode #timelineOverlay{display:flex;}
      .timeline-window{
        position:relative; width:100%; max-width:1100px; min-height:0;
        background:var(--panel); border:1px solid var(--ring);
        border-radius:20px; box-shadow:0 28px 90px rgba(0,0,0,0.45);
        display:flex; flex-direction:column; overflow:hidden;
      }
      .timeline-overlay-header{
        display:flex; align-items:center; justify-content:space-between;
        padding:18px 22px; border-bottom:1px solid var(--ring);
        gap:12px; background:var(--chip);
      }
      .timeline-overlay-header h2{margin:0; font-size:18px; font-weight:600;}
      .timeline-overlay-header .muted-text{margin:0;}
      .timeline-close-btn{
        background:var(--chip); border:1px solid var(--ring); border-radius:999px;
        padding:6px 12px; cursor:pointer; color:var(--ink);
      }
      .timeline-overlay-body{padding:20px 22px; display:flex; flex-direction:column; gap:16px; overflow:auto;}
      .timeline-prompt{font-size:14px; color:var(--muted);}
      .timeline-board-wrapper{overflow-x:auto; padding-bottom:8px;}
      .timeline-board{
        display:flex; gap:14px; align-items:stretch; min-height:220px;
        padding:4px 6px; flex-wrap:nowrap;
      }
      .timeline-card{
        flex:0 0 240px; background:var(--card); border:1px solid var(--ring);
        border-radius:16px; padding:16px; display:flex; flex-direction:column;
        gap:10px; cursor:pointer; position:relative; transition:transform .2s ease, border-color .2s ease, box-shadow .2s ease;
      }
      .timeline-card:hover{border-color:var(--acc); box-shadow:0 16px 40px rgba(0,0,0,0.28); transform:translateY(-2px);}
      .timeline-card.active{border-color:var(--acc); box-shadow:0 16px 48px rgba(47,110,255,0.32);}
      .timeline-card.dragging{opacity:0.6; box-shadow:none; transform:rotate(-2deg);} 
      .timeline-card small{color:var(--muted); font-size:11px; letter-spacing:.3px; text-transform:uppercase;}
      .timeline-card h4{margin:0; font-size:15px; line-height:1.35;}
      .timeline-card-snippet{font-size:13px; line-height:1.5; color:var(--inkMuted, var(--muted));}
      .timeline-card-actions{display:flex; justify-content:space-between; align-items:center; font-size:12px; color:var(--muted);}
      .timeline-dropzone{
        flex:0 0 52px; border:1px dashed transparent; border-radius:14px;
        display:flex; align-items:center; justify-content:center; position:relative;
        transition:border-color .2s ease, background .2s ease;
      }
      .timeline-dropzone.over{border-color:var(--acc); background:rgba(95,168,255,0.12);}
      .timeline-add-btn{
        background:var(--chip); border:1px solid var(--ring); border-radius:12px;
        padding:10px 12px; font-size:12px; cursor:pointer; color:var(--ink);
        display:flex; align-items:center; gap:6px;
      }
      .timeline-add-btn:hover{border-color:var(--acc);}
      .timeline-overlay-footer{
        padding:20px 22px 24px; border-top:1px solid var(--ring);
        background:var(--panel); display:flex; flex-direction:column; gap:12px;
      }
      .timeline-composer{display:flex; flex-direction:column; gap:10px;}
      .timeline-composer label{font-size:12px; letter-spacing:.3px; text-transform:uppercase; color:var(--muted);}
      .timeline-composer input,
      .timeline-composer textarea{background:var(--field); color:var(--ink); border:1px solid var(--ring); border-radius:12px; padding:10px 12px; font-size:14px; width:100%;}
      .timeline-composer textarea{min-height:96px; resize:vertical;}
      .timeline-composer-actions{display:flex; align-items:center; gap:12px; flex-wrap:wrap;}
      .timeline-position-label{font-size:12px; color:var(--muted);}
      .timeline-save-btn{
        background:var(--acc); border:1px solid var(--acc); color:var(--active-tab-text);
        border-radius:999px; padding:8px 18px; font-weight:600; letter-spacing:.3px; cursor:pointer;
      }
      .timeline-save-btn:disabled{opacity:0.5; cursor:not-allowed;}
      #timelinePreview{
        position:absolute; inset:16px; display:none; align-items:center; justify-content:center;
        pointer-events:none;
      }
      #timelinePreview.open{display:flex;}
      .timeline-preview-card{
        pointer-events:auto; width:min(640px, calc(100% - 40px)); max-height:calc(100% - 40px);
        background:var(--card); border:1px solid var(--ring); border-radius:18px;
        box-shadow:0 28px 80px rgba(0,0,0,0.45); display:flex; flex-direction:column;
        overflow:hidden; transform:scale(.94); opacity:0;
        transform-origin:calc(var(--origin-x, .5) * 100%) calc(var(--origin-y, .5) * 100%);
        transition:transform .24s ease, opacity .24s ease;
      }
      #timelinePreview.open .timeline-preview-card{transform:scale(1); opacity:1;}
      .timeline-preview-header{padding:18px 22px; border-bottom:1px solid var(--ring); display:flex; flex-direction:column; gap:6px;}
      .timeline-preview-header h3{margin:0; font-size:18px;}
      .timeline-preview-meta{font-size:12px; color:var(--muted);}
      .timeline-preview-body{padding:18px 22px 22px; overflow:auto; flex:1; display:flex; flex-direction:column; gap:8px;}
      .timeline-preview-body .line{margin:0;}
      .timeline-preview-actions{padding:16px 22px; border-top:1px solid var(--ring); display:flex; justify-content:flex-end; gap:12px; background:var(--chip);}
      .timeline-secondary-btn{
        background:var(--chip); border:1px solid var(--ring); border-radius:12px;
        padding:8px 14px; font-size:13px; cursor:pointer; color:var(--ink);
      }
      .timeline-secondary-btn:hover{border-color:var(--acc);}
      .stats-grid{display:grid; grid-template-columns:repeat(auto-fit, minmax(90px, 1fr)); gap:10px}
      .stat-card{border:1px solid var(--ring); border-radius:12px; padding:10px; background:var(--chip); display:flex; flex-direction:column; gap:4px; text-align:center}
      .stat-value{font-size:18px; font-weight:700; color:var(--ink)}
      .stat-label{font-size:11px; color:var(--muted); letter-spacing:.3px; text-transform:uppercase}
      .tab-chip-group{display:flex; flex-wrap:wrap; gap:6px}
      .tab-chip{background:var(--chip); border:1px solid var(--ring); border-radius:10px; padding:6px 10px; font-size:12px; color:var(--ink); cursor:pointer}
      .tab-chip:hover{border-color:var(--acc)}
      .danger-btn{background:#7f1d1d; border:1px solid #b91c1c; color:#fff; border-radius:10px; padding:8px 10px; font-size:12px; cursor:pointer}
      .danger-btn:disabled{opacity:0.5; cursor:not-allowed}
      .catalog-list{display:flex; flex-direction:column; gap:6px}
      .catalog-item{display:flex; justify-content:space-between; align-items:center; gap:8px; background:var(--card); border:1px solid var(--ring); border-radius:10px; padding:8px 10px}
      .catalog-item span{font-size:13px}
      .catalog-actions{display:flex; gap:6px}
      .catalog-actions button{background:var(--chip); border:1px solid var(--ring); border-radius:8px; padding:4px 8px; font-size:11px; color:var(--ink); cursor:pointer}
      .muted-text{color:var(--muted); font-size:12px}
      .tab-divider{height:1px; background:var(--ring); margin:4px 0}
      .sound-list{display:flex; flex-direction:column; gap:6px}
      .sound-item{display:flex; justify-content:space-between; align-items:center; gap:8px; background:var(--card); border:1px solid var(--ring); border-radius:10px; padding:8px 10px}
      .sound-item button{background:var(--chip); border:1px solid var(--ring); border-radius:8px; padding:4px 8px; font-size:11px; color:var(--ink); cursor:pointer}

      /* ==== Focus Mode ==== */
      body.focus-mode .layout{ grid-template-columns: 1fr; }
      body.focus-mode .layout .panel:first-child,
      body.focus-mode .layout .panel:last-child{ display:none !important; }
      body.focus-mode .editor-area{
        max-width: 68ch;
        margin: 0 auto;
        padding: 48px 24px;
        font-size: 17px;
        line-height: 1.7;
      }
      body.focus-mode .topbar .non-essential{ display:none !important; }

      /* Line highlight */
      .line.active{ background: rgba(255,255,255,0.05); border-radius: 8px; padding: 2px 6px; }
      body.focus-mode .line.active{ background: rgba(95,168,255,0.12); }

      /* Site chrome animations for focus mode */
      .nav,
      .footer{
        transition: transform 0.35s ease, opacity 0.3s ease;
        transform: translateY(0);
        opacity: 1;
      }
      body.focus-mode .nav{
        transform: translateY(-100%);
        opacity: 0;
        pointer-events: none;
      }
      body.focus-mode .footer{
        transform: translateY(100%);
        opacity: 0;
        pointer-events: none;
      }

      body.focus-mode .app{ transform: translateY(calc(-1 * var(--nav-height, 0px))); }

      /* Bottom HUD visible only in focus mode */
      #focusHud{
        position: fixed; left: 50%; bottom: 18px; transform: translateX(-50%);
        background: var(--hud); border: 1px solid var(--ring); border-radius: 12px;
        padding: 8px 12px; display: none; gap: 8px; align-items: center;
        box-shadow: 0 8px 24px rgba(0,0,0,0.35); z-index: 9999;
      }
      body.focus-mode #focusHud{ display:flex; }
      #focusHud .hud-text{ font-size:12px; color: var(--muted); white-space:nowrap }
      #focusHud select, #focusHud button{background:var(--chip); color:var(--ink); border:1px solid var(--ring);
        border-radius:10px; padding:6px 10px; font-size:12px; cursor:pointer
      }

      /* ==== Pomodoro (Focus HUD) ==== */
      #focusHud .pomo-chip{display:flex; align-items:center; gap:10px; padding:6px 8px; border-radius:10px;
        background:var(--chip); border:1px solid var(--ring);
      }
      .pomo-ring{
        --pct: 0; /* 0..100 */
        width:44px; height:44px; border-radius:50%;
        background: conic-gradient(var(--acc) calc(var(--pct)*1%), var(--progressTrack) 0);
        display:grid; place-items:center;
      }
      .pomo-dial{
        width:34px; height:34px; border-radius:50%;
        display:grid; place-items:center;
        background:var(--dial); font-size:11px; letter-spacing:0.3px;
        color:var(--ink); border:1px solid var(--ring);
      }
      .pomo-meta{ display:flex; flex-direction:column; line-height:1.15 }
      .pomo-mode{ font-size:11px; color:var(--muted) }
      .pomo-controls{ display:flex; gap:6px }
      .pomo-btn{
        background:var(--chip); color:var(--ink); border:1px solid var(--ring);
        border-radius:10px; padding:4px 8px; font-size:12px; cursor:pointer;
      }

      /* Print to PDF: keep only the script */
      @media print{
        .topbar, .layout .panel:first-child, .layout .panel:last-child, #focusHud{ display:none !important; }
        .layout{ grid-template-columns: 1fr; }
        .editor-area{ max-width: 70ch; margin:0 auto; }
        body{ background:#fff; color:#000; }
        .panel{ border:none }
      }
    </style>
    <div class="app">
      <div class="topbar">
        <h1 id="title">Untitled Project</h1>
        <span class="counter" id="counter">0 pages • 0 words</span>
        <div class="spacer"></div>

        <!-- non-essential buttons collapse in focus mode -->
        <div class="topbar-group non-essential" role="group" aria-label="Quick panel toggles">
          <button class="btn" type="button" id="timelineModeBtn">Timeline</button>
        </div>

        <div class="btn-menu non-essential" id="exportMenu">
          <button class="btn" type="button" id="exportMenuButton" aria-haspopup="true" aria-expanded="false">Export ▾</button>
          <div class="btn-menu-list" id="exportMenuList" role="menu">
            <button type="button" data-export-action="fountain" role="menuitem">Fountain (.fountain)</button>
            <button type="button" data-export-action="pdf" role="menuitem">PDF</button>
          </div>
        </div>

        <button class="btn non-essential" onclick="backupNow()">Backup Now</button>
        <button class="btn non-essential" onclick="openRestore()">Restore…</button>

        <!-- Focus toggle -->
        <button class="btn" id="focusBtn" onclick="toggleFocus()">Focus</button>
      </div>

      <div class="layout">
        <div class="panel">
          <h2 style="display:flex;align-items:center;justify-content:space-between;margin-right:8px">
            Scenes
            <button class="btn" style="padding:4px 8px" onclick="addScene()">+ Scene</button>
          </h2>
          <div id="sceneList" class="scenes"></div>
        </div>

        <div class="panel editor">
          <h2>Script</h2>
          <div id="editor" class="editor-area" contenteditable="true"></div>
        </div>

        <div class="panel">
          <div class="tab-header" id="rightTabBar">
            <button class="tab-btn" data-tab-btn="write">Script</button>
            <button class="tab-btn" data-tab-btn="characters">Characters</button>
            <button class="tab-btn" data-tab-btn="set">Set</button>
            <button class="tab-btn" data-tab-btn="sound">Sound</button>
            <button class="tab-btn" data-tab-btn="timeline">Timeline</button>
            <button class="tab-btn" data-tab-btn="stats">Stats</button>
          </div>
          <div class="tab-panels">
            <div class="tab-panel" data-tab="write" id="tabWrite">
              <div>
                <h3>Scene Slug</h3>
                <div class="tab-chip-group">
                  <button class="tab-chip" data-slug-prefix="INT.">INT</button>
                  <button class="tab-chip" data-slug-prefix="EXT.">EXT</button>
                  <button class="tab-chip" data-slug-prefix="INT-EXT.">INT-EXT</button>
                </div>
                <div class="tab-chip-group">
                  <button class="tab-chip" data-slug-suffix="DAY">DAY</button>
                  <button class="tab-chip" data-slug-suffix="NIGHT">NIGHT</button>
                </div>
              </div>
              <div class="tab-divider"></div>
              <div>
                <h3>Insert Line</h3>
                <div class="tab-chip-group">
                  <button class="tab-chip" data-line-type="slug">Slug</button>
                  <button class="tab-chip" data-line-type="action">Action</button>
                  <button class="tab-chip" data-line-type="character">Character</button>
                  <button class="tab-chip" data-line-type="parenthetical">Parenthetical</button>
                  <button class="tab-chip" data-line-type="dialogue">Dialogue</button>
                  <button class="tab-chip" data-line-type="transition">Transition</button>
                </div>
              </div>
              <div class="tab-divider"></div>
              <div>
                <button class="danger-btn" id="deleteSceneBtn">Delete Scene</button>
              </div>
            </div>
            <div class="tab-panel" data-tab="characters" id="tabCharacters">
              <div>
                <h3>Characters</h3>
                <div class="catalog-list" id="characterList"></div>
              </div>
              <div class="row">
                <input id="newCharacterName" placeholder="Add character" />
                <button class="btn" id="addCharacterBtn">Add</button>
              </div>
              <p class="muted-text">Tap a name to insert it as a CHARACTER line.</p>
            </div>
            <div class="tab-panel" data-tab="set" id="tabSet">
              <div>
                <h3>Locations</h3>
                <div class="catalog-list" id="setList"></div>
              </div>
              <div class="row">
                <input id="newSetName" placeholder="Add location" />
                <button class="btn" id="addSetBtn">Add</button>
              </div>
            </div>
            <div class="tab-panel" data-tab="sound" id="tabSound">
              <div>
                <h3>Sound Cues</h3>
                <div class="sound-list" id="soundList"></div>
              </div>
              <div class="row">
                <input id="newSoundCue" placeholder="Add sound cue" />
                <button class="btn" id="addSoundBtn">Add</button>
              </div>
            </div>
            <div class="tab-panel" data-tab="timeline" id="tabTimeline">
              <h3>Timeline</h3>
              <p class="muted-text" style="margin:0 0 8px">Open timeline mode for a card view of your scenes.</p>
              <div class="timeline-list" id="timelineList"></div>
            </div>
            <div class="tab-panel" data-tab="stats" id="tabStats">
              <h3>Stats</h3>
              <div class="stats-grid">
                <div class="stat-card">
                  <span class="stat-value" id="statSceneCount">0</span>
                  <span class="stat-label">Scenes</span>
                </div>
                <div class="stat-card">
                  <span class="stat-value" id="statPageCount">0</span>
                  <span class="stat-label">Pages</span>
                </div>
                <div class="stat-card">
                  <span class="stat-value" id="statWordCount">0</span>
                  <span class="stat-label">Words</span>
                </div>
                <div class="stat-card">
                  <span class="stat-value" id="statLineCount">0</span>
                  <span class="stat-label">Lines</span>
                </div>
              </div>
            </div>
          </div>
          <div class="panel-footer">
            <h2>Notes &amp; Meta</h2>
            <div class="notes">
              <input id="projectTitle" placeholder="Project Title" />
              <textarea id="projectNotes" rows="8" placeholder="Project notes"></textarea>
              <div class="row">
                <input id="sceneSlug" placeholder="Scene Heading (Slug)" />
                <input id="sceneColor" type="color" />
              </div>
              <div class="row">
                <select id="smartFormat">
                  <option value="true">Smart format: ON</option>
                  <option value="false">Smart format: OFF</option>
                </select>
                <select id="themeSel" data-theme-select>
                  <option value="dark">Theme: Dark</option>
                  <option value="light">Theme: Light</option>
                </select>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Minimal HUD for focus mode -->
    <div id="focusHud">
      <span class="hud-text" id="hudCounter">0 pages • 0 words</span>
      <select id="hudScenePicker" onchange="pickSceneFromHud(this.value)"></select>

      <div class="pomo-chip">
        <div class="pomo-ring"><div class="pomo-dial" id="pomoTime">25:00</div></div>
        <div class="pomo-meta">
          <div class="pomo-mode" id="pomoMode">Work</div>
          <div class="pomo-controls">
            <button class="pomo-btn" id="pomoToggle" onclick="togglePomodoro()">Start</button>
            <button class="pomo-btn" onclick="resetPomodoro()">Reset</button>
          </div>
        </div>
      </div>

      <button onclick="addScene()">+ Scene</button>
      <button onclick="toggleFocus()">Exit Focus</button>
    </div>

    <div id="timelineOverlay" aria-hidden="true">
      <div class="timeline-window" role="dialog" aria-modal="true" aria-labelledby="timelineOverlayTitle">
        <div class="timeline-overlay-header">
          <div>
            <h2 id="timelineOverlayTitle">Timeline</h2>
            <p class="muted-text">Rearrange scenes, add new beats, and preview the flow of your story.</p>
          </div>
          <button class="timeline-close-btn" type="button" id="timelineOverlayClose">Close ✕</button>
        </div>
        <div class="timeline-overlay-body">
          <div class="timeline-prompt">What happens next? Drag cards to reorder scenes or click + to drop a new moment anywhere.</div>
          <div class="timeline-board-wrapper">
            <div class="timeline-board" id="timelineBoard"></div>
          </div>
        </div>
        <div class="timeline-overlay-footer">
          <div class="timeline-composer">
            <label for="timelineNewSceneTitle">New scene prompt</label>
            <input id="timelineNewSceneTitle" placeholder="Scene heading (e.g. INT. OFFICE - DAY)" />
            <textarea id="timelineNewSceneSummary" placeholder="What happens in this scene?"></textarea>
          </div>
          <div class="timeline-composer-actions">
            <span class="timeline-position-label" id="timelinePositionLabel">Will insert at the end.</span>
            <button class="timeline-save-btn" type="button" id="timelineAddSceneBtn">Add Scene</button>
          </div>
        </div>
        <div id="timelinePreview">
          <div class="timeline-preview-card" role="document">
            <div class="timeline-preview-header">
              <h3 id="timelinePreviewTitle">Scene Title</h3>
              <div class="timeline-preview-meta" id="timelinePreviewMeta"></div>
            </div>
            <div class="timeline-preview-body" id="timelinePreviewBody"></div>
            <div class="timeline-preview-actions">
              <button class="timeline-secondary-btn" type="button" id="timelinePreviewClose">Close</button>
              <button class="timeline-save-btn" type="button" id="timelinePreviewOpen">Open in Writer</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
    function syncNavHeight(){
      const nav = document.querySelector('.nav');
      if (!nav) return;
      const rect = nav.getBoundingClientRect();
      const height = Math.max(0, Math.round(rect.height));
      document.documentElement.style.setProperty('--nav-height', `${height}px`);
    }
    syncNavHeight();
    window.addEventListener('resize', syncNavHeight);

    /* =========================
     * IndexedDB minimal wrapper
     * =======================*/
    const DB_NAME = 'sw_db_v1';
    const STORE = 'projects';
    let db;

    function openDB(){
      return new Promise((resolve, reject)=>{
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = e => {
          const idb = e.target.result;
          if(!idb.objectStoreNames.contains(STORE)){
            idb.createObjectStore(STORE, { keyPath: 'projectId' });
          }
        };
        req.onsuccess = e => { db = e.target.result; resolve(); };
        req.onerror = e => reject(e);
      });
    }
    function saveLocal(project){
      return new Promise((resolve,reject)=>{
        const tx = db.transaction([STORE],'readwrite');
        tx.objectStore(STORE).put(project);
        tx.oncomplete = resolve;
        tx.onerror = reject;
      });
    }
    function loadLocal(projectId){
      return new Promise((resolve,reject)=>{
        const tx = db.transaction([STORE],'readonly');
        const req = tx.objectStore(STORE).get(projectId);
        req.onsuccess = ()=> resolve(req.result || null);
        req.onerror = reject;
      });
    }

    /* =========================
     * State & Config
     * =======================*/
    let project = null;
    let activeSceneId = null;
    let saveTimer = null;
    let timelineMode = false;
    let timelineInsertIndex = 0;
    let timelineDragSceneId = null;
    let timelinePendingPreviewId = null;
    let timelineSuppressClick = false;

    const BACKUP_IDLE_MS = 120000;   // 2 min idle → auto backup
    const FULL_SNAPSHOT_EVERY = 10;  // every 10 deltas
    const MAX_DELTA_BYTES = 128 * 1024;

    let backupTimer = null;
    let lastSerializedMetaHash = '';
    let supabaseSession = null;
    let supabaseSessionBound = false;

    function bindSupabaseSessionClient(client){
      if (!client || supabaseSessionBound) return;
      supabaseSessionBound = true;
      client.auth.getSession().then(({ data, error }) => {
        if (error) {
          console.warn('Supabase session fetch failed:', error);
          return;
        }
        supabaseSession = data?.session || null;
      });
      client.auth.onAuthStateChange((_event, session) => {
        supabaseSession = session;
      });
    }

    if (window.supabaseClient) bindSupabaseSessionClient(window.supabaseClient);
    window.addEventListener('auth:ready', e => {
      if (supabaseSessionBound && supabaseSession) return;
      bindSupabaseSessionClient(e.detail?.supabase);
    });

    async function getSupabaseSession(client){
      if (!client) return null;
      if (supabaseSession && supabaseSession.user) return supabaseSession;
      const { data, error } = await client.auth.getSession();
      if (error) throw error;
      supabaseSession = data?.session || null;
      return supabaseSession;
    }

    const RIGHT_TAB_KEY = 'SW_RIGHT_TAB';
    let activeRightTab = (()=>{
      try { return localStorage.getItem(RIGHT_TAB_KEY) || 'write'; }
      catch(e){ return 'write'; }
    })();

    /* =========================
     * Hashing (FNV-1a) & helpers
     * =======================*/
    function hashString(str) {
      let h = 2166136261 >>> 0;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return (h >>> 0).toString(16);
    }
    function stableSceneString(s){
      return JSON.stringify({
        id: s.id, slug: s.slug,
        elements: s.elements, color: s.color, notes: s.notes,
        sounds: s.sounds
      });
    }
    function metaSignature(p){
      return JSON.stringify({ title:p.title, notes:p.notes, settings:p.settings });
    }

    function ensureProjectShape(){
      project.settings = project.settings || {};
      if (!project.settings.theme){
        const globalTheme = (typeof window.getSiteTheme === 'function') ? window.getSiteTheme() : (document.documentElement.dataset.theme || 'dark');
        project.settings.theme = globalTheme || 'dark';
      }
      project.catalogs = project.catalogs || {};
      project.catalogs.characters = (project.catalogs.characters || []).map(item => {
        if (typeof item === 'string') return { id: crypto.randomUUID(), name: item };
        if (!item || typeof item !== 'object') return { id: crypto.randomUUID(), name: '' };
        if (!item.id) item.id = crypto.randomUUID();
        item.name = typeof item.name === 'string' ? item.name : '';
        return item;
      });
      project.catalogs.locations = (project.catalogs.locations || []).map(item => {
        if (typeof item === 'string') return { id: crypto.randomUUID(), name: item };
        if (!item || typeof item !== 'object') return { id: crypto.randomUUID(), name: '' };
        if (!item.id) item.id = crypto.randomUUID();
        item.name = typeof item.name === 'string' ? item.name : '';
        return item;
      });
      project.scenes = (project.scenes || []).map(scene => {
        if (!Array.isArray(scene.cards)) scene.cards = [];
        if (!Array.isArray(scene.elements)) scene.elements = [];
        scene.sounds = (scene.sounds || []).map(sound => {
          if (typeof sound === 'string') return { id: crypto.randomUUID(), cue: sound };
          if (!sound || typeof sound !== 'object') return { id: crypto.randomUUID(), cue: '' };
          if (!sound.id) sound.id = crypto.randomUUID();
          sound.cue = typeof sound.cue === 'string' ? sound.cue : '';
          return sound;
        });
        return scene;
      });
    }

    function setRightTab(tab){
      const allowed = ['write','characters','set','sound','timeline','stats'];
      activeRightTab = allowed.includes(tab) ? tab : 'write';
      try { localStorage.setItem(RIGHT_TAB_KEY, activeRightTab); } catch(e){}
      applyActiveTabUI();
    }

    function applyActiveTabUI(){
      const allowed = ['write','characters','set','sound','timeline','stats'];
      if (!allowed.includes(activeRightTab)) activeRightTab = 'write';
      document.querySelectorAll('[data-tab-btn]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tabBtn === activeRightTab);
      });
      document.querySelectorAll('.tab-panel').forEach(panel => {
        panel.classList.toggle('active', panel.dataset.tab === activeRightTab);
      });
    }

    function setupExportMenu(){
      const menu = document.getElementById('exportMenu');
      const toggle = document.getElementById('exportMenuButton');
      if (!menu || !toggle) return;
      const list = document.getElementById('exportMenuList');
      if (!list) return;

      const setOpen = (open)=>{
        menu.classList.toggle('open', open);
        toggle.setAttribute('aria-expanded', open ? 'true' : 'false');
      };

      toggle.addEventListener('click', e=>{
        e.stopPropagation();
        setOpen(!menu.classList.contains('open'));
      });

      menu.querySelectorAll('[data-export-action]').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const action = btn.dataset.exportAction;
          setOpen(false);
          if (action === 'fountain') exportFountain();
          else if (action === 'pdf') printPDF();
        });
      });

      document.addEventListener('click', e=>{
        if (!menu.contains(e.target)) setOpen(false);
      });

      document.addEventListener('keydown', e=>{
        if (e.key === 'Escape') setOpen(false);
      });
    }

    /* =========================
     * Project creation / load
     * =======================*/
    function getLastProjectId(){ try { return localStorage.getItem('SW_LAST_PROJECT_ID'); } catch(e){ return null; } }
    function setLastProjectId(id){ try { localStorage.setItem('SW_LAST_PROJECT_ID', id); } catch(e){} }

    function newProject(){
      const pid = crypto.randomUUID();
      project = {
        projectId: pid,
        title: 'Untitled Project',
        format: 'screenplay/v1',
        createdAt: Date.now(),
        updatedAt: Date.now(),
        version: 1,
        settings: { theme: (typeof window.getSiteTheme === 'function' ? window.getSiteTheme() : (document.documentElement.dataset.theme || 'dark')), smartFormat:true, pageWidth:60, focus:false, pomodoro: undefined },
        catalogs: { characters:[], locations:[] },
        scenes: [{
          id: crypto.randomUUID(),
          slug: 'INT. HOUSE - DAY',
          cards: ['Opening image'],
          elements: [{t:'action', txt:'A room. Quiet.'}],
          color: '#5FA8FF',
          notes: '',
          sounds: []
        }],
        notes: '',
        _hashes: { scene: {} },
        _lastBackedUpVersion: 0,
        _deltaCountSinceFull: 0
      };
      project.scenes.forEach(s => { project._hashes.scene[s.id] = hashString(stableSceneString(s)); });
      activeSceneId = project.scenes[0].id;
      setLastProjectId(pid);
    }

    /* =========================
     * Rendering & UI
     * =======================*/
    function render(){
      ensureProjectShape();
      document.getElementById('title').textContent = project.title || 'Untitled Project';
      document.getElementById('projectTitle').value = project.title || '';
      document.getElementById('projectNotes').value = project.notes || '';
      const smartSel = document.getElementById('smartFormat');
      if (smartSel) smartSel.value = String(!!project.settings.smartFormat);
      project.settings.theme = project.settings.theme || (typeof window.getSiteTheme === 'function' ? window.getSiteTheme() : (document.documentElement.dataset.theme || 'dark'));
      const themeSel = document.getElementById('themeSel');
      if (themeSel) themeSel.value = project.settings.theme;

      // scenes list
      const list = document.getElementById('sceneList');
      list.innerHTML = '';
      project.scenes.forEach((s, idx)=>{
        const div = document.createElement('div');
        div.className = 'scene-card' + (s.id===activeSceneId ? ' active':'');
        div.onclick = ()=>{ activeSceneId = s.id; render(); };
        div.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
            <div>
              <strong>${escapeHtml(s.slug || '(no slug)')}</strong><br/>
              <small>Scene ${idx+1}</small>
            </div>
            <span title="Color" style="width:12px;height:12px;border-radius:50%;background:${s.color||'#5FA8FF'}"></span>
          </div>`;
        list.appendChild(div);
      });

      // right-side bindings
      const scene = getActiveScene();
      if (!scene){
        document.getElementById('editor').innerHTML = '';
        updateCounters();
        updateHud();
        updatePomodoroUI();
        applyTheme();
      renderCatalogs();
      renderSoundList();
      renderTimeline();
      updateDeleteSceneButton();
      applyActiveTabUI();
      if (timelineMode) renderTimelineBoard();
      else updateTimelineInsertLabel();
      updateTimelineButton();
      return;
    }
      if (!Array.isArray(scene.sounds)) scene.sounds = [];
      document.getElementById('sceneSlug').value = scene.slug || '';
      document.getElementById('sceneColor').value = scene.color || '#5FA8FF';

      // editor render
      const editor = document.getElementById('editor');
      editor.innerHTML = scene.elements.map(el=>{
        return `<div class="line ${el.t}" data-t="${el.t}">${escapeHtml(el.txt)}</div>`;
      }).join('');
      normalizeEditorLines(); // ensure structure

      updateCounters();
      updateHud();
      updatePomodoroUI();
      applyTheme();
      renderCatalogs();
      renderSoundList();
      renderTimeline();
      updateDeleteSceneButton();
      applyActiveTabUI();
      if (timelineMode) renderTimelineBoard();
      else updateTimelineInsertLabel();
      updateTimelineButton();
    }

    /* Keep child nodes as .line blocks */
    function normalizeEditorLines(){
      const editor = document.getElementById('editor');
      const children = Array.from(editor.childNodes);
      const normalized = [];
      let changed = false;

      for (let n of children){
        if (n.nodeType === 3){ // text node
          const div = document.createElement('div');
          div.className = 'line action';
          div.dataset.t = 'action';
          div.textContent = (n.textContent || '').trim();
          normalized.push(div);
          changed = true;
        } else if (n.nodeType === 1){ // element
          if (n.classList.contains('line')) {
            if (!n.dataset.t) n.dataset.t = 'action';
            normalized.push(n);
          } else if (n.tagName === 'BR') {
            const div = document.createElement('div');
            div.className = 'line action';
            div.dataset.t = 'action';
            div.textContent = '';
            normalized.push(div);
            changed = true;
          } else {
            const div = document.createElement('div');
            div.className = 'line action';
            div.dataset.t = 'action';
            div.textContent = n.textContent || '';
            normalized.push(div);
            changed = true;
          }
        }
      }

      if (!changed && normalized.length === children.length) return;

      editor.innerHTML = '';
      normalized.forEach(d=>editor.appendChild(d));
    }

    function syncActiveScene(autoDetect = true){
      const scene = getActiveScene();
      if (!scene) return;
      project.settings = project.settings || {};
      normalizeEditorLines();
      if (autoDetect && project.settings.smartFormat) autoDetectTypes();
      const nodes = Array.from(document.querySelectorAll('#editor .line'));
      scene.elements = nodes.map(n=>({ t:n.dataset.t || 'action', txt:n.textContent }));
      updateSceneHash(scene);
      bumpVersion();
      updateCounters();
      scheduleSave();
      scheduleBackup();
    }

    function renderCatalogs(){
      const charContainer = document.getElementById('characterList');
      if (charContainer){
        charContainer.innerHTML = '';
        if (!project.catalogs.characters.length){
          const empty = document.createElement('p');
          empty.className = 'muted-text';
          empty.textContent = 'No characters yet.';
          charContainer.appendChild(empty);
        } else {
          project.catalogs.characters.forEach(char => {
            const row = document.createElement('div');
            row.className = 'catalog-item';
            const name = document.createElement('span');
            name.textContent = char.name || '';
            const actions = document.createElement('div');
            actions.className = 'catalog-actions';
            const insertBtn = document.createElement('button');
            insertBtn.textContent = 'Insert';
            insertBtn.addEventListener('click', ()=>{
              insertLine('character', char.name || '');
              setRightTab('write');
            });
            const delBtn = document.createElement('button');
            delBtn.textContent = 'Delete';
            delBtn.addEventListener('click', ()=>{
              removeCharacter(char.id);
            });
            actions.appendChild(insertBtn);
            actions.appendChild(delBtn);
            row.appendChild(name);
            row.appendChild(actions);
            charContainer.appendChild(row);
          });
        }
      }

      const setContainer = document.getElementById('setList');
      if (setContainer){
        setContainer.innerHTML = '';
        if (!project.catalogs.locations.length){
          const empty = document.createElement('p');
          empty.className = 'muted-text';
          empty.textContent = 'No locations yet.';
          setContainer.appendChild(empty);
        } else {
          project.catalogs.locations.forEach(loc => {
            const row = document.createElement('div');
            row.className = 'catalog-item';
            const name = document.createElement('span');
            name.textContent = loc.name || '';
            const actions = document.createElement('div');
            actions.className = 'catalog-actions';
            const delBtn = document.createElement('button');
            delBtn.textContent = 'Delete';
            delBtn.addEventListener('click', ()=>{
              removeLocation(loc.id);
            });
            actions.appendChild(delBtn);
            row.appendChild(name);
            row.appendChild(actions);
            setContainer.appendChild(row);
          });
        }
      }
    }

    function renderSoundList(){
      const container = document.getElementById('soundList');
      if (!container) return;
      container.innerHTML = '';
      const scene = getActiveScene();
      if (!scene){
        const empty = document.createElement('p');
        empty.className = 'muted-text';
        empty.textContent = 'No scene selected.';
        container.appendChild(empty);
        return;
      }
      if (!scene.sounds.length){
        const empty = document.createElement('p');
        empty.className = 'muted-text';
        empty.textContent = 'No sound cues yet.';
        container.appendChild(empty);
        return;
      }
      scene.sounds.forEach(sound => {
        const row = document.createElement('div');
        row.className = 'sound-item';
        const label = document.createElement('span');
        label.textContent = sound.cue || '';
        const btn = document.createElement('button');
        btn.textContent = 'Delete';
        btn.addEventListener('click', ()=> removeSoundCue(sound.id));
        row.appendChild(label);
        row.appendChild(btn);
        container.appendChild(row);
      });
    }

    function renderTimeline(){
      const list = document.getElementById('timelineList');
      if (!list) return;
      list.innerHTML = '';
      const openBtn = document.createElement('button');
      openBtn.type = 'button';
      openBtn.className = 'timeline-item';
      openBtn.innerHTML = `
        <div class="timeline-bullet">↗</div>
        <div class="timeline-body">
          <strong>Open Timeline Mode</strong>
          <span class="timeline-meta">Card view with drag & drop reordering</span>
        </div>`;
      openBtn.addEventListener('click', ()=> openTimelineMode());
      list.appendChild(openBtn);
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      if (!scenes.length){
        const empty = document.createElement('p');
        empty.className = 'timeline-empty';
        empty.textContent = 'No scenes yet.';
        list.appendChild(empty);
        return;
      }
      scenes.forEach((scene, idx)=>{
        const item = document.createElement('button');
        item.type = 'button';
        item.className = 'timeline-item' + (scene.id === activeSceneId ? ' active' : '');
        const beats = Array.isArray(scene.cards) ? scene.cards.length : 0;
        const snippet = getSceneSnippet(scene);
        const metaParts = [];
        metaParts.push(`Scene ${idx + 1}`);
        metaParts.push(beats ? `${beats} beat${beats === 1 ? '' : 's'}` : 'No beats tagged');
        if (snippet) metaParts.push(snippet);
        const metaText = metaParts.join(' • ');
        item.innerHTML = `
          <div class="timeline-bullet">${idx + 1}</div>
          <div class="timeline-body">
            <strong>${escapeHtml(scene.slug || '(no slug)')}</strong>
            <span class="timeline-meta">${escapeHtml(metaText)}</span>
          </div>`;
        item.addEventListener('click', ()=>{
          openTimelineMode(scene.id);
        });
        list.appendChild(item);
      });
    }

    function getSceneSnippet(scene){
      if (!scene || !Array.isArray(scene.elements)) return '';
      const text = scene.elements.map(el => (el?.txt || '')).join(' ');
      const clean = text.replace(/\s+/g, ' ').trim();
      if (!clean) return '';
      return clean.length > 160 ? `${clean.slice(0, 157)}…` : clean;
    }

    function renderTimelineBoard(){
      const board = document.getElementById('timelineBoard');
      if (!board) return;
      board.innerHTML = '';
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      if (!scenes.length){
        const empty = document.createElement('p');
        empty.className = 'timeline-empty';
        empty.textContent = 'No scenes yet.';
        board.appendChild(empty);
        timelineInsertIndex = 0;
        updateTimelineInsertLabel();
        return;
      }
      timelineInsertIndex = Math.max(0, Math.min(timelineInsertIndex, scenes.length));
      board.appendChild(createTimelineDropZone(0));
      scenes.forEach((scene, idx)=>{
        board.appendChild(createTimelineCard(scene, idx));
        board.appendChild(createTimelineDropZone(idx + 1));
      });
      board.querySelectorAll('.timeline-dropzone').forEach(zone=>{
        zone.classList.toggle('over', parseInt(zone.dataset.index || '0', 10) === timelineInsertIndex);
      });
      updateTimelineInsertLabel();
      if (timelinePendingPreviewId){
        const target = timelinePendingPreviewId;
        timelinePendingPreviewId = null;
        requestAnimationFrame(()=> openTimelinePreview(target));
      }
    }

    function createTimelineCard(scene, idx){
      const card = document.createElement('div');
      card.className = 'timeline-card' + (scene.id === activeSceneId ? ' active' : '');
      card.dataset.sceneId = scene.id;
      card.draggable = true;
      const beats = Array.isArray(scene.cards) ? scene.cards.length : 0;
      const snippet = getSceneSnippet(scene) || 'Tap to add more detail.';
      const beatsLabel = beats ? `${beats} beat${beats === 1 ? '' : 's'}` : 'No beats yet';
      card.innerHTML = `
        <small>${escapeHtml(`Scene ${idx + 1}`)}</small>
        <h4>${escapeHtml(scene.slug || '(no slug)')}</h4>
        <p class="timeline-card-snippet">${escapeHtml(snippet)}</p>
        <div class="timeline-card-actions">
          <span>${escapeHtml(beatsLabel)}</span>
          <span style="width:12px;height:12px;border-radius:50%;background:${scene.color || '#5FA8FF'}"></span>
        </div>`;
      card.addEventListener('click', ()=>{
        if (timelineSuppressClick) return;
        openTimelinePreview(scene.id, card);
      });
      card.addEventListener('dragstart', (e)=>{
        timelineDragSceneId = scene.id;
        timelineSuppressClick = true;
        card.classList.add('dragging');
        if (e.dataTransfer){
          e.dataTransfer.effectAllowed = 'move';
          try { e.dataTransfer.setData('text/plain', scene.id); } catch(err){}
        }
      });
      card.addEventListener('dragend', ()=>{
        timelineDragSceneId = null;
        card.classList.remove('dragging');
        setTimeout(()=>{ timelineSuppressClick = false; }, 0);
        document.querySelectorAll('.timeline-dropzone.over').forEach(z=>z.classList.remove('over'));
      });
      return card;
    }

    function createTimelineDropZone(index){
      const zone = document.createElement('div');
      zone.className = 'timeline-dropzone';
      zone.dataset.index = index;
      zone.addEventListener('dragover', (e)=>{
        if (!timelineDragSceneId) return;
        e.preventDefault();
        zone.classList.add('over');
        if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
      });
      zone.addEventListener('dragleave', ()=> zone.classList.remove('over'));
      zone.addEventListener('drop', (e)=>{
        if (!timelineDragSceneId) return;
        e.preventDefault();
        zone.classList.remove('over');
        const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
        const fromIdx = scenes.findIndex(s=>s.id === timelineDragSceneId);
        let target = parseInt(zone.dataset.index || '0', 10);
        if (Number.isNaN(target) || fromIdx < 0) return;
        if (fromIdx < target) target = target - 1;
        target = Math.max(0, Math.min(target, scenes.length - 1));
        const preview = document.getElementById('timelinePreview');
        const openSceneId = preview?.dataset?.sceneId || null;
        if (openSceneId) timelinePendingPreviewId = openSceneId;
        moveScene(fromIdx, target);
      });
      const addBtn = document.createElement('button');
      addBtn.type = 'button';
      addBtn.className = 'timeline-add-btn';
      addBtn.innerHTML = '<span aria-hidden="true">＋</span> Add Scene';
      addBtn.addEventListener('click', ()=>{
        prepareTimelineComposer(index);
      });
      zone.appendChild(addBtn);
      return zone;
    }

    function prepareTimelineComposer(index){
      timelineInsertIndex = Math.max(0, Math.min(index, Array.isArray(project?.scenes) ? project.scenes.length : 0));
      updateTimelineInsertLabel();
      document.querySelectorAll('.timeline-dropzone').forEach(zone=>{
        zone.classList.toggle('over', parseInt(zone.dataset.index || '0', 10) === timelineInsertIndex);
      });
      const input = document.getElementById('timelineNewSceneTitle');
      if (input){
        requestAnimationFrame(()=> input.focus());
      }
    }

    function updateTimelineInsertLabel(){
      const label = document.getElementById('timelinePositionLabel');
      if (!label) return;
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      const total = scenes.length;
      const idx = Math.max(0, Math.min(timelineInsertIndex, total));
      let text = 'Will insert at the end.';
      if (!total){
        text = 'This will become the first scene.';
      } else if (idx === 0){
        text = 'Will insert before Scene 1.';
      } else if (idx >= total){
        text = `Will insert after Scene ${total}.`;
      } else {
        text = `Will insert between Scene ${idx} and Scene ${idx + 1}.`;
      }
      label.textContent = text;
    }

    function handleTimelineAddScene(){
      const title = document.getElementById('timelineNewSceneTitle');
      const summary = document.getElementById('timelineNewSceneSummary');
      if (!title || !summary) return;
      const insertAt = Math.max(0, Math.min(timelineInsertIndex, Array.isArray(project?.scenes) ? project.scenes.length : 0));
      const scene = buildDefaultScene(title.value, summary.value);
      timelinePendingPreviewId = scene.id;
      timelineInsertIndex = insertAt + 1;
      title.value = '';
      summary.value = '';
      insertSceneAt(insertAt, scene);
      updateTimelineInsertLabel();
      requestAnimationFrame(()=>{
        const inputAgain = document.getElementById('timelineNewSceneTitle');
        if (inputAgain) inputAgain.focus();
      });
    }

    function moveScene(fromIdx, toIdx){
      if (fromIdx === toIdx) return;
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      if (fromIdx < 0 || fromIdx >= scenes.length) return;
      toIdx = Math.max(0, Math.min(toIdx, scenes.length - 1));
      const [scene] = scenes.splice(fromIdx, 1);
      scenes.splice(toIdx, 0, scene);
      timelineInsertIndex = toIdx + 1;
      const preview = document.getElementById('timelinePreview');
      const openSceneId = preview?.dataset?.sceneId || null;
      if (openSceneId) timelinePendingPreviewId = openSceneId;
      bumpVersion();
      scheduleSave();
      scheduleBackup();
      render();
    }

    function openTimelinePreview(sceneId, anchorEl){
      if (!sceneId) return;
      if (!timelineMode) openTimelineMode(sceneId);
      const preview = document.getElementById('timelinePreview');
      const titleEl = document.getElementById('timelinePreviewTitle');
      const metaEl = document.getElementById('timelinePreviewMeta');
      const bodyEl = document.getElementById('timelinePreviewBody');
      if (!preview || !titleEl || !metaEl || !bodyEl) return;
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      const scene = scenes.find(s=>s.id === sceneId);
      if (!scene) return;
      const idx = scenes.findIndex(s=>s.id === sceneId);
      const beats = Array.isArray(scene.cards) ? scene.cards.length : 0;
      const lineCount = Array.isArray(scene.elements) ? scene.elements.length : 0;
      const metaParts = [];
      if (idx >= 0) metaParts.push(`Scene ${idx + 1}`);
      if (beats) metaParts.push(`${beats} beat${beats === 1 ? '' : 's'}`);
      metaParts.push(`${lineCount} line${lineCount === 1 ? '' : 's'}`);
      titleEl.textContent = scene.slug || '(no slug)';
      metaEl.textContent = metaParts.join(' • ');
      bodyEl.innerHTML = (Array.isArray(scene.elements) ? scene.elements : [])
        .map(el => `<div class="line ${el.t}">${escapeHtml(el.txt || '')}</div>`)
        .join('') || '<div class="line action">...</div>';
      const openBtn = document.getElementById('timelinePreviewOpen');
      if (openBtn) openBtn.dataset.sceneId = scene.id;
      preview.dataset.sceneId = scene.id;
      const windowEl = document.querySelector('.timeline-window');
      const originEl = anchorEl || document.querySelector(`.timeline-card[data-scene-id="${scene.id}"]`);
      if (windowEl && originEl){
        const winRect = windowEl.getBoundingClientRect();
        const originRect = originEl.getBoundingClientRect();
        const originX = (originRect.left + originRect.width/2 - winRect.left) / winRect.width;
        const originY = (originRect.top + originRect.height/2 - winRect.top) / winRect.height;
        preview.style.setProperty('--origin-x', Math.min(Math.max(originX, 0), 1));
        preview.style.setProperty('--origin-y', Math.min(Math.max(originY, 0), 1));
      } else {
        preview.style.removeProperty('--origin-x');
        preview.style.removeProperty('--origin-y');
      }
      preview.classList.add('open');
      preview.setAttribute('aria-hidden', 'false');
    }

    function closeTimelinePreview(){
      const preview = document.getElementById('timelinePreview');
      if (!preview) return;
      preview.classList.remove('open');
      preview.setAttribute('aria-hidden', 'true');
      preview.removeAttribute('data-scene-id');
      const openBtn = document.getElementById('timelinePreviewOpen');
      if (openBtn) delete openBtn.dataset.sceneId;
    }

    function updateTimelineButton(){
      const btn = document.getElementById('timelineModeBtn');
      if (!btn) return;
      btn.textContent = timelineMode ? 'Exit Timeline' : 'Timeline';
      btn.setAttribute('aria-pressed', timelineMode ? 'true' : 'false');
    }

    function openTimelineMode(sceneId = null){
      timelineMode = true;
      document.body.classList.add('timeline-mode');
      const overlay = document.getElementById('timelineOverlay');
      if (overlay) overlay.setAttribute('aria-hidden', 'false');
      updateTimelineButton();
      syncNavHeight();
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      if (sceneId){
        const idx = scenes.findIndex(s=>s.id === sceneId);
        timelineInsertIndex = idx >= 0 ? idx + 1 : scenes.length;
        timelinePendingPreviewId = sceneId;
      } else {
        timelineInsertIndex = scenes.length;
        timelinePendingPreviewId = null;
      }
      renderTimelineBoard();
    }

    function closeTimelineMode(){
      timelineMode = false;
      document.body.classList.remove('timeline-mode');
      const overlay = document.getElementById('timelineOverlay');
      if (overlay) overlay.setAttribute('aria-hidden', 'true');
      closeTimelinePreview();
      updateTimelineButton();
      document.querySelectorAll('.timeline-dropzone.over').forEach(z=>z.classList.remove('over'));
      timelineSuppressClick = false;
    }

    function toggleTimelineMode(){
      if (timelineMode) closeTimelineMode();
      else openTimelineMode();
    }

    function updateDeleteSceneButton(){
      const btn = document.getElementById('deleteSceneBtn');
      if (btn) btn.disabled = project.scenes.length <= 1;
    }

    /* =========================
     * Catalog helpers
     * =======================*/
    function addCharacter(name){
      const trimmed = (name || '').trim();
      if (!trimmed) return;
      project.catalogs = project.catalogs || {};
      project.catalogs.characters = project.catalogs.characters || [];
      project.catalogs.characters.push({ id: crypto.randomUUID(), name: trimmed });
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
    }

    function removeCharacter(id){
      project.catalogs = project.catalogs || {};
      project.catalogs.characters = (project.catalogs.characters || []).filter(c=>c.id !== id);
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
    }

    function addLocation(name){
      const trimmed = (name || '').trim();
      if (!trimmed) return;
      project.catalogs = project.catalogs || {};
      project.catalogs.locations = project.catalogs.locations || [];
      project.catalogs.locations.push({ id: crypto.randomUUID(), name: trimmed });
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
    }

    function removeLocation(id){
      project.catalogs = project.catalogs || {};
      project.catalogs.locations = (project.catalogs.locations || []).filter(l=>l.id !== id);
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
    }

    function addSoundCue(text){
      const scene = getActiveScene();
      if (!scene) return;
      const trimmed = (text || '').trim();
      if (!trimmed) return;
      scene.sounds = scene.sounds || [];
      scene.sounds.push({ id: crypto.randomUUID(), cue: trimmed });
      updateSceneHash(scene);
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
    }

    function removeSoundCue(id){
      const scene = getActiveScene();
      if (!scene) return;
      scene.sounds = (scene.sounds || []).filter(s=>s.id !== id);
      updateSceneHash(scene);
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
    }

    function setSceneSlugPart(kind, value){
      const input = document.getElementById('sceneSlug');
      const scene = getActiveScene();
      if (!input || !scene) return;
      const upperValue = (value || '').toUpperCase();
      let slug = (input.value || scene.slug || '').toUpperCase();
      if (kind === 'prefix'){
        slug = slug.replace(/^(INT\.|EXT\.|INT-EXT\.|INT\/EXT\.)\s*/, '');
        slug = slug.replace(/^\s+/, '');
        slug = `${upperValue} ${slug}`.trim();
      } else if (kind === 'suffix'){
        slug = slug.replace(/\s*-\s*(DAY|NIGHT)$/i, '').trim();
        slug = slug ? `${slug} - ${upperValue}` : upperValue;
      }
      slug = slug.replace(/\s+/g, ' ').trim();
      input.value = slug;
      input.dispatchEvent(new Event('input', { bubbles: true }));
    }

    /* =========================
     * Scene helpers
     * =======================*/
    function getActiveScene(){ return project.scenes.find(s=>s.id===activeSceneId); }
    function buildDefaultScene(slug, summary){
      const trimmedSlug = typeof slug === 'string' ? slug.trim() : '';
      const trimmedSummary = typeof summary === 'string' ? summary.trim() : '';
      const scene = {
        id: crypto.randomUUID(),
        slug: trimmedSlug || 'EXT. NEW PLACE - DAY',
        cards: [],
        elements: [],
        color: '#8ab4f8',
        notes: '',
        sounds: []
      };
      if (trimmedSummary){
        scene.elements = trimmedSummary
          .split(/\n+/)
          .map(line => ({ t:'action', txt: line.trim() }))
          .filter(el => !!el.txt);
      }
      if (!scene.elements.length){
        scene.elements = [{t:'action', txt:'...'}];
      }
      return scene;
    }
    function insertSceneAt(index, scene){
      project.scenes = Array.isArray(project.scenes) ? project.scenes : [];
      project._hashes = project._hashes || { scene: {} };
      const clamped = Math.max(0, Math.min(index, project.scenes.length));
      project.scenes.splice(clamped, 0, scene);
      project._hashes.scene[scene.id] = hashString(stableSceneString(scene));
      activeSceneId = scene.id;
      bumpVersion();
      render();
      scheduleSave(); scheduleBackup();
    }
    function addScene(){
      const scene = buildDefaultScene();
      insertSceneAt(project.scenes.length, scene);
    }
    function deleteScene(id){
      const idx = project.scenes.findIndex(s=>s.id===id);
      if (idx >= 0) {
        project.scenes.splice(idx,1);
        delete project._hashes.scene[id];
        if (!project.scenes.length){
          addScene();
          return;
        }
        if (activeSceneId === id) activeSceneId = project.scenes[0]?.id || null;
        bumpVersion(); render(); scheduleSave(); scheduleBackup();
      }
    }
    function updateSceneHash(scene){
      project._hashes = project._hashes || { scene: {} };
      project._hashes.scene[scene.id] = hashString(stableSceneString(scene));
    }

    /* =========================
     * Counters & Utilities
     * =======================*/
    function updateCounters(){
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      const text = scenes.flatMap(s=>s.elements.map(e=>e.txt)).join(' ');
      const words = (text.match(/\b\w+\b/g)||[]).length;
      const lines = scenes.reduce((acc,s)=>acc + s.elements.length, 0);
      const pages = Math.max(1, Math.round(lines / 55));
      document.getElementById('counter').textContent = `${pages} pages • ${words} words`;
      const sceneCountEl = document.getElementById('statSceneCount');
      if (sceneCountEl) sceneCountEl.textContent = scenes.length;
      const pageEl = document.getElementById('statPageCount');
      if (pageEl) pageEl.textContent = pages;
      const wordEl = document.getElementById('statWordCount');
      if (wordEl) wordEl.textContent = words;
      const lineEl = document.getElementById('statLineCount');
      if (lineEl) lineEl.textContent = lines;
    }
    function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;' }[m])); }

    /* Theme */
    function applyTheme(){
      const fallback = (typeof window.getSiteTheme === 'function') ? window.getSiteTheme() : (document.documentElement.dataset.theme || 'dark');
      const theme = project.settings.theme || fallback || 'dark';
      project.settings.theme = theme;
      if (typeof window.setSiteTheme === 'function'){
        window.setSiteTheme(theme);
      } else {
        document.documentElement.dataset.theme = theme;
        document.documentElement.style.colorScheme = theme;
      }
    }

    /* =========================
     * Editor interactions
     * =======================*/
    const editorEl = document.getElementById('editor');

    function getActiveLineNode(){
      const sel = window.getSelection();
      if (!sel || !sel.anchorNode) return null;
      let n = sel.anchorNode.nodeType === 3 ? sel.anchorNode.parentElement : sel.anchorNode;
      return n?.closest?.('.line') || null;
    }
    function markActiveLine(){
      document.querySelectorAll('#editor .line.active').forEach(el=>el.classList.remove('active'));
      const line = getActiveLineNode();
      if (line) line.classList.add('active');
    }
    function centerActiveLine(){
      const editor = document.getElementById('editor');
      const line = getActiveLineNode();
      if (!editor || !line) return;
      const rect = line.getBoundingClientRect();
      const parentRect = editor.getBoundingClientRect();
      const lineMid = rect.top + rect.height/2;
      const parentMid = parentRect.top + parentRect.height/2;
      const delta = lineMid - parentMid;
      editor.scrollTop += delta;
    }

    function placeCaret(node){
      if (!node) return;
      const editor = document.getElementById('editor');
      if (editor) editor.focus();
      const range = document.createRange();
      range.selectNodeContents(node);
      range.collapse(false);
      const sel = window.getSelection();
      if (!sel) return;
      sel.removeAllRanges();
      sel.addRange(range);
    }

    function insertLine(type, preset=''){
      const editor = document.getElementById('editor');
      if (!editor) return;
      const node = document.createElement('div');
      node.className = 'line ' + type;
      node.dataset.t = type;
      let text = preset || '';
      if (type === 'character' && text) text = text.toUpperCase();
      if (text) node.textContent = text;
      else node.innerHTML = '<br>';
      const active = getActiveLineNode();
      if (active && active.parentElement === editor) active.after(node);
      else editor.appendChild(node);
      placeCaret(node);
      syncActiveScene(false);
      markActiveLine();
      if (document.body.classList.contains('focus-mode')) centerActiveLine();
    }

    document.getElementById('editor').addEventListener('input', ()=>{
      syncActiveScene();
      markActiveLine();
      if (document.body.classList.contains('focus-mode')) centerActiveLine();
    });

    document.getElementById('editor').addEventListener('keydown', (e)=>{
      if (e.key === 'Enter') {
        setTimeout(()=>{
          syncActiveScene();
          markActiveLine();
          if (document.body.classList.contains('focus-mode')) centerActiveLine();
        }, 0);
      }
    });

    document.getElementById('editor').addEventListener('click', ()=>{
      markActiveLine();
      if (document.body.classList.contains('focus-mode')) centerActiveLine();
    });

    /* Auto type-detection */
    function autoDetectTypes(){
      const nodes = Array.from(document.querySelectorAll('#editor .line'));
      nodes.forEach(n=>{
        const text = (n.textContent||'').trim();
        let t = n.dataset.t;
        if (/^(INT|EXT|INT\/EXT|INT-EXT)\./i.test(text)) t = 'slug';
        else if (/^[A-Z0-9 .'-]{2,}$/.test(text) && text.length < 40) t = 'character';
        else if (/^\(.+\)$/.test(text)) t = 'parenthetical';
        else if (/^(CUT TO:|FADE OUT\.?|FADE IN\.?|SMASH CUT:|DISSOLVE TO:)/i.test(text)) t = 'transition';
        else if (!t || ['slug','character','parenthetical','transition'].includes(t)) t = 'action';
        n.className = 'line ' + t;
        n.dataset.t = t;
      });
    }

    /* =========================
     * Notes + meta bindings
     * =======================*/
    document.querySelectorAll('[data-tab-btn]').forEach(btn=>{
      btn.addEventListener('click', ()=> setRightTab(btn.dataset.tabBtn));
    });
    setupExportMenu();
    document.querySelectorAll('[data-slug-prefix]').forEach(btn=>{
      btn.addEventListener('click', ()=> setSceneSlugPart('prefix', btn.dataset.slugPrefix));
    });
    document.querySelectorAll('[data-slug-suffix]').forEach(btn=>{
      btn.addEventListener('click', ()=> setSceneSlugPart('suffix', btn.dataset.slugSuffix));
    });
    document.querySelectorAll('[data-line-type]').forEach(btn=>{
      btn.addEventListener('click', ()=> insertLine(btn.dataset.lineType));
    });
    const deleteSceneBtn = document.getElementById('deleteSceneBtn');
    if (deleteSceneBtn){
      deleteSceneBtn.addEventListener('click', ()=>{
        if (project.scenes.length <= 1) return;
        const scene = getActiveScene();
        const ok = confirm(`Delete scene "${scene?.slug || 'Untitled Scene'}"?`);
        if (ok) deleteScene(activeSceneId);
      });
    }
    const addCharacterBtn = document.getElementById('addCharacterBtn');
    if (addCharacterBtn){
      addCharacterBtn.addEventListener('click', ()=>{
        const input = document.getElementById('newCharacterName');
        const value = input.value;
        addCharacter(value);
        const fresh = document.getElementById('newCharacterName');
        if (fresh){ fresh.value = ''; fresh.focus(); }
      });
    }
    const addSetBtn = document.getElementById('addSetBtn');
    if (addSetBtn){
      addSetBtn.addEventListener('click', ()=>{
        const input = document.getElementById('newSetName');
        const value = input.value;
        addLocation(value);
        const fresh = document.getElementById('newSetName');
        if (fresh){ fresh.value = ''; fresh.focus(); }
      });
    }
    const addSoundBtn = document.getElementById('addSoundBtn');
    if (addSoundBtn){
      addSoundBtn.addEventListener('click', ()=>{
        const input = document.getElementById('newSoundCue');
        const value = input.value;
        addSoundCue(value);
        const fresh = document.getElementById('newSoundCue');
        if (fresh){ fresh.value = ''; fresh.focus(); }
      });
    }
    const timelineBtn = document.getElementById('timelineModeBtn');
    if (timelineBtn){
      updateTimelineButton();
      timelineBtn.addEventListener('click', ()=> toggleTimelineMode());
    }
    const timelineOverlayEl = document.getElementById('timelineOverlay');
    if (timelineOverlayEl){
      timelineOverlayEl.addEventListener('click', (e)=>{
        if (e.target === timelineOverlayEl) closeTimelineMode();
      });
    }
    const timelineOverlayClose = document.getElementById('timelineOverlayClose');
    if (timelineOverlayClose){
      timelineOverlayClose.addEventListener('click', ()=> closeTimelineMode());
    }
    const timelineAddBtn = document.getElementById('timelineAddSceneBtn');
    if (timelineAddBtn){
      timelineAddBtn.addEventListener('click', ()=> handleTimelineAddScene());
    }
    const timelinePreviewCloseBtn = document.getElementById('timelinePreviewClose');
    if (timelinePreviewCloseBtn){
      timelinePreviewCloseBtn.addEventListener('click', ()=> closeTimelinePreview());
    }
    const timelinePreviewOpenBtn = document.getElementById('timelinePreviewOpen');
    if (timelinePreviewOpenBtn){
      timelinePreviewOpenBtn.addEventListener('click', ()=>{
        const sceneId = timelinePreviewOpenBtn.dataset.sceneId;
        if (!sceneId) return;
        activeSceneId = sceneId;
        setRightTab('write');
        closeTimelineMode();
        render();
      });
    }
    const timelinePreviewLayer = document.getElementById('timelinePreview');
    if (timelinePreviewLayer){
      timelinePreviewLayer.addEventListener('click', (e)=>{
        if (e.target === timelinePreviewLayer) closeTimelinePreview();
      });
    }

    applyActiveTabUI();

    document.getElementById('projectTitle').addEventListener('input', e=>{
      project.title = e.target.value;
      document.getElementById('title').textContent = project.title || 'Untitled Project';
      bumpVersion(); scheduleSave(); scheduleBackup();
    });
    document.getElementById('projectNotes').addEventListener('input', e=>{
      project.notes = e.target.value; bumpVersion(); scheduleSave(); scheduleBackup();
    });
    document.getElementById('sceneSlug').addEventListener('input', e=>{
      const s = getActiveScene(); if (!s) return;
      s.slug = e.target.value; bumpVersion(); updateSceneHash(s); render(); scheduleSave(); scheduleBackup();
    });
    document.getElementById('sceneColor').addEventListener('input', e=>{
      const s = getActiveScene(); if (!s) return;
      s.color = e.target.value; bumpVersion(); updateSceneHash(s); render(); scheduleSave(); scheduleBackup();
    });
    document.getElementById('smartFormat').addEventListener('change', e=>{
      project.settings.smartFormat = (e.target.value === 'true');
      bumpVersion(); scheduleSave();
    });
    document.getElementById('themeSel').addEventListener('change', e=>{
      project.settings.theme = e.target.value || 'dark';
      bumpVersion(); scheduleSave(); applyTheme();
    });

    document.addEventListener('themechange', e=>{
      const nextTheme = e.detail?.theme;
      if (!nextTheme || !project) return;
      if (project.settings.theme !== nextTheme){
        project.settings.theme = nextTheme;
        const sel = document.getElementById('themeSel');
        if (sel) sel.value = nextTheme;
        bumpVersion(); scheduleSave();
      } else {
        const sel = document.getElementById('themeSel');
        if (sel && sel.value !== nextTheme) sel.value = nextTheme;
      }
    });

    /* =========================
     * Export / Print
     * =======================*/
    function exportFountain(){
      let out = `Title: ${project.title||''}\n\n`;
      project.scenes.forEach(s=>{
        if (s.slug) out += s.slug.toUpperCase() + '\n';
        s.elements.forEach(el=>{
          if (el.t==='character') out += '\n' + el.txt.toUpperCase() + '\n';
          else if (el.t==='parenthetical') out += '('+el.txt+')\n';
          else if (el.t==='dialogue') out += el.txt + '\n';
          else if (el.t==='transition') out += '\n> '+el.txt.toUpperCase()+'\n';
          else out += '\n'+el.txt+'\n';
        });
        out += '\n';
      });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([out], {type:'text/plain'}));
      a.download = (project.title||'script') + '.fountain';
      a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    }
    function printPDF(){ window.print(); }

    /* =========================
     * Smart backup (delta/full)
     * =======================*/
    function buildDeltaOrFull(){
      const metaSig = metaSignature(project);
      const metaChanged = metaSig !== lastSerializedMetaHash;

      const known = project._hashes?.scene || {};
      const currentIds = new Set(project.scenes.map(s=>s.id));
      const upserts = [];
      const deletes = [];

      for (const s of project.scenes) {
        const hNow = hashString(stableSceneString(s));
        const hWas = known[s.id];
        if (!hWas || hWas !== hNow) upserts.push(s);
      }
      for (const oldId of Object.keys(known)) {
        if (!currentIds.has(oldId)) deletes.push(oldId);
      }

      const delta = {
        projectId: project.projectId,
        version: project.version,
        meta: metaChanged ? { title: project.title, settings: project.settings, notes: project.notes } : undefined,
        upserts: upserts.length ? upserts : undefined,
        deletes: deletes.length ? deletes : undefined
      };
      const deltaStr = JSON.stringify(delta);
      const deltaBytes = new Blob([deltaStr]).size;

      const needFull =
        project._deltaCountSinceFull >= FULL_SNAPSHOT_EVERY ||
        deltaBytes > MAX_DELTA_BYTES ||
        (project._lastBackedUpVersion === 0);

      if (needFull) {
        const fullData = structuredClone(project);
        delete fullData._hashes;
        delete fullData._lastBackedUpVersion;
        delete fullData._deltaCountSinceFull;
        const fullStr = JSON.stringify(fullData);
        const fullBytes = new Blob([fullStr]).size;
        return { kind: 'full', bytes: fullBytes, data: fullData, metaSig };
      } else {
        return { kind: 'delta', bytes: deltaBytes, data: delta, metaSig };
      }
    }

    function parseSceneSlugParts(slug){
      if (!slug) return { location: null, timeOfDay: null };
      const trimmed = String(slug).trim();
      if (!trimmed) return { location: null, timeOfDay: null };
      const prefixMatch = trimmed.match(/^(INT\.|EXT\.|INT\/EXT\.|INT-EXT\.)\s*(.*)$/i);
      const remainder = prefixMatch ? prefixMatch[2] || '' : trimmed;
      const parts = remainder.split(/\s*-\s*/);
      let location = parts.length ? parts[0].trim() : '';
      const timeOfDay = parts.length > 1 ? parts.slice(1).join(' - ').trim() : '';
      location = location || (prefixMatch ? remainder.trim() : trimmed);
      return {
        location: location || null,
        timeOfDay: timeOfDay || null
      };
    }

    function sceneToSupabaseRow(scene, index, ownerId){
      const { location, timeOfDay } = parseSceneSlugParts(scene.slug || '');
      const safeCards = Array.isArray(scene.cards) ? structuredClone(scene.cards) : [];
      const safeElements = Array.isArray(scene.elements) ? structuredClone(scene.elements) : [];
      const safeSounds = Array.isArray(scene.sounds) ? structuredClone(scene.sounds) : [];
      const characters = Array.isArray(project?.catalogs?.characters)
        ? project.catalogs.characters.map(char => ({ id: char.id || null, name: char.name || '' }))
        : [];
      const locations = Array.isArray(project?.catalogs?.locations)
        ? project.catalogs.locations.map(loc => ({ id: loc.id || null, name: loc.name || '' }))
        : [];
      return {
        id: scene.id,
        owner_id: ownerId,
        project_id: project.projectId,
        slug: scene.slug || null,
        title: scene.title || location || scene.slug || `Scene ${index + 1}`,
        synopsis: scene.notes || null,
        scene_number: index + 1,
        script_order: index,
        color: scene.color || null,
        location,
        time_of_day: timeOfDay,
        cards: safeCards,
        elements: safeElements,
        sounds: safeSounds,
        metadata: {
          notes: scene.notes || '',
          projectTitle: project.title || '',
          projectNotes: project.notes || '',
          projectVersion: project.version || 0,
          projectUpdatedAt: project.updatedAt || Date.now(),
          settings: {
            theme: project.settings?.theme || null,
            smartFormat: typeof project.settings?.smartFormat === 'boolean' ? project.settings.smartFormat : null
          },
          catalogs: { characters, locations }
        }
      };
    }

    async function backupToSupabase(supabase, { userInitiated = false } = {}){
      if (!project || !Array.isArray(project.scenes)){
        if (userInitiated) alert('No project loaded to back up yet.');
        return false;
      }
      try {
        const session = await getSupabaseSession(supabase);
        if (!session || !session.user){
          if (userInitiated) alert('Sign in to back up your project to the cloud.');
          return false;
        }
        const ownerId = session.user.id;
        ensureProjectShape();
        const scenes = project.scenes.map((scene, index) => sceneToSupabaseRow(scene, index, ownerId));

        const { error: deleteError } = await supabase
          .from('scenes')
          .delete()
          .eq('owner_id', ownerId)
          .eq('project_id', project.projectId);
        if (deleteError) throw deleteError;

        if (scenes.length){
          const { error: upsertError } = await supabase
            .from('scenes')
            .upsert(scenes, { onConflict: 'id' });
          if (upsertError) throw upsertError;
        }

        project._hashes.scene = {};
        project.scenes.forEach(s => {
          project._hashes.scene[s.id] = hashString(stableSceneString(s));
        });
        project._lastBackedUpVersion = project.version;
        project._deltaCountSinceFull = 0;
        lastSerializedMetaHash = metaSignature(project);
        await saveLocal(project);

        console.info('Backed up project to Supabase.');
        return true;
      } catch (err) {
        if (userInitiated) alert('Backup failed. Please try again.');
        console.error('Supabase backup failed:', err);
        return false;
      }
    }

    function scheduleSave(){
      clearTimeout(saveTimer);
      saveTimer = setTimeout(async ()=>{
        await saveLocal(project);
      }, 500);
    }

    function scheduleBackup(){
      clearTimeout(backupTimer);
      backupTimer = setTimeout(()=> backupSmart(false), BACKUP_IDLE_MS);
    }

    async function backupSmart(userInitiated = false){
      const supabase = window.supabaseClient;
      if (supabase){
        const saved = await backupToSupabase(supabase, { userInitiated });
        if (saved) return;
      } else if (userInitiated) {
        alert('Backup is still initializing. Please try again in a moment.');
      }

      // In Apps Script context this will exist; in canvas preview it won't.
      if (!(window.google && google.script && google.script.run)) return;
      const pack = buildDeltaOrFull();

      google.script.run
        .withSuccessHandler(res=>{
          if (pack.kind === 'full') project._deltaCountSinceFull = 0;
          else project._deltaCountSinceFull = (project._deltaCountSinceFull || 0) + 1;

          project._lastBackedUpVersion = project.version;
          lastSerializedMetaHash = pack.metaSig || lastSerializedMetaHash;

          if (pack.kind === 'full') {
            project._hashes.scene = {};
            project.scenes.forEach(s=>{
              project._hashes.scene[s.id] = hashString(stableSceneString(s));
            });
          } else {
            (pack.data.upserts || []).forEach(s=>{
              project._hashes.scene[s.id] = hashString(stableSceneString(s));
            });
            (pack.data.deletes || []).forEach(id=> delete project._hashes.scene[id]);
          }
          saveLocal(project);
        })
        .withFailureHandler(err=>{
          console.error('Backup failed:', err);
        })
        .SW_backupProjectDelta({
          projectId: project.projectId,
          version: project.version,
          kind: pack.kind,
          bytes: pack.bytes,
          data: pack.data
        });
    }

    function backupNow(){
      clearTimeout(backupTimer);
      backupSmart(true);
    }

    /* =========================
     * Restore (client-side)
     * =======================*/
    function openRestore(){
      if (!(window.google && google.script && google.script.run)) { alert('Restore unavailable outside Apps Script.'); return; }
      google.script.run
        .withSuccessHandler(rows=>{
          if (!rows || !rows.length){ alert('No backups found.'); return; }
          const preview = rows.slice(0, 20).map((r,i)=> `${i}. ${r.kind.toUpperCase()} • v${r.version} • ${r.timestamp}`).join('\n');
          const choice = prompt('Choose entry # (0..19):\n' + preview, '0');
          const idx = Number(choice);
          if (isNaN(idx) || idx < 0 || idx >= Math.min(20, rows.length)) return;
          const subset = rows.slice(0, idx+1); // 0 is newest
          let fullIdx = -1;
          for (let i = subset.length-1; i >= 0; i--) {
            if (subset[i].kind === 'full'){ fullIdx = i; break; }
          }
          if (fullIdx === -1){ alert('No full snapshot found in selection window. Try choosing an older entry.'); return; }
          let state = JSON.parse(subset[fullIdx].payloadJSON);
          for (let i = fullIdx-1; i >= 0; i--){
            const entry = subset[i];
            if (entry.kind === 'delta') applyDeltaClient(state, JSON.parse(entry.payloadJSON));
          }
          project = state;
          project._hashes = { scene: {} };
          project.scenes.forEach(s => project._hashes.scene[s.id] = hashString(stableSceneString(s)));
          project._lastBackedUpVersion = project.version || 0;
          project._deltaCountSinceFull = 0;
          lastSerializedMetaHash = metaSignature(project);
          saveLocal(project);
          activeSceneId = project.scenes[0]?.id || null;
          render();
          alert('Restored to version ' + (project.version || '?'));
        })
        .withFailureHandler(err=> alert('Failed to load backups: ' + err))
        .SW_loadBackups(project.projectId, 200);
    }

    function applyDeltaClient(state, delta){
      if (delta.meta) {
        if (Object.prototype.hasOwnProperty.call(delta.meta, 'title')) state.title = delta.meta.title;
        if (Object.prototype.hasOwnProperty.call(delta.meta, 'notes')) state.notes = delta.meta.notes;
        if (delta.meta.settings) state.settings = Object.assign({}, state.settings || {}, delta.meta.settings);
      }
      const byId = new Map((state.scenes||[]).map(s => [s.id, s]));
      (delta.upserts || []).forEach(s => byId.set(s.id, s));
      (delta.deletes || []).forEach(id => byId.delete(id));
      state.scenes = Array.from(byId.values());
      if (typeof delta.version === 'number') state.version = Math.max(state.version || 0, delta.version);
    }

    /* =========================
     * Focus Mode
     * =======================*/
    function applyFocusModeUI(){
      const focused = !!project?.settings?.focus;
      document.body.classList.toggle('focus-mode', focused);
      const btn = document.getElementById('focusBtn');
      if (btn) btn.textContent = focused ? 'Exit Focus' : 'Focus';
      updateHud();
      markActiveLine();
      if (focused) centerActiveLine();
      syncNavHeight();
    }
    function toggleFocus(){
      project.settings = project.settings || {};
      project.settings.focus = !project.settings.focus;
      saveLocal(project);
      applyFocusModeUI();
    }
    function updateHud(){
      const hudC = document.getElementById('hudCounter');
      const hudSel = document.getElementById('hudScenePicker');
      if (hudC) hudC.textContent = document.getElementById('counter')?.textContent || '';
      if (hudSel){
        hudSel.innerHTML = '';
        project.scenes.forEach((s, i)=>{
          const opt = document.createElement('option');
          opt.value = s.id;
          opt.textContent = `${String(i+1).padStart(2,'0')} • ${s.slug || '(no slug)'}`;
          if (s.id === activeSceneId) opt.selected = true;
          hudSel.appendChild(opt);
        });
      }
    }
    function pickSceneFromHud(sceneId){
      if (!sceneId) return;
      activeSceneId = sceneId;
      render();
      const hudSel = document.getElementById('hudScenePicker');
      if (hudSel) hudSel.value = sceneId;
      markActiveLine();
      if (document.body.classList.contains('focus-mode')) centerActiveLine();
    }

    /* =========================
     * Pomodoro (Focus HUD)
     * =======================*/
    const POMO_DEFAULTS = { workMin: 25, breakMin: 5, autoStartBreak: true, autoStartWork: false };
    let pomo = { running: false, mode: 'work', endAt: 0, remainingMs: 25*60*1000, _timerId: null };

    function ensurePomodoroSettings(){
      project.settings = project.settings || {};
      project.settings.pomodoro = Object.assign({}, POMO_DEFAULTS, project.settings.pomodoro || {});
      if (!pomo || typeof pomo.remainingMs !== 'number') {
        pomo = {
          running: false, mode: 'work', endAt: 0,
          remainingMs: project.settings.pomodoro.workMin * 60 * 1000,
          _timerId: null
        };
      }
    }
    function fmtMMSS(ms){
      ms = Math.max(0, ms|0);
      const s = Math.round(ms/1000);
      const mm = String(Math.floor(s/60)).padStart(2,'0');
      const ss = String(s%60).padStart(2,'0');
      return `${mm}:${ss}`;
    }
    function updatePomodoroUI(){
      const dial = document.getElementById('pomoTime');
      const modeEl = document.getElementById('pomoMode');
      const ring = dial?.parentElement;
      const tog = document.getElementById('pomoToggle');
      if (!dial || !modeEl || !ring || !tog) return;

      dial.textContent = fmtMMSS(pomo.remainingMs);
      modeEl.textContent = pomo.mode === 'work' ? 'Work' : 'Break';

      const total = (pomo.mode === 'work'
        ? project.settings.pomodoro.workMin
        : project.settings.pomodoro.breakMin) * 60 * 1000;
      const pct = 100 * (1 - (pomo.remainingMs / total));
      ring.style.setProperty('--pct', Math.max(0, Math.min(100, pct)));

      tog.textContent = pomo.running ? 'Pause' : 'Start';

      project._pomoState = { running: pomo.running, mode: pomo.mode, remainingMs: pomo.remainingMs, endAt: pomo.endAt };
      saveLocal(project);
    }
    function startPomodoroTick(){
      stopPomodoroTick();
      pomo.running = true;
      if (pomo.endAt <= Date.now()) pomo.endAt = Date.now() + pomo.remainingMs;
      pomo._timerId = setInterval(()=>{
        const now = Date.now();
        pomo.remainingMs = Math.max(0, pomo.endAt - now);
        updatePomodoroUI();
        if (pomo.remainingMs <= 0) {
          stopPomodoroTick();
          onPomodoroEnd();
        }
      }, 250);
      updatePomodoroUI();
    }
    function stopPomodoroTick(){
      pomo.running = false;
      if (pomo._timerId) clearInterval(pomo._timerId);
      pomo._timerId = null;
      if (pomo.endAt > 0) pomo.remainingMs = Math.max(0, pomo.endAt - Date.now());
      updatePomodoroUI();
    }
    function togglePomodoro(){ if (pomo.running) stopPomodoroTick(); else startPomodoroTick(); }
    function resetPomodoro(){
      const mins = (pomo.mode === 'work' ? project.settings.pomodoro.workMin : project.settings.pomodoro.breakMin);
      pomo.remainingMs = mins * 60 * 1000; pomo.endAt = 0; updatePomodoroUI();
    }
    function switchPomodoroMode(nextMode){
      pomo.mode = nextMode;
      const mins = (pomo.mode === 'work' ? project.settings.pomodoro.workMin : project.settings.pomodoro.breakMin);
      pomo.remainingMs = mins * 60 * 1000; pomo.endAt = 0; updatePomodoroUI();
    }
    function beep(){
      try{
        const ctx = new (window.AudioContext||window.webkitAudioContext)();
        const o = ctx.createOscillator(); const g = ctx.createGain();
        o.type = 'sine'; o.frequency.value = 880; o.connect(g); g.connect(ctx.destination);
        g.gain.setValueAtTime(0.001, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime + 0.01);
        o.start();
        setTimeout(()=>{ g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.05); o.stop(ctx.currentTime + 0.08); }, 180);
      }catch(e){}
    }
    function onPomodoroEnd(){
      beep();
      if (pomo.mode === 'work') {
        switchPomodoroMode('break');
        if (project.settings.pomodoro.autoStartBreak) startPomodoroTick();
      } else {
        switchPomodoroMode('work');
        if (project.settings.pomodoro.autoStartWork) startPomodoroTick();
      }
    }

    /* =========================
     * Shortcuts
     * =======================*/
    document.addEventListener('keydown', (e)=>{
      if (e.key === 'Escape' && timelineMode){
        const previewOpen = document.getElementById('timelinePreview')?.classList.contains('open');
        if (previewOpen) closeTimelinePreview();
        else closeTimelineMode();
        return;
      }
      const cmd = e.metaKey || e.ctrlKey;
      if (cmd && e.key.toLowerCase() === 'k') { e.preventDefault(); toggleFocus(); return; }
      if (cmd && e.key === ';') { e.preventDefault(); togglePomodoro(); return; }
      if (cmd && e.key === "'") { e.preventDefault(); resetPomodoro(); return; }
    });

    /* =========================
     * Versioning helpers
     * =======================*/
    function bumpVersion(){ project.version = (project.version || 0) + 1; project.updatedAt = Date.now(); }

    /* =========================
     * Self-tests (basic) — won't change user data
     * =======================*/
    function runSelfTests(){
      try {
        // Theme switch test
        const prevTheme = project.settings.theme;
        project.settings.theme = 'light'; applyTheme();
        const lightBg = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim();
        console.assert(lightBg === '#f7f9fc', 'Light theme var not applied');
        project.settings.theme = 'dark'; applyTheme();
        const darkBg = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim();
        console.assert(darkBg === '#0b0f14', 'Dark theme var not applied');
        // Build delta/full doesn't throw
        const pack = buildDeltaOrFull();
        console.assert(pack && (pack.kind==='delta'||pack.kind==='full'), 'buildDeltaOrFull returned invalid kind');
        // Focus HUD exists
        console.assert(document.getElementById('focusHud'), 'focusHud missing');
        console.log('Self-tests passed');
      } catch (err) {
        console.error('Self-tests failed', err);
      }
    }

    /* =========================
     * Bootstrap
     * =======================*/
    (async function init(){
      await openDB();

      // Load last project if exists
      const lastId = getLastProjectId();
      if (lastId) {
        const loaded = await loadLocal(lastId);
        if (loaded) {
          project = loaded;
          activeSceneId = project.scenes?.[0]?.id || null;
        } else {
          newProject();
          await saveLocal(project);
        }
      } else {
        newProject();
        await saveLocal(project);
      }

      project.settings = project.settings || {};
      if (typeof project.settings.focus === 'undefined') project.settings.focus = false;

      ensurePomodoroSettings();
      if (project._pomoState) {
        pomo = Object.assign({}, pomo, project._pomoState);
        if (!['work','break'].includes(pomo.mode)) pomo.mode = 'work';
      }

      lastSerializedMetaHash = metaSignature(project);
      timelineInsertIndex = Array.isArray(project?.scenes) ? project.scenes.length : 0;
      render();
      applyFocusModeUI();
      updatePomodoroUI();
      setTimeout(runSelfTests, 0);
    })();
    </script>
  </main>

  <footer class="footer">
    <div class="footer__grid">
      <div><strong>StudioOrganize</strong></div>
      <div><a href="/products/">Products</a></div>
      <div><a href="mailto:support@studioorganize.com">support@studioorganize.com</a><br/><span class="muted">© <span id="y"></span> StudioOrganize</span></div>
    </div>
  </footer>
  <script type="module" src="/assets/auth.js"></script>
  <script src="/assets/main.js" defer></script>
</body>
</html>
