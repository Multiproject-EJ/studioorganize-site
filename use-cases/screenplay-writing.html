<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Screenplay Writing — StudioOrganize</title>
  <link rel="stylesheet" href="/assets/styles.css"/>
</head>
<body>
  <header class="nav">
    <a class="brand" href="/">StudioOrganize</a>
    <nav class="menu">
      <div class="dropdown">
        <button class="dropbtn">Products</button>
        <div class="dropdown-content">
          <a href="/products/#online">Subscribe &amp; save it online</a>
          <a href="/products/#sheets">Google Sheets — keep the database yourself</a>
        </div>
      </div>
      <div class="dropdown">
        <button class="dropbtn">Use Cases</button>
        <div class="dropdown-content">
          <a href="/use-cases/">All Use Cases</a>
          <a href="/use-cases/generate-ideas.html">Generate Ideas</a>
          <a href="/use-cases/screenplay.html">Screenplay Script</a>
          <a href="/use-cases/character-design.html">Character Design</a>
          <a href="/use-cases/set-design.html">Set / Production Design</a>
        </div>
      </div>
      <a href="/about.html">About</a>
      <a href="/faq.html">FAQ</a>
      <button class="theme-toggle" type="button" data-theme-toggle aria-pressed="false">Toggle theme</button>
    </nav>
  </header>

  <main class="section">
    <style>
      html,body{height:100%; font-family: ui-sans-serif,system-ui,Segoe UI,Roboto,Arial}
      body{color:var(--ink);}
      main.section{flex:1; display:flex; flex-direction:column; width:100%; max-width:none; padding:0; margin:0;}
      .app{display:grid; grid-template-rows:56px 1fr; flex:1; min-height:0}
      .topbar{display:flex; align-items:center; gap:12px; padding:8px 12px; background:var(--panel); border-bottom:1px solid var(--ring)}
      .topbar h1{font-size:16px; font-weight:600; margin:0 8px 0 0}
      .spacer{flex:1}
      .btn{background:var(--chip); color:var(--ink); border:1px solid var(--ring); border-radius:10px; padding:8px 12px; cursor:pointer}
      .layout{display:grid; grid-template-columns:280px 1fr 320px; gap:10px; padding:10px; min-height:0}
      .panel{background:var(--panel); border:1px solid var(--ring); border-radius:14px; overflow:hidden; display:flex; flex-direction:column; min-height:0}
      .panel h2{font-size:13px; font-weight:600; letter-spacing:.4px; color:var(--muted); margin:10px 12px}
      .scenes{overflow:auto; padding:8px}
      .scene-card{background:var(--card); border:1px solid var(--ring); border-radius:12px; padding:10px; margin-bottom:8px; cursor:pointer}
      .scene-card.active{outline:2px solid var(--acc)}
      .scene-card small{color:var(--muted)}
      .editor{padding:0; display:flex; flex-direction:column; min-height:0}
      .editor-area{flex:1; overflow:auto; padding:16px 20px; line-height:1.6; font-size:15px; white-space:pre-wrap; outline:none; direction:ltr; writing-mode:horizontal-tb; unicode-bidi:plaintext}
      .line{margin:6px 0}
      .line.slug{letter-spacing:.4px; font-weight:700}
      .line.character{text-transform:uppercase; margin-top:14px; margin-bottom:2px}
      .line.parenthetical{margin-left:30px; font-style:italic}
      .line.dialogue{margin-left:30px; max-width:60ch}
      .line.transition{text-align:right; letter-spacing:.2px}
      .notes{padding:8px; display:flex; flex-direction:column; gap:8px; overflow:auto}
      textarea, input, select{background:var(--field); color:var(--ink); border:1px solid var(--ring); border-radius:10px; padding:8px; width:100%}
      .row{display:flex; gap:8px}
      .counter{font-size:12px; color:var(--muted)}
      .tab-header{display:flex; padding:8px; gap:6px; background:var(--chip); border-bottom:1px solid var(--ring)}
      .tab-btn{flex:1; background:var(--chip); border:1px solid var(--ring); border-radius:10px; padding:8px 10px; font-size:12px; color:var(--ink); cursor:pointer; letter-spacing:.3px; text-transform:uppercase}
      .tab-btn.active{background:var(--acc); border-color:var(--acc); color:var(--active-tab-text); font-weight:600}
      .tab-panels{flex:1; display:flex; flex-direction:column; min-height:0}
      .tab-panel{display:none; flex-direction:column; flex:1; padding:12px; gap:12px; overflow:auto}
      .tab-panel.active{display:flex}
      .tab-panel h3{margin:0; font-size:12px; letter-spacing:.4px; color:var(--muted); text-transform:uppercase}
      .panel-footer{padding:12px; border-top:1px solid var(--ring); display:flex; flex-direction:column; gap:10px; background:var(--panel)}
      .panel-footer h2{margin:0; font-size:13px; font-weight:600; letter-spacing:.4px; color:var(--muted); text-transform:uppercase}
      .timeline-list{display:flex; flex-direction:column; gap:10px}
      .timeline-item{display:flex; gap:10px; align-items:flex-start; padding:10px; border:1px solid var(--ring); border-radius:12px; background:var(--chip); cursor:pointer; transition:background .2s, border-color .2s; font:inherit; color:inherit; text-align:left}
      .timeline-item:hover{border-color:var(--acc)}
      .timeline-item.active{background:var(--acc); border-color:var(--acc); color:var(--active-tab-text)}
      .timeline-item.active .timeline-bullet{background:var(--active-tab-text); color:var(--panel)}
      .timeline-bullet{width:26px; height:26px; border-radius:999px; background:var(--ring); color:var(--muted); display:flex; align-items:center; justify-content:center; font-size:12px; font-weight:600}
      .timeline-item:focus{outline:none}
      .timeline-item:focus-visible{outline:2px solid var(--acc); outline-offset:2px}
      .timeline-body{display:flex; flex-direction:column; gap:4px}
      .timeline-meta{font-size:11px; color:var(--muted)}
      .timeline-item.active .timeline-meta{color:var(--active-tab-text)}
      .timeline-empty{font-size:12px; color:var(--muted)}
      .stats-grid{display:grid; grid-template-columns:repeat(auto-fit, minmax(90px, 1fr)); gap:10px}
      .stat-card{border:1px solid var(--ring); border-radius:12px; padding:10px; background:var(--chip); display:flex; flex-direction:column; gap:4px; text-align:center}
      .stat-value{font-size:18px; font-weight:700; color:var(--ink)}
      .stat-label{font-size:11px; color:var(--muted); letter-spacing:.3px; text-transform:uppercase}
      .tab-chip-group{display:flex; flex-wrap:wrap; gap:6px}
      .tab-chip{background:var(--chip); border:1px solid var(--ring); border-radius:10px; padding:6px 10px; font-size:12px; color:var(--ink); cursor:pointer}
      .tab-chip:hover{border-color:var(--acc)}
      .danger-btn{background:#7f1d1d; border:1px solid #b91c1c; color:#fff; border-radius:10px; padding:8px 10px; font-size:12px; cursor:pointer}
      .danger-btn:disabled{opacity:0.5; cursor:not-allowed}
      .catalog-list{display:flex; flex-direction:column; gap:6px}
      .catalog-item{display:flex; justify-content:space-between; align-items:center; gap:8px; background:var(--card); border:1px solid var(--ring); border-radius:10px; padding:8px 10px}
      .catalog-item span{font-size:13px}
      .catalog-actions{display:flex; gap:6px}
      .catalog-actions button{background:var(--chip); border:1px solid var(--ring); border-radius:8px; padding:4px 8px; font-size:11px; color:var(--ink); cursor:pointer}
      .muted-text{color:var(--muted); font-size:12px}
      .tab-divider{height:1px; background:var(--ring); margin:4px 0}
      .sound-list{display:flex; flex-direction:column; gap:6px}
      .sound-item{display:flex; justify-content:space-between; align-items:center; gap:8px; background:var(--card); border:1px solid var(--ring); border-radius:10px; padding:8px 10px}
      .sound-item button{background:var(--chip); border:1px solid var(--ring); border-radius:8px; padding:4px 8px; font-size:11px; color:var(--ink); cursor:pointer}

      /* ==== Focus Mode ==== */
      body.focus-mode .layout{ grid-template-columns: 1fr; }
      body.focus-mode .layout .panel:first-child,
      body.focus-mode .layout .panel:last-child{ display:none !important; }
      body.focus-mode .editor-area{
        max-width: 68ch;
        margin: 0 auto;
        padding: 48px 24px;
        font-size: 17px;
        line-height: 1.7;
      }
      body.focus-mode .topbar .non-essential{ display:none !important; }

      /* Line highlight */
      .line.active{ background: rgba(255,255,255,0.05); border-radius: 8px; padding: 2px 6px; }
      body.focus-mode .line.active{ background: rgba(95,168,255,0.12); }

      /* Bottom HUD visible only in focus mode */
      #focusHud{
        position: fixed; left: 50%; bottom: 18px; transform: translateX(-50%);
        background: var(--hud); border: 1px solid var(--ring); border-radius: 12px;
        padding: 8px 12px; display: none; gap: 8px; align-items: center;
        box-shadow: 0 8px 24px rgba(0,0,0,0.35); z-index: 9999;
      }
      body.focus-mode #focusHud{ display:flex; }
      #focusHud .hud-text{ font-size:12px; color: var(--muted); white-space:nowrap }
      #focusHud select, #focusHud button{background:var(--chip); color:var(--ink); border:1px solid var(--ring);
        border-radius:10px; padding:6px 10px; font-size:12px; cursor:pointer
      }

      /* ==== Pomodoro (Focus HUD) ==== */
      #focusHud .pomo-chip{display:flex; align-items:center; gap:10px; padding:6px 8px; border-radius:10px;
        background:var(--chip); border:1px solid var(--ring);
      }
      .pomo-ring{
        --pct: 0; /* 0..100 */
        width:44px; height:44px; border-radius:50%;
        background: conic-gradient(var(--acc) calc(var(--pct)*1%), var(--progressTrack) 0);
        display:grid; place-items:center;
      }
      .pomo-dial{
        width:34px; height:34px; border-radius:50%;
        display:grid; place-items:center;
        background:var(--dial); font-size:11px; letter-spacing:0.3px;
        color:var(--ink); border:1px solid var(--ring);
      }
      .pomo-meta{ display:flex; flex-direction:column; line-height:1.15 }
      .pomo-mode{ font-size:11px; color:var(--muted) }
      .pomo-controls{ display:flex; gap:6px }
      .pomo-btn{
        background:var(--chip); color:var(--ink); border:1px solid var(--ring);
        border-radius:10px; padding:4px 8px; font-size:12px; cursor:pointer;
      }

      /* Print to PDF: keep only the script */
      @media print{
        .topbar, .layout .panel:first-child, .layout .panel:last-child, #focusHud{ display:none !important; }
        .layout{ grid-template-columns: 1fr; }
        .editor-area{ max-width: 70ch; margin:0 auto; }
        body{ background:#fff; color:#000; }
        .panel{ border:none }
      }
    </style>
    <div class="app">
      <div class="topbar">
        <h1 id="title">Untitled Project</h1>
        <span class="counter" id="counter">0 pages • 0 words</span>
        <div class="spacer"></div>

        <!-- non-essential buttons collapse in focus mode -->
        <button class="btn non-essential" onclick="exportFountain()">Export Fountain</button>
        <button class="btn non-essential" onclick="setRightTab('timeline')">Timeline</button>
        <button class="btn non-essential" onclick="printPDF()">Export PDF</button>
        <button class="btn non-essential" onclick="backupNow()">Backup Now</button>
        <button class="btn non-essential" onclick="openRestore()">Restore…</button>

        <!-- Focus toggle -->
        <button class="btn" id="focusBtn" onclick="toggleFocus()">Focus</button>
      </div>

      <div class="layout">
        <div class="panel">
          <h2 style="display:flex;align-items:center;justify-content:space-between;margin-right:8px">
            Scenes
            <button class="btn" style="padding:4px 8px" onclick="addScene()">+ Scene</button>
          </h2>
          <div id="sceneList" class="scenes"></div>
        </div>

        <div class="panel editor">
          <h2>Script</h2>
          <div id="editor" class="editor-area" contenteditable="true"></div>
        </div>

        <div class="panel">
          <div class="tab-header" id="rightTabBar">
            <button class="tab-btn" data-tab-btn="write">Write</button>
            <button class="tab-btn" data-tab-btn="characters">Characters</button>
            <button class="tab-btn" data-tab-btn="set">Set</button>
            <button class="tab-btn" data-tab-btn="sound">Sound</button>
            <button class="tab-btn" data-tab-btn="timeline">Timeline</button>
            <button class="tab-btn" data-tab-btn="stats">Stats</button>
          </div>
          <div class="tab-panels">
            <div class="tab-panel" data-tab="write" id="tabWrite">
              <div>
                <h3>Scene Slug</h3>
                <div class="tab-chip-group">
                  <button class="tab-chip" data-slug-prefix="INT.">INT</button>
                  <button class="tab-chip" data-slug-prefix="EXT.">EXT</button>
                  <button class="tab-chip" data-slug-prefix="INT-EXT.">INT-EXT</button>
                </div>
                <div class="tab-chip-group">
                  <button class="tab-chip" data-slug-suffix="DAY">DAY</button>
                  <button class="tab-chip" data-slug-suffix="NIGHT">NIGHT</button>
                </div>
              </div>
              <div class="tab-divider"></div>
              <div>
                <h3>Insert Line</h3>
                <div class="tab-chip-group">
                  <button class="tab-chip" data-line-type="slug">Slug</button>
                  <button class="tab-chip" data-line-type="action">Action</button>
                  <button class="tab-chip" data-line-type="character">Character</button>
                  <button class="tab-chip" data-line-type="parenthetical">Parenthetical</button>
                  <button class="tab-chip" data-line-type="dialogue">Dialogue</button>
                  <button class="tab-chip" data-line-type="transition">Transition</button>
                </div>
              </div>
              <div class="tab-divider"></div>
              <div>
                <button class="danger-btn" id="deleteSceneBtn">Delete Scene</button>
              </div>
            </div>
            <div class="tab-panel" data-tab="characters" id="tabCharacters">
              <div>
                <h3>Characters</h3>
                <div class="catalog-list" id="characterList"></div>
              </div>
              <div class="row">
                <input id="newCharacterName" placeholder="Add character" />
                <button class="btn" id="addCharacterBtn">Add</button>
              </div>
              <p class="muted-text">Tap a name to insert it as a CHARACTER line.</p>
            </div>
            <div class="tab-panel" data-tab="set" id="tabSet">
              <div>
                <h3>Locations</h3>
                <div class="catalog-list" id="setList"></div>
              </div>
              <div class="row">
                <input id="newSetName" placeholder="Add location" />
                <button class="btn" id="addSetBtn">Add</button>
              </div>
            </div>
            <div class="tab-panel" data-tab="sound" id="tabSound">
              <div>
                <h3>Sound Cues</h3>
                <div class="sound-list" id="soundList"></div>
              </div>
              <div class="row">
                <input id="newSoundCue" placeholder="Add sound cue" />
                <button class="btn" id="addSoundBtn">Add</button>
              </div>
            </div>
            <div class="tab-panel" data-tab="timeline" id="tabTimeline">
              <h3>Timeline</h3>
              <div class="timeline-list" id="timelineList"></div>
            </div>
            <div class="tab-panel" data-tab="stats" id="tabStats">
              <h3>Stats</h3>
              <div class="stats-grid">
                <div class="stat-card">
                  <span class="stat-value" id="statSceneCount">0</span>
                  <span class="stat-label">Scenes</span>
                </div>
                <div class="stat-card">
                  <span class="stat-value" id="statPageCount">0</span>
                  <span class="stat-label">Pages</span>
                </div>
                <div class="stat-card">
                  <span class="stat-value" id="statWordCount">0</span>
                  <span class="stat-label">Words</span>
                </div>
                <div class="stat-card">
                  <span class="stat-value" id="statLineCount">0</span>
                  <span class="stat-label">Lines</span>
                </div>
              </div>
            </div>
          </div>
          <div class="panel-footer">
            <h2>Notes &amp; Meta</h2>
            <div class="notes">
              <input id="projectTitle" placeholder="Project Title" />
              <textarea id="projectNotes" rows="8" placeholder="Project notes"></textarea>
              <div class="row">
                <input id="sceneSlug" placeholder="Scene Heading (Slug)" />
                <input id="sceneColor" type="color" />
              </div>
              <div class="row">
                <select id="smartFormat">
                  <option value="true">Smart format: ON</option>
                  <option value="false">Smart format: OFF</option>
                </select>
                <select id="themeSel">
                  <option value="dark">Theme: Dark</option>
                  <option value="light">Theme: Light</option>
                </select>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Minimal HUD for focus mode -->
    <div id="focusHud">
      <span class="hud-text" id="hudCounter">0 pages • 0 words</span>
      <select id="hudScenePicker" onchange="pickSceneFromHud(this.value)"></select>

      <div class="pomo-chip">
        <div class="pomo-ring"><div class="pomo-dial" id="pomoTime">25:00</div></div>
        <div class="pomo-meta">
          <div class="pomo-mode" id="pomoMode">Work</div>
          <div class="pomo-controls">
            <button class="pomo-btn" id="pomoToggle" onclick="togglePomodoro()">Start</button>
            <button class="pomo-btn" onclick="resetPomodoro()">Reset</button>
          </div>
        </div>
      </div>

      <button onclick="addScene()">+ Scene</button>
      <button onclick="toggleFocus()">Exit Focus</button>
    </div>

    <script>
    /* =========================
     * IndexedDB minimal wrapper
     * =======================*/
    const DB_NAME = 'sw_db_v1';
    const STORE = 'projects';
    let db;

    function openDB(){
      return new Promise((resolve, reject)=>{
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = e => {
          const idb = e.target.result;
          if(!idb.objectStoreNames.contains(STORE)){
            idb.createObjectStore(STORE, { keyPath: 'projectId' });
          }
        };
        req.onsuccess = e => { db = e.target.result; resolve(); };
        req.onerror = e => reject(e);
      });
    }
    function saveLocal(project){
      return new Promise((resolve,reject)=>{
        const tx = db.transaction([STORE],'readwrite');
        tx.objectStore(STORE).put(project);
        tx.oncomplete = resolve;
        tx.onerror = reject;
      });
    }
    function loadLocal(projectId){
      return new Promise((resolve,reject)=>{
        const tx = db.transaction([STORE],'readonly');
        const req = tx.objectStore(STORE).get(projectId);
        req.onsuccess = ()=> resolve(req.result || null);
        req.onerror = reject;
      });
    }

    /* =========================
     * State & Config
     * =======================*/
    let project = null;
    let activeSceneId = null;
    let saveTimer = null;

    const BACKUP_IDLE_MS = 120000;   // 2 min idle → auto backup
    const FULL_SNAPSHOT_EVERY = 10;  // every 10 deltas
    const MAX_DELTA_BYTES = 128 * 1024;

    let backupTimer = null;
    let lastSerializedMetaHash = '';

    const RIGHT_TAB_KEY = 'SW_RIGHT_TAB';
    let activeRightTab = (()=>{
      try { return localStorage.getItem(RIGHT_TAB_KEY) || 'write'; }
      catch(e){ return 'write'; }
    })();

    /* =========================
     * Hashing (FNV-1a) & helpers
     * =======================*/
    function hashString(str) {
      let h = 2166136261 >>> 0;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return (h >>> 0).toString(16);
    }
    function stableSceneString(s){
      return JSON.stringify({
        id: s.id, slug: s.slug,
        elements: s.elements, color: s.color, notes: s.notes,
        sounds: s.sounds
      });
    }
    function metaSignature(p){
      return JSON.stringify({ title:p.title, notes:p.notes, settings:p.settings });
    }

    function ensureProjectShape(){
      project.settings = project.settings || {};
      if (!project.settings.theme){
        const globalTheme = (typeof window.getSiteTheme === 'function') ? window.getSiteTheme() : (document.documentElement.dataset.theme || 'dark');
        project.settings.theme = globalTheme || 'dark';
      }
      project.catalogs = project.catalogs || {};
      project.catalogs.characters = (project.catalogs.characters || []).map(item => {
        if (typeof item === 'string') return { id: crypto.randomUUID(), name: item };
        if (!item || typeof item !== 'object') return { id: crypto.randomUUID(), name: '' };
        if (!item.id) item.id = crypto.randomUUID();
        item.name = typeof item.name === 'string' ? item.name : '';
        return item;
      });
      project.catalogs.locations = (project.catalogs.locations || []).map(item => {
        if (typeof item === 'string') return { id: crypto.randomUUID(), name: item };
        if (!item || typeof item !== 'object') return { id: crypto.randomUUID(), name: '' };
        if (!item.id) item.id = crypto.randomUUID();
        item.name = typeof item.name === 'string' ? item.name : '';
        return item;
      });
      project.scenes = (project.scenes || []).map(scene => {
        if (!Array.isArray(scene.cards)) scene.cards = [];
        if (!Array.isArray(scene.elements)) scene.elements = [];
        scene.sounds = (scene.sounds || []).map(sound => {
          if (typeof sound === 'string') return { id: crypto.randomUUID(), cue: sound };
          if (!sound || typeof sound !== 'object') return { id: crypto.randomUUID(), cue: '' };
          if (!sound.id) sound.id = crypto.randomUUID();
          sound.cue = typeof sound.cue === 'string' ? sound.cue : '';
          return sound;
        });
        return scene;
      });
    }

    function setRightTab(tab){
      const allowed = ['write','characters','set','sound','timeline','stats'];
      activeRightTab = allowed.includes(tab) ? tab : 'write';
      try { localStorage.setItem(RIGHT_TAB_KEY, activeRightTab); } catch(e){}
      applyActiveTabUI();
    }

    function applyActiveTabUI(){
      const allowed = ['write','characters','set','sound','timeline','stats'];
      if (!allowed.includes(activeRightTab)) activeRightTab = 'write';
      document.querySelectorAll('[data-tab-btn]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tabBtn === activeRightTab);
      });
      document.querySelectorAll('.tab-panel').forEach(panel => {
        panel.classList.toggle('active', panel.dataset.tab === activeRightTab);
      });
    }

    /* =========================
     * Project creation / load
     * =======================*/
    function getLastProjectId(){ try { return localStorage.getItem('SW_LAST_PROJECT_ID'); } catch(e){ return null; } }
    function setLastProjectId(id){ try { localStorage.setItem('SW_LAST_PROJECT_ID', id); } catch(e){} }

    function newProject(){
      const pid = crypto.randomUUID();
      project = {
        projectId: pid,
        title: 'Untitled Project',
        format: 'screenplay/v1',
        createdAt: Date.now(),
        updatedAt: Date.now(),
        version: 1,
        settings: { theme: (typeof window.getSiteTheme === 'function' ? window.getSiteTheme() : (document.documentElement.dataset.theme || 'dark')), smartFormat:true, pageWidth:60, focus:false, pomodoro: undefined },
        catalogs: { characters:[], locations:[] },
        scenes: [{
          id: crypto.randomUUID(),
          slug: 'INT. HOUSE - DAY',
          cards: ['Opening image'],
          elements: [{t:'action', txt:'A room. Quiet.'}],
          color: '#5FA8FF',
          notes: '',
          sounds: []
        }],
        notes: '',
        _hashes: { scene: {} },
        _lastBackedUpVersion: 0,
        _deltaCountSinceFull: 0
      };
      project.scenes.forEach(s => { project._hashes.scene[s.id] = hashString(stableSceneString(s)); });
      activeSceneId = project.scenes[0].id;
      setLastProjectId(pid);
    }

    /* =========================
     * Rendering & UI
     * =======================*/
    function render(){
      ensureProjectShape();
      document.getElementById('title').textContent = project.title || 'Untitled Project';
      document.getElementById('projectTitle').value = project.title || '';
      document.getElementById('projectNotes').value = project.notes || '';
      const smartSel = document.getElementById('smartFormat');
      if (smartSel) smartSel.value = String(!!project.settings.smartFormat);
      project.settings.theme = project.settings.theme || (typeof window.getSiteTheme === 'function' ? window.getSiteTheme() : (document.documentElement.dataset.theme || 'dark'));
      const themeSel = document.getElementById('themeSel');
      if (themeSel) themeSel.value = project.settings.theme;

      // scenes list
      const list = document.getElementById('sceneList');
      list.innerHTML = '';
      project.scenes.forEach((s, idx)=>{
        const div = document.createElement('div');
        div.className = 'scene-card' + (s.id===activeSceneId ? ' active':'');
        div.onclick = ()=>{ activeSceneId = s.id; render(); };
        div.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
            <div>
              <strong>${escapeHtml(s.slug || '(no slug)')}</strong><br/>
              <small>Scene ${idx+1}</small>
            </div>
            <span title="Color" style="width:12px;height:12px;border-radius:50%;background:${s.color||'#5FA8FF'}"></span>
          </div>`;
        list.appendChild(div);
      });

      // right-side bindings
      const scene = getActiveScene();
      if (!scene){
        document.getElementById('editor').innerHTML = '';
        updateCounters();
        updateHud();
        updatePomodoroUI();
        applyTheme();
        renderCatalogs();
        renderSoundList();
        renderTimeline();
        updateDeleteSceneButton();
        applyActiveTabUI();
        return;
      }
      if (!Array.isArray(scene.sounds)) scene.sounds = [];
      document.getElementById('sceneSlug').value = scene.slug || '';
      document.getElementById('sceneColor').value = scene.color || '#5FA8FF';

      // editor render
      const editor = document.getElementById('editor');
      editor.innerHTML = scene.elements.map(el=>{
        return `<div class="line ${el.t}" data-t="${el.t}">${escapeHtml(el.txt)}</div>`;
      }).join('');
      normalizeEditorLines(); // ensure structure

      updateCounters();
      updateHud();
      updatePomodoroUI();
      applyTheme();
      renderCatalogs();
      renderSoundList();
      renderTimeline();
      updateDeleteSceneButton();
      applyActiveTabUI();
    }

    /* Keep child nodes as .line blocks */
    function normalizeEditorLines(){
      const editor = document.getElementById('editor');
      const children = Array.from(editor.childNodes);
      const normalized = [];
      let changed = false;

      for (let n of children){
        if (n.nodeType === 3){ // text node
          const div = document.createElement('div');
          div.className = 'line action';
          div.dataset.t = 'action';
          div.textContent = (n.textContent || '').trim();
          normalized.push(div);
          changed = true;
        } else if (n.nodeType === 1){ // element
          if (n.classList.contains('line')) {
            if (!n.dataset.t) n.dataset.t = 'action';
            normalized.push(n);
          } else if (n.tagName === 'BR') {
            const div = document.createElement('div');
            div.className = 'line action';
            div.dataset.t = 'action';
            div.textContent = '';
            normalized.push(div);
            changed = true;
          } else {
            const div = document.createElement('div');
            div.className = 'line action';
            div.dataset.t = 'action';
            div.textContent = n.textContent || '';
            normalized.push(div);
            changed = true;
          }
        }
      }

      if (!changed && normalized.length === children.length) return;

      editor.innerHTML = '';
      normalized.forEach(d=>editor.appendChild(d));
    }

    function syncActiveScene(autoDetect = true){
      const scene = getActiveScene();
      if (!scene) return;
      project.settings = project.settings || {};
      normalizeEditorLines();
      if (autoDetect && project.settings.smartFormat) autoDetectTypes();
      const nodes = Array.from(document.querySelectorAll('#editor .line'));
      scene.elements = nodes.map(n=>({ t:n.dataset.t || 'action', txt:n.textContent }));
      updateSceneHash(scene);
      bumpVersion();
      updateCounters();
      scheduleSave();
      scheduleBackup();
    }

    function renderCatalogs(){
      const charContainer = document.getElementById('characterList');
      if (charContainer){
        charContainer.innerHTML = '';
        if (!project.catalogs.characters.length){
          const empty = document.createElement('p');
          empty.className = 'muted-text';
          empty.textContent = 'No characters yet.';
          charContainer.appendChild(empty);
        } else {
          project.catalogs.characters.forEach(char => {
            const row = document.createElement('div');
            row.className = 'catalog-item';
            const name = document.createElement('span');
            name.textContent = char.name || '';
            const actions = document.createElement('div');
            actions.className = 'catalog-actions';
            const insertBtn = document.createElement('button');
            insertBtn.textContent = 'Insert';
            insertBtn.addEventListener('click', ()=>{
              insertLine('character', char.name || '');
              setRightTab('write');
            });
            const delBtn = document.createElement('button');
            delBtn.textContent = 'Delete';
            delBtn.addEventListener('click', ()=>{
              removeCharacter(char.id);
            });
            actions.appendChild(insertBtn);
            actions.appendChild(delBtn);
            row.appendChild(name);
            row.appendChild(actions);
            charContainer.appendChild(row);
          });
        }
      }

      const setContainer = document.getElementById('setList');
      if (setContainer){
        setContainer.innerHTML = '';
        if (!project.catalogs.locations.length){
          const empty = document.createElement('p');
          empty.className = 'muted-text';
          empty.textContent = 'No locations yet.';
          setContainer.appendChild(empty);
        } else {
          project.catalogs.locations.forEach(loc => {
            const row = document.createElement('div');
            row.className = 'catalog-item';
            const name = document.createElement('span');
            name.textContent = loc.name || '';
            const actions = document.createElement('div');
            actions.className = 'catalog-actions';
            const delBtn = document.createElement('button');
            delBtn.textContent = 'Delete';
            delBtn.addEventListener('click', ()=>{
              removeLocation(loc.id);
            });
            actions.appendChild(delBtn);
            row.appendChild(name);
            row.appendChild(actions);
            setContainer.appendChild(row);
          });
        }
      }
    }

    function renderSoundList(){
      const container = document.getElementById('soundList');
      if (!container) return;
      container.innerHTML = '';
      const scene = getActiveScene();
      if (!scene){
        const empty = document.createElement('p');
        empty.className = 'muted-text';
        empty.textContent = 'No scene selected.';
        container.appendChild(empty);
        return;
      }
      if (!scene.sounds.length){
        const empty = document.createElement('p');
        empty.className = 'muted-text';
        empty.textContent = 'No sound cues yet.';
        container.appendChild(empty);
        return;
      }
      scene.sounds.forEach(sound => {
        const row = document.createElement('div');
        row.className = 'sound-item';
        const label = document.createElement('span');
        label.textContent = sound.cue || '';
        const btn = document.createElement('button');
        btn.textContent = 'Delete';
        btn.addEventListener('click', ()=> removeSoundCue(sound.id));
        row.appendChild(label);
        row.appendChild(btn);
        container.appendChild(row);
      });
    }

    function renderTimeline(){
      const list = document.getElementById('timelineList');
      if (!list) return;
      list.innerHTML = '';
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      if (!scenes.length){
        const empty = document.createElement('p');
        empty.className = 'timeline-empty';
        empty.textContent = 'No scenes yet.';
        list.appendChild(empty);
        return;
      }
      scenes.forEach((scene, idx)=>{
        const item = document.createElement('button');
        item.type = 'button';
        item.className = 'timeline-item' + (scene.id === activeSceneId ? ' active' : '');
        const beats = Array.isArray(scene.cards) ? scene.cards.length : 0;
        const metaText = beats ? `${beats} beat${beats === 1 ? '' : 's'}` : 'No beats tagged';
        item.innerHTML = `
          <div class="timeline-bullet">${idx + 1}</div>
          <div class="timeline-body">
            <strong>${escapeHtml(scene.slug || '(no slug)')}</strong>
            <span class="timeline-meta">${escapeHtml(metaText)}</span>
          </div>`;
        item.addEventListener('click', ()=>{
          activeSceneId = scene.id;
          setRightTab('write');
          render();
        });
        list.appendChild(item);
      });
    }

    function updateDeleteSceneButton(){
      const btn = document.getElementById('deleteSceneBtn');
      if (btn) btn.disabled = project.scenes.length <= 1;
    }

    /* =========================
     * Catalog helpers
     * =======================*/
    function addCharacter(name){
      const trimmed = (name || '').trim();
      if (!trimmed) return;
      project.catalogs = project.catalogs || {};
      project.catalogs.characters = project.catalogs.characters || [];
      project.catalogs.characters.push({ id: crypto.randomUUID(), name: trimmed });
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
    }

    function removeCharacter(id){
      project.catalogs = project.catalogs || {};
      project.catalogs.characters = (project.catalogs.characters || []).filter(c=>c.id !== id);
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
    }

    function addLocation(name){
      const trimmed = (name || '').trim();
      if (!trimmed) return;
      project.catalogs = project.catalogs || {};
      project.catalogs.locations = project.catalogs.locations || [];
      project.catalogs.locations.push({ id: crypto.randomUUID(), name: trimmed });
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
    }

    function removeLocation(id){
      project.catalogs = project.catalogs || {};
      project.catalogs.locations = (project.catalogs.locations || []).filter(l=>l.id !== id);
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
    }

    function addSoundCue(text){
      const scene = getActiveScene();
      if (!scene) return;
      const trimmed = (text || '').trim();
      if (!trimmed) return;
      scene.sounds = scene.sounds || [];
      scene.sounds.push({ id: crypto.randomUUID(), cue: trimmed });
      updateSceneHash(scene);
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
    }

    function removeSoundCue(id){
      const scene = getActiveScene();
      if (!scene) return;
      scene.sounds = (scene.sounds || []).filter(s=>s.id !== id);
      updateSceneHash(scene);
      bumpVersion();
      scheduleSave(); scheduleBackup();
      render();
    }

    function setSceneSlugPart(kind, value){
      const input = document.getElementById('sceneSlug');
      const scene = getActiveScene();
      if (!input || !scene) return;
      const upperValue = (value || '').toUpperCase();
      let slug = (input.value || scene.slug || '').toUpperCase();
      if (kind === 'prefix'){
        slug = slug.replace(/^(INT\.|EXT\.|INT-EXT\.|INT\/EXT\.)\s*/, '');
        slug = slug.replace(/^\s+/, '');
        slug = `${upperValue} ${slug}`.trim();
      } else if (kind === 'suffix'){
        slug = slug.replace(/\s*-\s*(DAY|NIGHT)$/i, '').trim();
        slug = slug ? `${slug} - ${upperValue}` : upperValue;
      }
      slug = slug.replace(/\s+/g, ' ').trim();
      input.value = slug;
      input.dispatchEvent(new Event('input', { bubbles: true }));
    }

    /* =========================
     * Scene helpers
     * =======================*/
    function getActiveScene(){ return project.scenes.find(s=>s.id===activeSceneId); }
    function addScene(){
      const s = {
        id: crypto.randomUUID(),
        slug: 'EXT. NEW PLACE - DAY',
        cards: [],
        elements: [{t:'action', txt:'...'}],
        color: '#8ab4f8',
        notes: '',
        sounds: []
      };
      project.scenes.push(s);
      project._hashes.scene[s.id] = hashString(stableSceneString(s));
      activeSceneId = s.id;
      bumpVersion();
      render();
      scheduleSave(); scheduleBackup();
    }
    function deleteScene(id){
      const idx = project.scenes.findIndex(s=>s.id===id);
      if (idx >= 0) {
        project.scenes.splice(idx,1);
        delete project._hashes.scene[id];
        if (!project.scenes.length){
          addScene();
          return;
        }
        if (activeSceneId === id) activeSceneId = project.scenes[0]?.id || null;
        bumpVersion(); render(); scheduleSave(); scheduleBackup();
      }
    }
    function updateSceneHash(scene){
      project._hashes = project._hashes || { scene: {} };
      project._hashes.scene[scene.id] = hashString(stableSceneString(scene));
    }

    /* =========================
     * Counters & Utilities
     * =======================*/
    function updateCounters(){
      const scenes = Array.isArray(project?.scenes) ? project.scenes : [];
      const text = scenes.flatMap(s=>s.elements.map(e=>e.txt)).join(' ');
      const words = (text.match(/\b\w+\b/g)||[]).length;
      const lines = scenes.reduce((acc,s)=>acc + s.elements.length, 0);
      const pages = Math.max(1, Math.round(lines / 55));
      document.getElementById('counter').textContent = `${pages} pages • ${words} words`;
      const sceneCountEl = document.getElementById('statSceneCount');
      if (sceneCountEl) sceneCountEl.textContent = scenes.length;
      const pageEl = document.getElementById('statPageCount');
      if (pageEl) pageEl.textContent = pages;
      const wordEl = document.getElementById('statWordCount');
      if (wordEl) wordEl.textContent = words;
      const lineEl = document.getElementById('statLineCount');
      if (lineEl) lineEl.textContent = lines;
    }
    function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;' }[m])); }

    /* Theme */
    function applyTheme(){
      const fallback = (typeof window.getSiteTheme === 'function') ? window.getSiteTheme() : (document.documentElement.dataset.theme || 'dark');
      const theme = project.settings.theme || fallback || 'dark';
      project.settings.theme = theme;
      if (typeof window.setSiteTheme === 'function'){
        window.setSiteTheme(theme);
      } else {
        document.documentElement.dataset.theme = theme;
        document.documentElement.style.colorScheme = theme;
      }
    }

    /* =========================
     * Editor interactions
     * =======================*/
    const editorEl = document.getElementById('editor');

    function getActiveLineNode(){
      const sel = window.getSelection();
      if (!sel || !sel.anchorNode) return null;
      let n = sel.anchorNode.nodeType === 3 ? sel.anchorNode.parentElement : sel.anchorNode;
      return n?.closest?.('.line') || null;
    }
    function markActiveLine(){
      document.querySelectorAll('#editor .line.active').forEach(el=>el.classList.remove('active'));
      const line = getActiveLineNode();
      if (line) line.classList.add('active');
    }
    function centerActiveLine(){
      const editor = document.getElementById('editor');
      const line = getActiveLineNode();
      if (!editor || !line) return;
      const rect = line.getBoundingClientRect();
      const parentRect = editor.getBoundingClientRect();
      const lineMid = rect.top + rect.height/2;
      const parentMid = parentRect.top + parentRect.height/2;
      const delta = lineMid - parentMid;
      editor.scrollTop += delta;
    }

    function placeCaret(node){
      if (!node) return;
      const editor = document.getElementById('editor');
      if (editor) editor.focus();
      const range = document.createRange();
      range.selectNodeContents(node);
      range.collapse(false);
      const sel = window.getSelection();
      if (!sel) return;
      sel.removeAllRanges();
      sel.addRange(range);
    }

    function insertLine(type, preset=''){
      const editor = document.getElementById('editor');
      if (!editor) return;
      const node = document.createElement('div');
      node.className = 'line ' + type;
      node.dataset.t = type;
      let text = preset || '';
      if (type === 'character' && text) text = text.toUpperCase();
      if (text) node.textContent = text;
      else node.innerHTML = '<br>';
      const active = getActiveLineNode();
      if (active && active.parentElement === editor) active.after(node);
      else editor.appendChild(node);
      placeCaret(node);
      syncActiveScene(false);
      markActiveLine();
      if (document.body.classList.contains('focus-mode')) centerActiveLine();
    }

    document.getElementById('editor').addEventListener('input', ()=>{
      syncActiveScene();
      markActiveLine();
      if (document.body.classList.contains('focus-mode')) centerActiveLine();
    });

    document.getElementById('editor').addEventListener('keydown', (e)=>{
      if (e.key === 'Enter') {
        setTimeout(()=>{
          syncActiveScene();
          markActiveLine();
          if (document.body.classList.contains('focus-mode')) centerActiveLine();
        }, 0);
      }
    });

    document.getElementById('editor').addEventListener('click', ()=>{
      markActiveLine();
      if (document.body.classList.contains('focus-mode')) centerActiveLine();
    });

    /* Auto type-detection */
    function autoDetectTypes(){
      const nodes = Array.from(document.querySelectorAll('#editor .line'));
      nodes.forEach(n=>{
        const text = (n.textContent||'').trim();
        let t = n.dataset.t;
        if (/^(INT|EXT|INT\/EXT|INT-EXT)\./i.test(text)) t = 'slug';
        else if (/^[A-Z0-9 .'-]{2,}$/.test(text) && text.length < 40) t = 'character';
        else if (/^\(.+\)$/.test(text)) t = 'parenthetical';
        else if (/^(CUT TO:|FADE OUT\.?|FADE IN\.?|SMASH CUT:|DISSOLVE TO:)/i.test(text)) t = 'transition';
        else if (!t || ['slug','character','parenthetical','transition'].includes(t)) t = 'action';
        n.className = 'line ' + t;
        n.dataset.t = t;
      });
    }

    /* =========================
     * Notes + meta bindings
     * =======================*/
    document.querySelectorAll('[data-tab-btn]').forEach(btn=>{
      btn.addEventListener('click', ()=> setRightTab(btn.dataset.tabBtn));
    });
    document.querySelectorAll('[data-slug-prefix]').forEach(btn=>{
      btn.addEventListener('click', ()=> setSceneSlugPart('prefix', btn.dataset.slugPrefix));
    });
    document.querySelectorAll('[data-slug-suffix]').forEach(btn=>{
      btn.addEventListener('click', ()=> setSceneSlugPart('suffix', btn.dataset.slugSuffix));
    });
    document.querySelectorAll('[data-line-type]').forEach(btn=>{
      btn.addEventListener('click', ()=> insertLine(btn.dataset.lineType));
    });
    const deleteSceneBtn = document.getElementById('deleteSceneBtn');
    if (deleteSceneBtn){
      deleteSceneBtn.addEventListener('click', ()=>{
        if (project.scenes.length <= 1) return;
        const scene = getActiveScene();
        const ok = confirm(`Delete scene "${scene?.slug || 'Untitled Scene'}"?`);
        if (ok) deleteScene(activeSceneId);
      });
    }
    const addCharacterBtn = document.getElementById('addCharacterBtn');
    if (addCharacterBtn){
      addCharacterBtn.addEventListener('click', ()=>{
        const input = document.getElementById('newCharacterName');
        const value = input.value;
        addCharacter(value);
        const fresh = document.getElementById('newCharacterName');
        if (fresh){ fresh.value = ''; fresh.focus(); }
      });
    }
    const addSetBtn = document.getElementById('addSetBtn');
    if (addSetBtn){
      addSetBtn.addEventListener('click', ()=>{
        const input = document.getElementById('newSetName');
        const value = input.value;
        addLocation(value);
        const fresh = document.getElementById('newSetName');
        if (fresh){ fresh.value = ''; fresh.focus(); }
      });
    }
    const addSoundBtn = document.getElementById('addSoundBtn');
    if (addSoundBtn){
      addSoundBtn.addEventListener('click', ()=>{
        const input = document.getElementById('newSoundCue');
        const value = input.value;
        addSoundCue(value);
        const fresh = document.getElementById('newSoundCue');
        if (fresh){ fresh.value = ''; fresh.focus(); }
      });
    }

    applyActiveTabUI();

    document.getElementById('projectTitle').addEventListener('input', e=>{
      project.title = e.target.value;
      document.getElementById('title').textContent = project.title || 'Untitled Project';
      bumpVersion(); scheduleSave(); scheduleBackup();
    });
    document.getElementById('projectNotes').addEventListener('input', e=>{
      project.notes = e.target.value; bumpVersion(); scheduleSave(); scheduleBackup();
    });
    document.getElementById('sceneSlug').addEventListener('input', e=>{
      const s = getActiveScene(); if (!s) return;
      s.slug = e.target.value; bumpVersion(); updateSceneHash(s); render(); scheduleSave(); scheduleBackup();
    });
    document.getElementById('sceneColor').addEventListener('input', e=>{
      const s = getActiveScene(); if (!s) return;
      s.color = e.target.value; bumpVersion(); updateSceneHash(s); render(); scheduleSave(); scheduleBackup();
    });
    document.getElementById('smartFormat').addEventListener('change', e=>{
      project.settings.smartFormat = (e.target.value === 'true');
      bumpVersion(); scheduleSave();
    });
    document.getElementById('themeSel').addEventListener('change', e=>{
      project.settings.theme = e.target.value || 'dark';
      bumpVersion(); scheduleSave(); applyTheme();
    });

    document.addEventListener('themechange', e=>{
      const nextTheme = e.detail?.theme;
      if (!nextTheme || !project) return;
      if (project.settings.theme !== nextTheme){
        project.settings.theme = nextTheme;
        const sel = document.getElementById('themeSel');
        if (sel) sel.value = nextTheme;
        bumpVersion(); scheduleSave();
      } else {
        const sel = document.getElementById('themeSel');
        if (sel && sel.value !== nextTheme) sel.value = nextTheme;
      }
    });

    /* =========================
     * Export / Print
     * =======================*/
    function exportFountain(){
      let out = `Title: ${project.title||''}\n\n`;
      project.scenes.forEach(s=>{
        if (s.slug) out += s.slug.toUpperCase() + '\n';
        s.elements.forEach(el=>{
          if (el.t==='character') out += '\n' + el.txt.toUpperCase() + '\n';
          else if (el.t==='parenthetical') out += '('+el.txt+')\n';
          else if (el.t==='dialogue') out += el.txt + '\n';
          else if (el.t==='transition') out += '\n> '+el.txt.toUpperCase()+'\n';
          else out += '\n'+el.txt+'\n';
        });
        out += '\n';
      });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([out], {type:'text/plain'}));
      a.download = (project.title||'script') + '.fountain';
      a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    }
    function printPDF(){ window.print(); }

    /* =========================
     * Smart backup (delta/full)
     * =======================*/
    function buildDeltaOrFull(){
      const metaSig = metaSignature(project);
      const metaChanged = metaSig !== lastSerializedMetaHash;

      const known = project._hashes?.scene || {};
      const currentIds = new Set(project.scenes.map(s=>s.id));
      const upserts = [];
      const deletes = [];

      for (const s of project.scenes) {
        const hNow = hashString(stableSceneString(s));
        const hWas = known[s.id];
        if (!hWas || hWas !== hNow) upserts.push(s);
      }
      for (const oldId of Object.keys(known)) {
        if (!currentIds.has(oldId)) deletes.push(oldId);
      }

      const delta = {
        projectId: project.projectId,
        version: project.version,
        meta: metaChanged ? { title: project.title, settings: project.settings, notes: project.notes } : undefined,
        upserts: upserts.length ? upserts : undefined,
        deletes: deletes.length ? deletes : undefined
      };
      const deltaStr = JSON.stringify(delta);
      const deltaBytes = new Blob([deltaStr]).size;

      const needFull =
        project._deltaCountSinceFull >= FULL_SNAPSHOT_EVERY ||
        deltaBytes > MAX_DELTA_BYTES ||
        (project._lastBackedUpVersion === 0);

      if (needFull) {
        const fullData = structuredClone(project);
        delete fullData._hashes;
        delete fullData._lastBackedUpVersion;
        delete fullData._deltaCountSinceFull;
        const fullStr = JSON.stringify(fullData);
        const fullBytes = new Blob([fullStr]).size;
        return { kind: 'full', bytes: fullBytes, data: fullData, metaSig };
      } else {
        return { kind: 'delta', bytes: deltaBytes, data: delta, metaSig };
      }
    }

    function scheduleSave(){
      clearTimeout(saveTimer);
      saveTimer = setTimeout(async ()=>{
        await saveLocal(project);
      }, 500);
    }

    function scheduleBackup(){
      clearTimeout(backupTimer);
      backupTimer = setTimeout(backupSmart, BACKUP_IDLE_MS);
    }

    function backupSmart(){
      // In Apps Script context this will exist; in canvas preview it won't.
      if (!(window.google && google.script && google.script.run)) return;
      const pack = buildDeltaOrFull();

      google.script.run
        .withSuccessHandler(res=>{
          if (pack.kind === 'full') project._deltaCountSinceFull = 0;
          else project._deltaCountSinceFull = (project._deltaCountSinceFull || 0) + 1;

          project._lastBackedUpVersion = project.version;
          lastSerializedMetaHash = pack.metaSig || lastSerializedMetaHash;

          if (pack.kind === 'full') {
            project._hashes.scene = {};
            project.scenes.forEach(s=>{
              project._hashes.scene[s.id] = hashString(stableSceneString(s));
            });
          } else {
            (pack.data.upserts || []).forEach(s=>{
              project._hashes.scene[s.id] = hashString(stableSceneString(s));
            });
            (pack.data.deletes || []).forEach(id=> delete project._hashes.scene[id]);
          }
          saveLocal(project);
        })
        .withFailureHandler(err=>{
          console.error('Backup failed:', err);
        })
        .SW_backupProjectDelta({
          projectId: project.projectId,
          version: project.version,
          kind: pack.kind,
          bytes: pack.bytes,
          data: pack.data
        });
    }

    function backupNow(){ clearTimeout(backupTimer); backupSmart(); }

    /* =========================
     * Restore (client-side)
     * =======================*/
    function openRestore(){
      if (!(window.google && google.script && google.script.run)) { alert('Restore unavailable outside Apps Script.'); return; }
      google.script.run
        .withSuccessHandler(rows=>{
          if (!rows || !rows.length){ alert('No backups found.'); return; }
          const preview = rows.slice(0, 20).map((r,i)=> `${i}. ${r.kind.toUpperCase()} • v${r.version} • ${r.timestamp}`).join('\n');
          const choice = prompt('Choose entry # (0..19):\n' + preview, '0');
          const idx = Number(choice);
          if (isNaN(idx) || idx < 0 || idx >= Math.min(20, rows.length)) return;
          const subset = rows.slice(0, idx+1); // 0 is newest
          let fullIdx = -1;
          for (let i = subset.length-1; i >= 0; i--) {
            if (subset[i].kind === 'full'){ fullIdx = i; break; }
          }
          if (fullIdx === -1){ alert('No full snapshot found in selection window. Try choosing an older entry.'); return; }
          let state = JSON.parse(subset[fullIdx].payloadJSON);
          for (let i = fullIdx-1; i >= 0; i--){
            const entry = subset[i];
            if (entry.kind === 'delta') applyDeltaClient(state, JSON.parse(entry.payloadJSON));
          }
          project = state;
          project._hashes = { scene: {} };
          project.scenes.forEach(s => project._hashes.scene[s.id] = hashString(stableSceneString(s)));
          project._lastBackedUpVersion = project.version || 0;
          project._deltaCountSinceFull = 0;
          lastSerializedMetaHash = metaSignature(project);
          saveLocal(project);
          activeSceneId = project.scenes[0]?.id || null;
          render();
          alert('Restored to version ' + (project.version || '?'));
        })
        .withFailureHandler(err=> alert('Failed to load backups: ' + err))
        .SW_loadBackups(project.projectId, 200);
    }

    function applyDeltaClient(state, delta){
      if (delta.meta) {
        if (Object.prototype.hasOwnProperty.call(delta.meta, 'title')) state.title = delta.meta.title;
        if (Object.prototype.hasOwnProperty.call(delta.meta, 'notes')) state.notes = delta.meta.notes;
        if (delta.meta.settings) state.settings = Object.assign({}, state.settings || {}, delta.meta.settings);
      }
      const byId = new Map((state.scenes||[]).map(s => [s.id, s]));
      (delta.upserts || []).forEach(s => byId.set(s.id, s));
      (delta.deletes || []).forEach(id => byId.delete(id));
      state.scenes = Array.from(byId.values());
      if (typeof delta.version === 'number') state.version = Math.max(state.version || 0, delta.version);
    }

    /* =========================
     * Focus Mode
     * =======================*/
    function applyFocusModeUI(){
      const focused = !!project?.settings?.focus;
      document.body.classList.toggle('focus-mode', focused);
      const btn = document.getElementById('focusBtn');
      if (btn) btn.textContent = focused ? 'Exit Focus' : 'Focus';
      updateHud();
      markActiveLine();
      if (focused) centerActiveLine();
    }
    function toggleFocus(){
      project.settings = project.settings || {};
      project.settings.focus = !project.settings.focus;
      saveLocal(project);
      applyFocusModeUI();
    }
    function updateHud(){
      const hudC = document.getElementById('hudCounter');
      const hudSel = document.getElementById('hudScenePicker');
      if (hudC) hudC.textContent = document.getElementById('counter')?.textContent || '';
      if (hudSel){
        hudSel.innerHTML = '';
        project.scenes.forEach((s, i)=>{
          const opt = document.createElement('option');
          opt.value = s.id;
          opt.textContent = `${String(i+1).padStart(2,'0')} • ${s.slug || '(no slug)'}`;
          if (s.id === activeSceneId) opt.selected = true;
          hudSel.appendChild(opt);
        });
      }
    }
    function pickSceneFromHud(sceneId){
      if (!sceneId) return;
      activeSceneId = sceneId;
      render();
      const hudSel = document.getElementById('hudScenePicker');
      if (hudSel) hudSel.value = sceneId;
      markActiveLine();
      if (document.body.classList.contains('focus-mode')) centerActiveLine();
    }

    /* =========================
     * Pomodoro (Focus HUD)
     * =======================*/
    const POMO_DEFAULTS = { workMin: 25, breakMin: 5, autoStartBreak: true, autoStartWork: false };
    let pomo = { running: false, mode: 'work', endAt: 0, remainingMs: 25*60*1000, _timerId: null };

    function ensurePomodoroSettings(){
      project.settings = project.settings || {};
      project.settings.pomodoro = Object.assign({}, POMO_DEFAULTS, project.settings.pomodoro || {});
      if (!pomo || typeof pomo.remainingMs !== 'number') {
        pomo = {
          running: false, mode: 'work', endAt: 0,
          remainingMs: project.settings.pomodoro.workMin * 60 * 1000,
          _timerId: null
        };
      }
    }
    function fmtMMSS(ms){
      ms = Math.max(0, ms|0);
      const s = Math.round(ms/1000);
      const mm = String(Math.floor(s/60)).padStart(2,'0');
      const ss = String(s%60).padStart(2,'0');
      return `${mm}:${ss}`;
    }
    function updatePomodoroUI(){
      const dial = document.getElementById('pomoTime');
      const modeEl = document.getElementById('pomoMode');
      const ring = dial?.parentElement;
      const tog = document.getElementById('pomoToggle');
      if (!dial || !modeEl || !ring || !tog) return;

      dial.textContent = fmtMMSS(pomo.remainingMs);
      modeEl.textContent = pomo.mode === 'work' ? 'Work' : 'Break';

      const total = (pomo.mode === 'work'
        ? project.settings.pomodoro.workMin
        : project.settings.pomodoro.breakMin) * 60 * 1000;
      const pct = 100 * (1 - (pomo.remainingMs / total));
      ring.style.setProperty('--pct', Math.max(0, Math.min(100, pct)));

      tog.textContent = pomo.running ? 'Pause' : 'Start';

      project._pomoState = { running: pomo.running, mode: pomo.mode, remainingMs: pomo.remainingMs, endAt: pomo.endAt };
      saveLocal(project);
    }
    function startPomodoroTick(){
      stopPomodoroTick();
      pomo.running = true;
      if (pomo.endAt <= Date.now()) pomo.endAt = Date.now() + pomo.remainingMs;
      pomo._timerId = setInterval(()=>{
        const now = Date.now();
        pomo.remainingMs = Math.max(0, pomo.endAt - now);
        updatePomodoroUI();
        if (pomo.remainingMs <= 0) {
          stopPomodoroTick();
          onPomodoroEnd();
        }
      }, 250);
      updatePomodoroUI();
    }
    function stopPomodoroTick(){
      pomo.running = false;
      if (pomo._timerId) clearInterval(pomo._timerId);
      pomo._timerId = null;
      if (pomo.endAt > 0) pomo.remainingMs = Math.max(0, pomo.endAt - Date.now());
      updatePomodoroUI();
    }
    function togglePomodoro(){ if (pomo.running) stopPomodoroTick(); else startPomodoroTick(); }
    function resetPomodoro(){
      const mins = (pomo.mode === 'work' ? project.settings.pomodoro.workMin : project.settings.pomodoro.breakMin);
      pomo.remainingMs = mins * 60 * 1000; pomo.endAt = 0; updatePomodoroUI();
    }
    function switchPomodoroMode(nextMode){
      pomo.mode = nextMode;
      const mins = (pomo.mode === 'work' ? project.settings.pomodoro.workMin : project.settings.pomodoro.breakMin);
      pomo.remainingMs = mins * 60 * 1000; pomo.endAt = 0; updatePomodoroUI();
    }
    function beep(){
      try{
        const ctx = new (window.AudioContext||window.webkitAudioContext)();
        const o = ctx.createOscillator(); const g = ctx.createGain();
        o.type = 'sine'; o.frequency.value = 880; o.connect(g); g.connect(ctx.destination);
        g.gain.setValueAtTime(0.001, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime + 0.01);
        o.start();
        setTimeout(()=>{ g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.05); o.stop(ctx.currentTime + 0.08); }, 180);
      }catch(e){}
    }
    function onPomodoroEnd(){
      beep();
      if (pomo.mode === 'work') {
        switchPomodoroMode('break');
        if (project.settings.pomodoro.autoStartBreak) startPomodoroTick();
      } else {
        switchPomodoroMode('work');
        if (project.settings.pomodoro.autoStartWork) startPomodoroTick();
      }
    }

    /* =========================
     * Shortcuts
     * =======================*/
    document.addEventListener('keydown', (e)=>{
      const cmd = e.metaKey || e.ctrlKey;
      if (cmd && e.key.toLowerCase() === 'k') { e.preventDefault(); toggleFocus(); return; }
      if (cmd && e.key === ';') { e.preventDefault(); togglePomodoro(); return; }
      if (cmd && e.key === "'") { e.preventDefault(); resetPomodoro(); return; }
    });

    /* =========================
     * Versioning helpers
     * =======================*/
    function bumpVersion(){ project.version = (project.version || 0) + 1; project.updatedAt = Date.now(); }

    /* =========================
     * Self-tests (basic) — won't change user data
     * =======================*/
    function runSelfTests(){
      try {
        // Theme switch test
        const prevTheme = project.settings.theme;
        project.settings.theme = 'light'; applyTheme();
        const lightBg = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim();
        console.assert(lightBg === '#f7f9fc', 'Light theme var not applied');
        project.settings.theme = 'dark'; applyTheme();
        const darkBg = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim();
        console.assert(darkBg === '#0b0f14', 'Dark theme var not applied');
        // Build delta/full doesn't throw
        const pack = buildDeltaOrFull();
        console.assert(pack && (pack.kind==='delta'||pack.kind==='full'), 'buildDeltaOrFull returned invalid kind');
        // Focus HUD exists
        console.assert(document.getElementById('focusHud'), 'focusHud missing');
        console.log('Self-tests passed');
      } catch (err) {
        console.error('Self-tests failed', err);
      }
    }

    /* =========================
     * Bootstrap
     * =======================*/
    (async function init(){
      await openDB();

      // Load last project if exists
      const lastId = getLastProjectId();
      if (lastId) {
        const loaded = await loadLocal(lastId);
        if (loaded) {
          project = loaded;
          activeSceneId = project.scenes?.[0]?.id || null;
        } else {
          newProject();
          await saveLocal(project);
        }
      } else {
        newProject();
        await saveLocal(project);
      }

      project.settings = project.settings || {};
      if (typeof project.settings.focus === 'undefined') project.settings.focus = false;

      ensurePomodoroSettings();
      if (project._pomoState) {
        pomo = Object.assign({}, pomo, project._pomoState);
        if (!['work','break'].includes(pomo.mode)) pomo.mode = 'work';
      }

      lastSerializedMetaHash = metaSignature(project);
      render();
      applyFocusModeUI();
      updatePomodoroUI();
      setTimeout(runSelfTests, 0);
    })();
    </script>
  </main>

  <footer class="footer">
    <div class="footer__grid">
      <div><strong>StudioOrganize</strong></div>
      <div><a href="/products/">Products</a></div>
      <div><a href="mailto:support@studioorganize.com">support@studioorganize.com</a><br/><span class="muted">© <span id="y"></span> StudioOrganize</span></div>
    </div>
  </footer>
  <script src="/assets/main.js"></script>
</body>
</html>
