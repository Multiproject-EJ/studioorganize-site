<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Storyboard Pro ‚Äî StudioOrganize</title>
  <meta
    name="description"
    content="Storyboard Pro timelines keep scenes, shots, and production teams aligned with the StudioOrganize writer."
  />
  <link rel="stylesheet" href="/assets/styles.css" />
  <link rel="icon" type="image/webp" href="/assets/img/studioorganizeFavicon.webp" />
</head>
<body>
  <header class="nav">
    <div class="brand-with-logo">
      <a class="brand" href="/">StudioOrganize</a>
      <span class="brand-with-logo__badge brand-with-logo__badge--storyboard" aria-hidden="true">SB</span>
    </div>
    <nav class="menu">
      <a class="menu__link menu__link--plain menu__link--icon" href="/">
        <span aria-hidden="true">üè†</span>
        <span class="sr-only">Home</span>
      </a>
      <div class="dropdown">
        <button class="dropbtn dropbtn--plain" type="button">Use Cases</button>
        <div class="dropdown-content">
          <a href="/use-cases/">All Use Cases</a>
          <a href="/use-cases/generate-ideas.html">Generate Ideas</a>
          <a href="/use-cases/screenplay.html">Screenplay Script</a>
          <a href="/use-cases/character-design.html">Character Design</a>
          <a href="/use-cases/set-design.html">Set / Production Design</a>
        </div>
      </div>
      <a class="menu__link menu__link--plain" href="https://finishthatstory.com" target="_blank" rel="noopener noreferrer">FinishThatStory.com</a>
      <div class="menu__actions">
        <button class="theme-toggle theme-toggle--icon" type="button" data-theme-toggle aria-pressed="false">
          <span class="sr-only">Toggle theme</span>
          <span class="theme-toggle__icon" aria-hidden="true" data-theme-icon>‚òÄÔ∏è</span>
        </button>
        <a class="menu__cta" href="https://studioorganize.com/supabase-test.html" data-auth-link>Sign up / Log in</a>
        <div class="dropdown" data-account-menu hidden>
          <button class="menu__cta" type="button" data-account-button>Account</button>
          <div class="dropdown-content">
            <a href="/account.html">My Creator Page</a>
            <a href="/product/personal.html">My Subscription</a>
            <a href="#" data-account-logout>Log out</a>
          </div>
        </div>
      </div>
    </nav>
  </header>

  <main class="section">
    <style>
      html, body { height: 100%; font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Arial; }
      body {
        color: var(--ink);
        background: radial-gradient(circle at top right, rgba(79,123,255,0.08), transparent 35%), var(--surface);
        --nav-height: 72px;
      }
      main.section { flex: 1; display: flex; flex-direction: column; width: 100%; max-width: none; padding: 0; margin: 0; }
      .app { display: grid; grid-template-rows: 56px 1fr; flex: 1; min-height: 0; transition: transform .35s ease; }
      .topbar { display: flex; align-items: center; gap: 12px; padding: 10px 16px; background: var(--panel); border-bottom: 1px solid var(--ring); }
      .topbar h1 { font-size: 18px; font-weight: 600; margin: 0; letter-spacing: 0.1px; }
      .topbar .badge { font-size: 11px; letter-spacing: .3px; text-transform: uppercase; background: rgba(79,123,255,0.12); color: var(--acc); border: 1px solid rgba(79,123,255,0.4); border-radius: 999px; padding: 3px 8px; }
      .spacer { flex: 1; }
      .btn {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        background: var(--chip);
        color: var(--ink);
        border: 1px solid var(--ring);
        border-radius: 10px;
        padding: 8px 12px;
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        line-height: 1.2;
        transition: background .2s ease, color .2s ease, border-color .2s ease, box-shadow .2s ease;
      }
      .btn:hover { border-color: var(--acc); }
      .btn:focus-visible { outline: none; border-color: var(--acc); box-shadow: 0 0 0 2px rgba(79,123,255,0.18); }
      .btn.active { background: var(--acc); border-color: var(--acc); color: var(--active-tab-text); font-weight: 600; }
      .btn.btn-primary { background: var(--acc); border-color: var(--acc); color: var(--active-tab-text); font-weight: 600; }
      .topbar-group { display: flex; gap: 6px; align-items: center; }
      .layout { display: grid; grid-template-columns: 280px 1fr 320px; gap: 12px; padding: 16px; min-height: 0; }
      .panel { background: var(--panel); border: 1px solid var(--ring); border-radius: 14px; overflow: hidden; display: flex; flex-direction: column; min-height: 0; }
      .panel h2 { font-size: 13px; font-weight: 600; letter-spacing: .4px; color: var(--muted); margin: 12px 16px 8px; text-transform: uppercase; }
      .panel-body { flex: 1; padding: 0 16px 16px; overflow: auto; }
      .scene-list { display: flex; flex-direction: column; gap: 10px; }
      .scene-card { background: var(--card); border: 1px solid var(--ring); border-radius: 12px; padding: 12px; display: flex; flex-direction: column; gap: 6px; cursor: pointer; transition: border-color .2s ease, transform .2s ease; outline: none; position: relative; }
      .scene-card.active { border-color: var(--acc); box-shadow: 0 0 0 2px rgba(79,123,255,0.25); transform: translateY(-1px); }
      .scene-card small { color: var(--muted); font-size: 12px; }
      .scene-card-label { display: flex; align-items: center; gap: 8px; font-weight: 600; letter-spacing: .2px; width: 100%; }
      .scene-card-label span.scene-card-color { display: inline-flex; width: 14px; height: 14px; border-radius: 50%; background: linear-gradient(135deg, #4f7bff, #22d3ee); box-shadow: inset 0 0 0 2px rgba(255,255,255,0.55); }
      .scene-card-label-display { display: inline-flex; align-items: baseline; gap: 4px; flex: 1; min-width: 0; }
      .scene-card-label-display strong { font-size: 13px; font-weight: 600; }
      .scene-card-label-display span[data-scene-card-name] { font-weight: 600; }
      .scene-card-label-display span.scene-card-separator { opacity: 0.5; margin: 0 2px; }
      .scene-card-input { display: none; flex: 1; min-width: 0; border-radius: 8px; border: 1px solid var(--ring); background: var(--chip); color: var(--ink); padding: 6px 8px; font-size: 13px; font-weight: 500; }
      .scene-card.editing { cursor: text; }
      .scene-card.editing .scene-card-label-display { display: none; }
      .scene-card.editing .scene-card-input { display: inline-flex; }
      .timeline-panel { padding: 0; }
      .timeline-stage { flex: 1; display: flex; flex-direction: column; min-height: 0; }
      .timeline-stage header { display: flex; align-items: center; justify-content: space-between; padding: 16px; border-bottom: 1px solid var(--ring); gap: 16px; }
      .timeline-stage header h2 { margin: 0; font-size: 15px; font-weight: 600; }
      .timeline-stage header span { font-size: 12px; color: var(--muted); }
      .timeline-controls { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
      .timeline-wrapper { flex: 1; overflow: auto; padding-bottom: 16px; }
      .timeline-grid { display: grid; grid-template-columns: 200px 1fr; min-width: 680px; }
      .timeline-scale { grid-column: 1 / -1; padding: 12px 24px; border-bottom: 1px solid var(--ring); background: linear-gradient(135deg, rgba(79,123,255,0.12), rgba(79,123,255,0)); position: sticky; top: 0; z-index: 2; }
      .timeline-scale__header { font-size: 12px; color: var(--muted); letter-spacing: .3px; text-transform: uppercase; margin-bottom: 10px; display: flex; justify-content: space-between; }
      .timeline-scale__ruler { position: relative; height: 28px; border-bottom: 1px dashed rgba(79,123,255,0.35); }
      .timeline-scale__ruler span { position: absolute; top: 8px; font-size: 11px; color: var(--muted); transform: translateX(-50%); }
      .timeline-scene { display: contents; }
      .timeline-scene__label { padding: 20px 16px; border-right: 1px solid var(--ring); background: var(--panel); display: flex; flex-direction: column; gap: 6px; position: sticky; left: 0; z-index: 1; }
      .timeline-scene__label strong { font-size: 14px; letter-spacing: .2px; }
      .timeline-scene__label span { font-size: 13px; }
      .timeline-scene__label small { font-size: 12px; color: var(--muted); }
      .timeline-scene.active .timeline-scene__label { box-shadow: inset 3px 0 0 var(--acc); }
      .timeline-scene__tracks { padding: 16px 24px; display: flex; flex-direction: column; gap: 14px; background: var(--card); border-bottom: 1px solid var(--ring); }
      .timeline-track { display: flex; flex-direction: column; gap: 6px; }
      .timeline-track__header { font-size: 11px; text-transform: uppercase; letter-spacing: .3px; color: var(--muted); }
      .timeline-track__lane { position: relative; background: var(--panel); border: 1px solid var(--ring); border-radius: 10px; height: 48px; overflow: hidden; }
      .timeline-track__lane::before { content: ""; position: absolute; inset: 0; background-image: repeating-linear-gradient(to right, transparent, transparent calc(12.5% - 1px), rgba(79,123,255,0.12) calc(12.5% - 1px), rgba(79,123,255,0.12) calc(12.5%)); pointer-events: none; }
      .timeline-block { position: absolute; top: 6px; bottom: 6px; border-radius: 8px; padding: 6px 10px; font-size: 12px; display: inline-flex; align-items: center; gap: 6px; color: rgba(15,23,42,0.9); font-weight: 500; }
      .timeline-block::before { content: attr(data-icon); font-size: 14px; }
      .timeline-block--shots { background: rgba(79,123,255,0.18); border: 1px solid rgba(79,123,255,0.35); }
      .timeline-block--audio { background: rgba(220,38,38,0.14); border: 1px solid rgba(220,38,38,0.3); }
      .timeline-block--lighting { background: rgba(14,165,233,0.18); border: 1px solid rgba(14,165,233,0.3); }
      .timeline-block--notes { background: rgba(126,58,242,0.16); border: 1px solid rgba(126,58,242,0.28); }
      .timeline-block--beats { background: rgba(16,185,129,0.18); border: 1px solid rgba(16,185,129,0.3); }
      .timeline-track--hidden { display: none; }
      .brand-with-logo__badge--storyboard { width: 36px; height: 36px; border-radius: 12px; display: inline-flex; align-items: center; justify-content: center; font-weight: 700; font-size: 14px; letter-spacing: .6px; background: linear-gradient(135deg, #1d4ed8, #22d3ee); color: white; box-shadow: 0 8px 24px rgba(30,64,175,0.35); }
      .panel.ai-panel { background: linear-gradient(135deg, rgba(79,123,255,0.08), rgba(34,211,238,0.08)), var(--panel); border-color: rgba(79,123,255,0.45); }
      .ai-panel header { padding: 16px; border-bottom: 1px solid rgba(79,123,255,0.25); }
      .ai-panel header h2 { margin: 0; font-size: 15px; font-weight: 600; }
      .ai-panel header p { margin: 6px 0 0; font-size: 13px; color: var(--muted); line-height: 1.5; }
      .ai-form { display: flex; flex-direction: column; gap: 12px; padding: 16px; }
      .ai-form label { font-size: 12px; letter-spacing: .3px; text-transform: uppercase; color: var(--muted); }
      .ai-form textarea, .ai-form input { width: 100%; border-radius: 12px; border: 1px solid var(--ring); background: var(--chip); color: var(--ink); padding: 10px 12px; font-size: 14px; resize: vertical; min-height: 96px; }
      .ai-form input { min-height: auto; }
      .ai-hint { font-size: 12px; color: var(--muted); line-height: 1.5; }
      .ai-status { font-size: 12px; letter-spacing: .3px; text-transform: uppercase; color: var(--acc); }
      .ai-actions { display: flex; align-items: center; gap: 8px; justify-content: flex-end; flex-wrap: wrap; }
      .ai-actions [data-api-manager] { margin-right: auto; }
      .ai-actions button[data-api-manager] { order: -1; }
      .ai-result { margin-top: 12px; background: var(--card); border: 1px solid var(--ring); border-radius: 12px; padding: 16px; display: none; flex-direction: column; gap: 12px; }
      .ai-result.active { display: flex; }
      .ai-result__heading { font-size: 13px; font-weight: 600; text-transform: uppercase; letter-spacing: .3px; color: var(--muted); margin: 0; }
      .ai-result__image { width: 100%; border-radius: 10px; border: 1px solid var(--ring); background: var(--chip); object-fit: cover; max-height: 320px; }
      .ai-result__meta { font-size: 12px; color: var(--muted); margin: 0; }
      .ai-result pre { margin: 0; padding: 12px; background: var(--panel); border-radius: 10px; overflow: auto; font-size: 12px; line-height: 1.5; max-height: 260px; }
      .ai-result__empty { font-size: 13px; color: var(--muted); }
      .api-dialog { border: none; border-radius: 18px; padding: 0; width: min(480px, 90vw); background: var(--panel); color: var(--ink); box-shadow: 0 30px 70px rgba(15,23,42,0.28); }
      .api-dialog[open] { display: block; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 50; }
      .api-dialog::backdrop { background: rgba(15,23,42,0.55); }
      .api-dialog__container { display: flex; flex-direction: column; gap: 16px; padding: 24px; }
      .api-dialog__header { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
      .api-dialog__header h2 { margin: 0; font-size: 18px; }
      .api-dialog__body { display: flex; flex-direction: column; gap: 16px; }
      .api-dialog label { font-size: 12px; letter-spacing: .3px; text-transform: uppercase; color: var(--muted); display: block; margin-bottom: 6px; }
      .api-dialog input { width: 100%; border-radius: 12px; border: 1px solid var(--ring); background: var(--chip); color: var(--ink); padding: 10px 12px; font-size: 14px; }
      .api-dialog__hint { font-size: 12px; color: var(--muted); margin: 4px 0 0; }
      .api-dialog__actions { display: flex; align-items: center; justify-content: flex-end; gap: 8px; }
      .api-dialog__feedback { font-size: 12px; color: var(--acc); margin-right: auto; min-height: 18px; }
      .api-dialog__close { border: none; background: transparent; color: inherit; font-size: 22px; line-height: 1; cursor: pointer; padding: 4px 8px; border-radius: 8px; }
      .api-dialog__close:hover { background: rgba(79,123,255,0.12); }
      .ai-form select { width: 100%; border-radius: 12px; border: 1px solid var(--ring); background: var(--chip); color: var(--ink); padding: 10px 12px; font-size: 14px; }
      .feature-section { padding: 36px 48px 72px; display: grid; gap: 24px; }
      .feature-section h2 { font-size: 26px; margin: 0; }
      .feature-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 20px; }
      .feature-card { background: var(--panel); border: 1px solid var(--ring); border-radius: 16px; padding: 20px; display: flex; flex-direction: column; gap: 10px; }
      .feature-card h3 { margin: 0; font-size: 16px; }
      .feature-card p { margin: 0; color: var(--muted); line-height: 1.5; }
      @media (max-width: 1280px) {
        .layout { grid-template-columns: 1fr; grid-template-rows: repeat(3, minmax(0, auto)); }
        .timeline-wrapper { max-height: 520px; }
        .panel.ai-panel { order: 3; }
      }
      @media (max-width: 720px) {
        .topbar { flex-wrap: wrap; }
        .layout { padding: 12px; }
        .timeline-grid { min-width: 560px; }
        .timeline-stage header { flex-direction: column; align-items: flex-start; }
        .timeline-controls { width: 100%; justify-content: space-between; }
      }
    </style>

    <div class="app">
      <div class="topbar">
        <h1>Storyboard Pro</h1>
        <span class="badge">Scene-synced timelines</span>
        <div class="spacer"></div>
        <div class="topbar-group" role="group" aria-label="Timeline track visibility">
          <button class="btn active" type="button" data-track-toggle="beats" aria-pressed="true">Beat grid</button>
          <button class="btn active" type="button" data-track-toggle="shots" aria-pressed="true">Shots</button>
          <button class="btn active" type="button" data-track-toggle="audio" aria-pressed="true">Audio</button>
          <button class="btn active" type="button" data-track-toggle="lighting" aria-pressed="true">Lighting</button>
          <button class="btn active" type="button" data-track-toggle="notes" aria-pressed="true">Notes</button>
        </div>
        <button class="btn" type="button" onclick="window.location.href='/use-cases/screenplay-writing.html#storyboardOverlay'">Open writer workspace</button>
      </div>

      <div class="layout">
        <aside class="panel">
          <h2>Scenes</h2>
          <div class="panel-body">
            <div class="scene-list" data-scene-list></div>
          </div>
        </aside>

        <section class="panel timeline-panel">
          <div class="timeline-stage">
            <header>
              <div>
                <h2 data-scene-title>Scene 13 ¬∑ Rooftop chase</h2>
                <span data-scene-meta>Linked to draft v4 ¬∑ 00:45 runtime ¬∑ 8 frames</span>
              </div>
              <div class="timeline-controls">
                <span class="muted">Timeline synced to script page 47</span>
              </div>
            </header>
            <div class="timeline-wrapper">
              <div class="timeline-grid" data-timeline-grid>
                <div class="timeline-scale" aria-hidden="true">
                  <div class="timeline-scale__header">
                    <span>Scene timeline (minutes)</span>
                    <span>Drag & drop clips to re-time</span>
                  </div>
                  <div class="timeline-scale__ruler">
                    <span style="left:0%">0:00</span>
                    <span style="left:12.5%">0:05</span>
                    <span style="left:25%">0:10</span>
                    <span style="left:37.5%">0:15</span>
                    <span style="left:50%">0:20</span>
                    <span style="left:62.5%">0:25</span>
                    <span style="left:75%">0:30</span>
                    <span style="left:87.5%">0:35</span>
                    <span style="left:100%">0:40</span>
                  </div>
                </div>
              </div>

            </div>
          </div>
        </section>

        <aside class="panel ai-panel">
          <header>
            <h2>Storyboard AI Companion</h2>
            <p>Feed scene context and characters to draft new frames that stay aligned with your script timing.</p>
          </header>
          <form class="ai-form">
            <div>
              <label for="aiShotPrompt">Shot prompt</label>
              <textarea id="aiShotPrompt" placeholder="Wide aerial reveals the neon skyline before pushing into the rooftop chase."></textarea>
            </div>
            <div>
              <label for="aiProvider">Image model</label>
              <select id="aiProvider">
                <option value="gemini">Gemini image</option>
                <option value="soara">Soara images</option>
              </select>
            </div>
            <div>
              <label for="aiFrameCount">Frame count</label>
              <input id="aiFrameCount" type="number" min="1" max="12" value="4" />
            </div>
            <p class="ai-hint">Character tokens and lighting notes auto-sync from the writer so your frames stay on model. Select a provider and store API keys to render previews.</p>
            <div class="ai-actions">
              <button class="btn" type="button" data-api-manager>Manage API keys</button>
              <span class="ai-status" data-ai-status>Ready</span>
              <button class="btn btn-primary" type="button" data-ai-generate>Generate preview</button>
            </div>
            <div class="ai-result" data-ai-result aria-live="polite"></div>
          </form>
        </aside>
      </div>
    </div>

    <dialog class="api-dialog" data-api-dialog aria-labelledby="apiDialogTitle">
      <form class="api-dialog__container" method="dialog" data-api-form>
        <div class="api-dialog__header">
          <h2 id="apiDialogTitle">AI API manager</h2>
          <button class="api-dialog__close" type="button" data-api-close aria-label="Close API manager">√ó</button>
        </div>
        <div class="api-dialog__body">
          <p>Store your Gemini and Soara API keys locally to test storyboard image generation. Keys are saved to this browser only.</p>
          <div>
            <label for="apiGeminiKey">Gemini API key</label>
            <input id="apiGeminiKey" type="password" placeholder="AIz..." autocomplete="off" data-api-gemini />
            <p class="api-dialog__hint">Create a key in Google AI Studio and enable the Gemini image endpoint.</p>
          </div>
          <div>
            <label for="apiSoaraKey">Soara API key</label>
            <input id="apiSoaraKey" type="password" placeholder="soara_..." autocomplete="off" data-api-soara />
            <p class="api-dialog__hint">Use your Soara developer dashboard to generate a token with image permissions.</p>
          </div>
        </div>
        <div class="api-dialog__actions">
          <span class="api-dialog__feedback" data-api-feedback role="status" aria-live="polite"></span>
          <button class="btn" type="button" data-api-close>Cancel</button>
          <button class="btn btn-primary" type="submit">Save keys</button>
        </div>
      </form>
    </dialog>

    <section class="feature-section">
      <h2>Storyboard Pro keeps every department locked to the same scene timeline.</h2>
      <div class="feature-grid">
        <div class="feature-card">
          <h3>Scene-aware continuity</h3>
          <p>Every block tracks back to a script beat, automatically inheriting dialogue, props, and camera notes from the writer.</p>
        </div>
        <div class="feature-card">
          <h3>Unified stacked timelines</h3>
          <p>Shots, audio cues, lighting rigs, and production notes live in parallel so teams can iterate without losing sync.</p>
        </div>
        <div class="feature-card">
          <h3>Realtime collaboration</h3>
          <p>Invite directors, storyboard artists, and producers with role-based access and threaded feedback.</p>
        </div>
        <div class="feature-card">
          <h3>Production-ready pipeline</h3>
          <p>Sync cues with lighting, VFX, and edit teams using integrations for Notion, Frame.io, and timeline apps.</p>
        </div>
      </div>
    </section>
  </main>

  <footer class="footer">
    <div class="footer__grid">
      <div>
        <strong>StudioOrganize</strong>
        <p class="muted">Tools for storytellers &amp; focused work.</p>
      </div>
      <div>
        <a href="/about.html">About</a><br />
      </div>
      <div>
        <a href="mailto:support@studioorganize.com">support@studioorganize.com</a><br />
        <span class="muted">¬© <span id="y"></span> StudioOrganize</span>
      </div>
    </div>
  </footer>

  <script>
    const trackToggles = document.querySelectorAll('[data-track-toggle]');
    const sceneListContainer = document.querySelector('[data-scene-list]');
    const sceneTitle = document.querySelector('[data-scene-title]');
    const sceneMeta = document.querySelector('[data-scene-meta]');
    const timelineGrid = document.querySelector('[data-timeline-grid]');
    const aiPromptInput = document.getElementById('aiShotPrompt');
    const aiFrameInput = document.getElementById('aiFrameCount');
    const aiProviderSelect = document.getElementById('aiProvider');
    const aiStatusLabel = document.querySelector('[data-ai-status]');
    const aiResultContainer = document.querySelector('[data-ai-result]');
    const aiGenerateButton = document.querySelector('[data-ai-generate]');
    const apiManagerButton = document.querySelector('[data-api-manager]');
    const apiDialog = document.querySelector('[data-api-dialog]');
    const apiForm = document.querySelector('[data-api-form]');
    const apiCloseButtons = document.querySelectorAll('[data-api-close]');
    const apiGeminiInput = apiDialog ? apiDialog.querySelector('[data-api-gemini]') : null;
    const apiSoaraInput = apiDialog ? apiDialog.querySelector('[data-api-soara]') : null;
    const apiFeedbackLabel = apiDialog ? apiDialog.querySelector('[data-api-feedback]') : null;

    const API_STORAGE_KEYS = {
      provider: 'ai.provider',
      gemini: 'ai.geminiKey',
      soara: 'ai.soaraKey',
    };

    const storage = createScopedStorage('storyboard');

    const sceneDataMap = new Map();
    let sceneData = [];
    let sceneCards = [];
    let sceneRows = [];
    let activeSceneId = null;

    initialiseAiProviderSelect();
    setupApiDialog();
    setupGenerationWorkflow();

    const WRITER_DB_NAME = 'sw_db_v1';
    const WRITER_DB_STORE = 'projects';
    const WRITER_LAST_PROJECT_KEY = 'SW_LAST_PROJECT_ID';

    const FALLBACK_SCENES_RAW = [
      {
        id: 'demo-alley',
        slug: 'EXT. ALLEY - NIGHT',
        storyboardStatus: 'Storyboard locked ¬∑ 12 frames',
        storyboardDescription: 'Lighting cues synced to script beats.',
        cards: ['Establish threat', 'Knife reversal', 'Slow mo impact', 'Escape alley'],
        storyboards: [
          { id: 'demo-alley-shot-1', title: 'Establish threat' },
          { id: 'demo-alley-shot-2', title: 'Knife reversal' },
          { id: 'demo-alley-shot-3', title: 'Slow mo impact' },
          { id: 'demo-alley-shot-4', title: 'Escape alley' }
        ],
        sounds: [
          { id: 'demo-alley-sound-1', cue: 'SFX: rain layers' },
          { id: 'demo-alley-sound-2', cue: 'Score: tension swell' }
        ],
        notes: 'Director: stay wide\nProducer: add rain plates',
        metadata: {
          sceneTagState: { locationType: 'ALLEY', timeOfDay: 'NIGHT', custom: ['Rain soaked'] },
          sceneAutoColorLabel: 'Night exterior',
          sceneAutoColorDetail: 'Neon practical bounce'
        },
        color: '#1d4ed8'
      },
      {
        id: 'demo-rooftop',
        slug: 'EXT. ROOFTOP - NIGHT',
        storyboardStatus: 'In progress ¬∑ 8 frames',
        storyboardDescription: 'Share draft with second unit.',
        cards: ['Drone reveal', 'Leap across gap', 'Handheld scramble', 'Edge save'],
        storyboards: [
          { id: 'demo-rooftop-shot-1', title: 'Drone reveal' },
          { id: 'demo-rooftop-shot-2', title: 'Leap across gap' },
          { id: 'demo-rooftop-shot-3', title: 'Handheld scramble' },
          { id: 'demo-rooftop-shot-4', title: 'Edge save' }
        ],
        sounds: [
          { id: 'demo-rooftop-sound-1', cue: 'Drone whir' },
          { id: 'demo-rooftop-sound-2', cue: 'Score: percussive chase bed' },
          { id: 'demo-rooftop-sound-3', cue: 'Wind gusts' }
        ],
        notes: 'FX: add rain pass\nDirector: add wide landing',
        metadata: {
          sceneTagState: { locationType: 'ROOFTOP', timeOfDay: 'NIGHT', custom: ['Neon spill'] },
          sceneAutoColorLabel: 'City skyline',
          sceneAutoColorDetail: 'Helipad strobes'
        },
        color: '#1f2937'
      },
      {
        id: 'demo-safehouse',
        slug: 'INT. SAFEHOUSE - NIGHT',
        storyboardStatus: 'Needs review ¬∑ 5 frames',
        storyboardDescription: 'Director comments pending.',
        cards: ['Intel drop', 'Mission brief', 'Surveillance plan'],
        storyboards: [
          { id: 'demo-safehouse-shot-1', title: 'Table wide' },
          { id: 'demo-safehouse-shot-2', title: 'Files close-up' },
          { id: 'demo-safehouse-shot-3', title: 'Resolve push-in' }
        ],
        sounds: [
          { id: 'demo-safehouse-sound-1', cue: 'Score: low synth tension' },
          { id: 'demo-safehouse-sound-2', cue: 'Radio chatter' }
        ],
        notes: 'AD: schedule reshoot\nDP: add monitor glow',
        metadata: {
          sceneTagState: { locationType: 'SAFEHOUSE', timeOfDay: 'NIGHT', custom: ['Briefing table'] },
          sceneAutoColorLabel: 'Interior warm practicals',
          sceneAutoColorDetail: 'Desk lamps dim'
        },
        color: '#0f172a'
      },
      {
        id: 'demo-finale',
        slug: 'INT. SOUNDSTAGE - NIGHT',
        storyboardStatus: 'Storyboard AI ready',
        storyboardDescription: 'Generate new hero shots.',
        cards: ['Setup reveal', 'Hero choice', 'Twist', 'Resolution'],
        storyboards: [
          { id: 'demo-finale-shot-1', title: 'Reveal wide' },
          { id: 'demo-finale-shot-2', title: 'Close hero' },
          { id: 'demo-finale-shot-3', title: 'VFX burst' }
        ],
        sounds: [
          { id: 'demo-finale-sound-1', cue: 'Score: ascend' },
          { id: 'demo-finale-sound-2', cue: 'FX: energy surge' },
          { id: 'demo-finale-sound-3', cue: 'Score: resolve' }
        ],
        notes: 'Producer: confirm VFX\nDirector: punch final beat',
        metadata: {
          sceneTagState: { locationType: 'STAGE', timeOfDay: 'NIGHT', custom: ['Hero moment'] },
          sceneAutoColorLabel: 'Moving spots',
          sceneAutoColorDetail: 'Backlight flare'
        },
        color: '#312e81'
      }
    ];

    function sanitizeString(value) {
      return typeof value === 'string' ? value.trim() : '';
    }

    function extractCardLabel(card) {
      if (typeof card === 'string') return card.trim();
      if (!card || typeof card !== 'object') return '';
      const keys = ['title', 'label', 'name', 'text', 'slug'];
      for (const key of keys) {
        const value = card[key];
        if (typeof value === 'string' && value.trim()) return value.trim();
      }
      return '';
    }

    function extractStoryboardLabel(entry, index) {
      const label = extractCardLabel(entry);
      if (label) return label;
      return `Storyboard ${index + 1}`;
    }

    function extractSoundLabel(sound) {
      if (typeof sound === 'string') return sound.trim();
      if (!sound || typeof sound !== 'object') return '';
      if (typeof sound.cue === 'string' && sound.cue.trim()) return sound.cue.trim();
      if (typeof sound.title === 'string' && sound.title.trim()) return sound.title.trim();
      return '';
    }

    function resolveAudioIcon(label) {
      const lower = label.toLowerCase();
      if (lower.includes('score') || lower.includes('music') || lower.includes('choir')) {
        return 'üéµ';
      }
      return 'üîä';
    }

    function getSceneSnippetFromElements(elements) {
      if (!Array.isArray(elements)) return '';
      const text = elements
        .map(el => (el && typeof el.txt === 'string' ? el.txt : ''))
        .join(' ')
        .replace(/\s+/g, ' ')
        .trim();
      if (!text) return '';
      return text.length > 160 ? `${text.slice(0, 157)}‚Ä¶` : text;
    }

    function formatWriterScene(scene, index, options = {}) {
      const { source = 'writer' } = options;
      const rawSlug = sanitizeString(scene?.slug) || sanitizeString(scene?.title);
      const number = index + 1;
      const numberLabel = sanitizeString(scene?.metadata?.sceneNumberLabel) || `Scene ${number}`;
      const displayName = rawSlug || numberLabel;
      const cards = Array.isArray(scene?.cards) ? scene.cards.map(extractCardLabel).filter(Boolean) : [];
      const storyboards = Array.isArray(scene?.storyboards)
        ? scene.storyboards.map((entry, idx) => extractStoryboardLabel(entry, idx)).filter(Boolean)
        : [];
      const sounds = Array.isArray(scene?.sounds) ? scene.sounds.map(extractSoundLabel).filter(Boolean) : [];
      const metadata = scene && typeof scene.metadata === 'object' ? scene.metadata : {};
      const tagState = metadata.sceneTagState && typeof metadata.sceneTagState === 'object' ? metadata.sceneTagState : {};
      const notesLines = [];
      const rawNotes = sanitizeString(scene?.notes);
      if (rawNotes) {
        rawNotes.split(/\n+/).map(part => part.trim()).filter(Boolean).forEach(part => notesLines.push(part));
      }
      const customTags = Array.isArray(tagState.custom) ? tagState.custom.map(sanitizeString).filter(Boolean) : [];
      customTags.forEach(tag => notesLines.push(`Tag: ${tag}`));
      const snippet = getSceneSnippetFromElements(scene?.elements);
      let statusText = sanitizeString(scene?.storyboardStatus) || sanitizeString(metadata.storyboardStatus);
      if (!statusText) {
        const pieces = [];
        if (cards.length) pieces.push(`${cards.length} beat${cards.length === 1 ? '' : 's'}`);
        if (storyboards.length) pieces.push(`${storyboards.length} storyboard${storyboards.length === 1 ? '' : 's'}`);
        if (sounds.length) pieces.push(`${sounds.length} sound cue${sounds.length === 1 ? '' : 's'}`);
        statusText = pieces.join(' ¬∑ ') || 'No beats yet';
      }
      const description = sanitizeString(scene?.storyboardDescription)
        || sanitizeString(metadata.storyboardDescription)
        || snippet
        || 'Add scene summary in the writer to see it here.';
      const lightingCues = [];
      const autoLabel = sanitizeString(metadata.sceneAutoColorLabel);
      const autoDetail = sanitizeString(metadata.sceneAutoColorDetail);
      if (autoLabel) lightingCues.push(autoLabel);
      if (autoDetail && autoDetail !== autoLabel) lightingCues.push(autoDetail);
      const locationType = sanitizeString(tagState.locationType);
      const timeOfDay = sanitizeString(tagState.timeOfDay);
      const locationMeta = [locationType, timeOfDay].filter(Boolean).join(' ¬∑ ');
      if (!lightingCues.length && locationMeta) lightingCues.push(locationMeta);
      const notesList = notesLines.slice(0, 4);
      const sourceMeta = source === 'writer'
        ? 'Synced from Writer workspace'
        : 'Demo data ‚Äî open Writer to sync live scenes.';
      const timelinePieces = [];
      if (statusText) timelinePieces.push(statusText);
      if (locationMeta) timelinePieces.push(locationMeta);
      timelinePieces.push(sourceMeta);
      const colorValue = sanitizeString(scene?.color);
      const color = /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(colorValue) ? colorValue : '';
      const colorSourceRaw = sanitizeString(metadata.sceneColorSource || scene?.colorSource);
      const colorSourceLabel = color
        ? (colorSourceRaw === 'custom'
          ? 'Writer custom color'
          : (colorSourceRaw === 'auto'
            ? 'Writer auto color'
            : (source === 'writer' ? 'Writer scene color' : 'Demo scene color')))
        : 'Scene color';
      return {
        id: String(scene?.id || `scene-${index}`),
        index,
        numberLabel,
        displayName,
        statusText,
        description,
        timelineMeta: timelinePieces.join(' ¬∑ '),
        cards,
        storyboards,
        sounds,
        lightingCues,
        notesList,
        color,
        colorSourceLabel,
        source,
      };
    }

    function computeBlockPositions(count) {
      if (!count) return [];
      if (count === 1) {
        return [{ left: 30, width: 40 }];
      }
      const width = Math.max(12, Math.min(36, 70 / count));
      const step = (100 - width) / Math.max(1, count - 1);
      const positions = [];
      for (let index = 0; index < count; index += 1) {
        const left = Math.max(0, Math.min(100 - width, step * index));
        positions.push({ left, width });
      }
      return positions;
    }

    function createTimelineTrack(trackKey, headerLabel, blockClass, icon, items, iconResolver = null) {
      const track = document.createElement('div');
      track.className = 'timeline-track';
      track.dataset.track = trackKey;
      const header = document.createElement('div');
      header.className = 'timeline-track__header';
      header.textContent = headerLabel;
      const lane = document.createElement('div');
      lane.className = 'timeline-track__lane';
      const values = Array.isArray(items) ? items.filter(Boolean) : [];
      const positions = computeBlockPositions(values.length);
      values.forEach((label, index) => {
        const block = document.createElement('div');
        block.className = `timeline-block ${blockClass}`;
        const iconValue = iconResolver ? iconResolver(label) : icon;
        block.dataset.icon = iconValue;
        block.style.left = `${positions[index].left}%`;
        block.style.width = `${positions[index].width}%`;
        block.textContent = label;
        lane.appendChild(block);
      });
      track.append(header, lane);
      return track;
    }

    function createSceneCard(scene) {
      const card = document.createElement('div');
      card.className = 'scene-card';
      card.dataset.scene = scene.id;
      card.setAttribute('role', 'button');
      card.tabIndex = 0;
      const combinedLabel = `${scene.numberLabel} ¬∑ ${scene.displayName}`;
      card.setAttribute('aria-label', combinedLabel);

      const label = document.createElement('div');
      label.className = 'scene-card-label';
      label.setAttribute('data-scene-edit-root', '');

      const color = document.createElement('span');
      color.className = 'scene-card-color';
      color.setAttribute('aria-hidden', 'true');
      if (scene.color) {
        color.style.background = scene.color;
      }
      if (scene.colorSourceLabel) {
        color.title = scene.colorSourceLabel;
      }

      const display = document.createElement('div');
      display.className = 'scene-card-label-display';
      const strong = document.createElement('strong');
      strong.dataset.sceneCardNumber = '';
      strong.textContent = scene.numberLabel;
      const separator = document.createElement('span');
      separator.className = 'scene-card-separator';
      separator.setAttribute('aria-hidden', 'true');
      separator.textContent = '¬∑';
      const name = document.createElement('span');
      name.dataset.sceneCardName = '';
      name.textContent = scene.displayName;
      display.append(strong, separator, name);

      const input = document.createElement('input');
      input.className = 'scene-card-input';
      input.type = 'text';
      input.value = scene.displayName;
      input.setAttribute('data-scene-input', '');
      input.setAttribute('aria-label', 'Scene name');

      label.append(color, display, input);

      const status = document.createElement('small');
      status.textContent = scene.statusText || '';

      const description = document.createElement('p');
      description.className = 'muted';
      description.textContent = scene.description || '';

      card.append(label, status, description);

      card.addEventListener('click', () => {
        if (card.classList.contains('editing')) return;
        activateScene(scene.id);
      });

      card.addEventListener('keydown', event => {
        if (event.key === 'F2') {
          event.preventDefault();
          startSceneRename(card);
          return;
        }
        if (card.classList.contains('editing')) return;
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          activateScene(scene.id);
        }
      });

      label.addEventListener('dblclick', event => {
        event.preventDefault();
        event.stopPropagation();
        startSceneRename(card);
      });

      input.addEventListener('keydown', event => {
        if (event.key === 'Enter') {
          event.preventDefault();
          finishSceneRename(card, true);
        } else if (event.key === 'Escape') {
          event.preventDefault();
          finishSceneRename(card, false);
        }
      });
      input.addEventListener('blur', () => finishSceneRename(card, true));
      input.addEventListener('click', event => event.stopPropagation());

      return card;
    }

    function createTimelineScene(scene) {
      const row = document.createElement('div');
      row.className = 'timeline-scene';
      row.dataset.sceneRow = scene.id;
      row.dataset.sceneName = `${scene.numberLabel} ¬∑ ${scene.displayName}`;
      row.dataset.sceneMeta = scene.timelineMeta;

      const label = document.createElement('div');
      label.className = 'timeline-scene__label';
      const number = document.createElement('strong');
      number.textContent = scene.numberLabel;
      const name = document.createElement('span');
      name.textContent = scene.displayName;
      const small = document.createElement('small');
      small.textContent = scene.statusText || '';
      label.append(number, name, small);

      const tracks = document.createElement('div');
      tracks.className = 'timeline-scene__tracks';
      tracks.append(
        createTimelineTrack('beats', 'Beat grid', 'timeline-block--beats', '‚è±', scene.cards),
        createTimelineTrack('shots', 'Shots', 'timeline-block--shots', 'üé¨', scene.storyboards),
        createTimelineTrack('audio', 'Audio', 'timeline-block--audio', 'üîä', scene.sounds, resolveAudioIcon),
        createTimelineTrack('lighting', 'Lighting', 'timeline-block--lighting', 'üí°', scene.lightingCues),
        createTimelineTrack('notes', 'Notes', 'timeline-block--notes', 'üìù', scene.notesList)
      );

      row.append(label, tracks);
      return row;
    }

    function renderScenes() {
      if (!sceneListContainer || !timelineGrid) return;
      sceneDataMap.clear();
      sceneListContainer.innerHTML = '';
      timelineGrid.querySelectorAll('.timeline-scene').forEach(el => el.remove());

      if (!sceneData.length) {
        const empty = document.createElement('p');
        empty.className = 'muted';
        empty.dataset.sceneEmpty = 'true';
        empty.textContent = 'No scenes yet. Open the Writer workspace to add scenes.';
        sceneListContainer.appendChild(empty);
        if (sceneTitle) sceneTitle.textContent = 'No scenes yet';
        if (sceneMeta) sceneMeta.textContent = 'Create a scene in the writer to sync it here.';
        sceneCards = [];
        sceneRows = [];
        activeSceneId = null;
        return;
      }

      const fragment = document.createDocumentFragment();
      sceneData.forEach(scene => {
        sceneDataMap.set(scene.id, scene);
        fragment.appendChild(createSceneCard(scene));
      });
      sceneListContainer.appendChild(fragment);
      sceneCards = Array.from(sceneListContainer.querySelectorAll('.scene-card'));

      sceneData.forEach(scene => {
        timelineGrid.appendChild(createTimelineScene(scene));
      });
      sceneRows = Array.from(timelineGrid.querySelectorAll('[data-scene-row]'));

      if (!sceneDataMap.has(activeSceneId)) {
        activeSceneId = sceneData[0]?.id || null;
      }

      if (activeSceneId) {
        activateScene(activeSceneId, { scroll: false });
      }
    }

    async function bootstrapScenes() {
      if (sceneListContainer) {
        sceneListContainer.innerHTML = '';
        const loading = document.createElement('p');
        loading.className = 'muted';
        loading.dataset.sceneEmpty = 'true';
        loading.textContent = 'Loading scenes from Writer‚Ä¶';
        sceneListContainer.appendChild(loading);
      }
      const writerScenes = await loadWriterScenes();
      if (writerScenes && writerScenes.length) {
        sceneData = writerScenes;
      } else {
        sceneData = FALLBACK_SCENES_RAW.map((scene, index) => formatWriterScene(scene, index, { source: 'fallback' }));
      }
      renderScenes();
    }

    function getLastWriterProjectId() {
      try {
        return window.localStorage.getItem(WRITER_LAST_PROJECT_KEY) || null;
      } catch (error) {
        console.warn('Unable to read Writer project id from localStorage:', error);
        return null;
      }
    }

    function openWriterDb() {
      return new Promise((resolve, reject) => {
        try {
          const request = indexedDB.open(WRITER_DB_NAME, 1);
          request.onerror = () => reject(request.error || new Error('IndexedDB open failed'));
          request.onsuccess = () => resolve(request.result);
        } catch (error) {
          reject(error);
        }
      });
    }

    function readWriterProject(db, projectId) {
      return new Promise((resolve, reject) => {
        try {
          const transaction = db.transaction([WRITER_DB_STORE], 'readonly');
          const store = transaction.objectStore(WRITER_DB_STORE);
          const request = store.get(projectId);
          request.onsuccess = () => resolve(request.result || null);
          request.onerror = () => reject(request.error || new Error('Project lookup failed'));
        } catch (error) {
          reject(error);
        }
      });
    }

    async function loadWriterScenes() {
      if (!('indexedDB' in window)) return null;
      const projectId = getLastWriterProjectId();
      if (!projectId) return null;
      let db;
      try {
        db = await openWriterDb();
        const project = await readWriterProject(db, projectId);
        if (!project || !Array.isArray(project.scenes) || !project.scenes.length) return null;
        const title = sanitizeString(project.title);
        return project.scenes.map((scene, index) => formatWriterScene(scene, index, { source: 'writer' }));
      } catch (error) {
        console.warn('Unable to load Writer scenes:', error);
        return null;
      } finally {
        if (db && typeof db.close === 'function') {
          db.close();
        }
      }
    }



    function setTrackVisibility(track, visible) {
      document.querySelectorAll(`[data-track="${track}"]`).forEach(trackRow => {
        trackRow.classList.toggle('timeline-track--hidden', !visible);
      });
    }

    trackToggles.forEach(btn => {
      btn.addEventListener('click', () => {
        btn.classList.toggle('active');
        const nowActive = btn.classList.contains('active');
        btn.setAttribute('aria-pressed', String(nowActive));
        setTrackVisibility(btn.dataset.trackToggle, nowActive);
      });
    });

    function activateScene(id, opts = { scroll: true }) {
      if (!id) return;
      activeSceneId = id;
      sceneCards.forEach(card => {
        const isActive = card.dataset.scene === id;
        card.classList.toggle('active', isActive);
      });
      sceneRows.forEach(row => {
        const isActive = row.dataset.sceneRow === id;
        row.classList.toggle('active', isActive);
        if (isActive) {
          if (sceneTitle) sceneTitle.textContent = row.dataset.sceneName || '';
          if (sceneMeta) sceneMeta.textContent = row.dataset.sceneMeta || '';
          if (opts.scroll) {
            const label = row.querySelector('.timeline-scene__label');
            if (label && typeof label.scrollIntoView === 'function') {
              label.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }
        }
      });
    }

    function updateSceneName(card, newName) {
      if (!card) return;
      const numberEl = card.querySelector('[data-scene-card-number]');
      const nameEl = card.querySelector('[data-scene-card-name]');
      if (!numberEl || !nameEl) return;
      const sceneId = card.dataset.scene;
      const sceneInfo = sceneDataMap.get(sceneId);
      const sceneNumber = sceneInfo ? sceneInfo.numberLabel : numberEl.textContent.trim();
      const trimmedName = newName.trim() || nameEl.textContent.trim();
      if (!trimmedName) return;
      nameEl.textContent = trimmedName;
      if (sceneInfo) sceneInfo.displayName = trimmedName;
      const combinedLabel = sceneNumber ? `${sceneNumber} ¬∑ ${trimmedName}` : trimmedName;
      card.setAttribute('aria-label', combinedLabel);

      const matchingRow = sceneRows.find(row => row.dataset.sceneRow === sceneId);
      if (matchingRow) {
        matchingRow.dataset.sceneName = combinedLabel;
        const timelineName = matchingRow.querySelector('.timeline-scene__label span');
        if (timelineName) {
          timelineName.textContent = trimmedName;
        }
        if (matchingRow.classList.contains('active') && sceneTitle) {
          sceneTitle.textContent = combinedLabel;
        }
      }
    }

    function startSceneRename(card) {
      if (!card || card.classList.contains('editing')) return;
      const input = card.querySelector('[data-scene-input]');
      const nameEl = card.querySelector('[data-scene-card-name]');
      if (!input || !nameEl) return;
      card.classList.add('editing');
      input.value = nameEl.textContent.trim();
      requestAnimationFrame(() => {
        input.focus();
        input.select();
      });
    }

    function finishSceneRename(card, commit = true) {
      if (!card) return;
      const input = card.querySelector('[data-scene-input]');
      const nameEl = card.querySelector('[data-scene-card-name]');
      if (!input || !nameEl) {
        card.classList.remove('editing');
        return;
      }
      const originalName = nameEl.textContent.trim();
      const desiredName = commit ? input.value.trim() : originalName;
      if (!desiredName) {
        input.value = originalName;
        card.classList.remove('editing');
        return;
      }
      input.value = desiredName;
      updateSceneName(card, desiredName);
      card.classList.remove('editing');
    }

    function createScopedStorage(namespace) {
      const prefix = namespace ? `${namespace}.` : '';
      let storageAvailable = true;
      try {
        const testKey = `${prefix}__test__`;
        window.localStorage.setItem(testKey, '1');
        window.localStorage.removeItem(testKey);
      } catch (error) {
        storageAvailable = false;
        console.warn('Local storage unavailable for API keys:', error);
      }

      return {
        get(key) {
          if (!storageAvailable) return '';
          try {
            return window.localStorage.getItem(`${prefix}${key}`) || '';
          } catch (error) {
            console.warn('Unable to read from storage:', error);
            return '';
          }
        },
        set(key, value) {
          if (!storageAvailable) return;
          try {
            if (value === undefined || value === null || value === '') {
              window.localStorage.removeItem(`${prefix}${key}`);
            } else {
              window.localStorage.setItem(`${prefix}${key}`, value);
            }
          } catch (error) {
            console.warn('Unable to write to storage:', error);
          }
        },
      };
    }

    function initialiseAiProviderSelect() {
      if (!aiProviderSelect) return;
      const storedProvider = storage.get(API_STORAGE_KEYS.provider);
      if (storedProvider) {
        aiProviderSelect.value = storedProvider;
      }
      aiProviderSelect.addEventListener('change', () => {
        storage.set(API_STORAGE_KEYS.provider, aiProviderSelect.value);
      });
    }

    function setupApiDialog() {
      if (!apiManagerButton || !apiDialog) return;

      const isDialogElement = typeof HTMLDialogElement !== 'undefined' && apiDialog instanceof HTMLDialogElement;

      function populateDialogFields() {
        if (apiGeminiInput) {
          apiGeminiInput.value = storage.get(API_STORAGE_KEYS.gemini);
        }
        if (apiSoaraInput) {
          apiSoaraInput.value = storage.get(API_STORAGE_KEYS.soara);
        }
        if (apiFeedbackLabel) {
          apiFeedbackLabel.textContent = '';
        }
      }

      function openDialog() {
        populateDialogFields();
        if (isDialogElement && typeof apiDialog.showModal === 'function') {
          apiDialog.showModal();
        } else {
          apiDialog.setAttribute('open', 'true');
        }
        if (apiGeminiInput) {
          requestAnimationFrame(() => apiGeminiInput.focus());
        }
      }

      function closeDialog() {
        if (isDialogElement && typeof apiDialog.close === 'function') {
          apiDialog.close();
        } else {
          apiDialog.removeAttribute('open');
        }
      }

      apiManagerButton.addEventListener('click', event => {
        event.preventDefault();
        openDialog();
      });

      if (apiForm) {
        apiForm.addEventListener('submit', event => {
          event.preventDefault();
          const geminiKey = apiGeminiInput ? apiGeminiInput.value.trim() : '';
          const soaraKey = apiSoaraInput ? apiSoaraInput.value.trim() : '';
          storage.set(API_STORAGE_KEYS.gemini, geminiKey);
          storage.set(API_STORAGE_KEYS.soara, soaraKey);
          if (apiFeedbackLabel) {
            apiFeedbackLabel.textContent = 'Saved locally';
            window.setTimeout(() => {
              if (apiFeedbackLabel && apiFeedbackLabel.textContent === 'Saved locally') {
                apiFeedbackLabel.textContent = '';
              }
            }, 3200);
          }
        });
      }

      apiCloseButtons.forEach(btn => {
        btn.addEventListener('click', event => {
          event.preventDefault();
          closeDialog();
        });
      });

      apiDialog.addEventListener('cancel', () => {
        if (apiFeedbackLabel) {
          apiFeedbackLabel.textContent = '';
        }
      });

      apiDialog.addEventListener('close', () => {
        if (apiFeedbackLabel) {
          apiFeedbackLabel.textContent = '';
        }
      });

      apiDialog.addEventListener('click', event => {
        if (event.target === apiDialog) {
          closeDialog();
        }
      });
    }

    function setAiStatus(message) {
      if (!aiStatusLabel) return;
      aiStatusLabel.textContent = message;
    }

    function summariseJson(value) {
      try {
        const jsonString = typeof value === 'string' ? value : JSON.stringify(value, null, 2);
        return jsonString.length > 2000 ? `${jsonString.slice(0, 2000)}\n‚Ä¶` : jsonString;
      } catch (error) {
        return '';
      }
    }

    function extractGeminiResult(data) {
      const result = {
        heading: 'Gemini response',
        provider: 'gemini',
        imageDataUrl: '',
        altText: 'Gemini storyboard preview',
        rawText: summariseJson(data),
      };
      const parts = data?.candidates?.[0]?.content?.parts || [];
      for (const part of parts) {
        if (part?.inlineData?.data) {
          const mimeType = part.inlineData.mimeType || 'image/png';
          result.imageDataUrl = `data:${mimeType};base64,${part.inlineData.data}`;
          break;
        }
        if (part?.fileData?.fileUri) {
          result.imageDataUrl = part.fileData.fileUri;
          break;
        }
      }
      const textParts = parts.map(part => part?.text).filter(Boolean);
      if (textParts.length) {
        result.rawText = textParts.join('\n');
      }
      return result;
    }

    function extractSoaraResult(data) {
      const result = {
        heading: 'Soara response',
        provider: 'soara',
        imageDataUrl: '',
        altText: 'Soara storyboard preview',
        rawText: summariseJson(data),
      };
      const images = Array.isArray(data?.data)
        ? data.data
        : Array.isArray(data?.images)
        ? data.images
        : [];
      const firstImage = images[0] || data;
      if (firstImage?.b64_json) {
        result.imageDataUrl = `data:image/png;base64,${firstImage.b64_json}`;
      } else if (firstImage?.base64) {
        result.imageDataUrl = `data:image/png;base64,${firstImage.base64}`;
      } else if (firstImage?.url) {
        result.imageDataUrl = firstImage.url;
      }
      return result;
    }

    function showAiResult(content) {
      if (!aiResultContainer) return;
      if (!content) {
        aiResultContainer.classList.remove('active');
        aiResultContainer.innerHTML = '';
        return;
      }
      aiResultContainer.classList.add('active');
      aiResultContainer.innerHTML = '';
      const headingText = content.heading || 'API response';
      const headingEl = document.createElement('p');
      headingEl.className = 'ai-result__heading';
      headingEl.textContent = headingText;
      aiResultContainer.appendChild(headingEl);

      const metaItems = Array.isArray(content.meta)
        ? content.meta
        : content.meta
        ? [content.meta]
        : [];
      metaItems.forEach(text => {
        const metaEl = document.createElement('p');
        metaEl.className = 'ai-result__meta';
        metaEl.textContent = text;
        aiResultContainer.appendChild(metaEl);
      });

      if (content.imageDataUrl) {
        const img = document.createElement('img');
        img.className = 'ai-result__image';
        img.src = content.imageDataUrl;
        img.alt = content.altText || 'Storyboard frame preview';
        aiResultContainer.appendChild(img);
      }

      if (content.rawText) {
        const pre = document.createElement('pre');
        pre.textContent = content.rawText;
        aiResultContainer.appendChild(pre);
      } else if (!content.imageDataUrl) {
        const fallback = document.createElement('p');
        fallback.className = 'ai-result__empty';
        fallback.textContent = 'No response payload received. Check your API keys and try again.';
        aiResultContainer.appendChild(fallback);
      }
    }

    async function requestGeminiImage(apiKey, prompt, frameCount, signal) {
      const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${encodeURIComponent(apiKey)}`;
      const payload = {
        contents: [
          {
            role: 'user',
            parts: [
              {
                text: `Generate ${frameCount} storyboard frame${frameCount > 1 ? 's' : ''} for an action sequence. Return base64 image data if available.\n${prompt}`,
              },
            ],
          },
        ],
        generationConfig: {
          temperature: 0.9,
        },
      };
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
        signal,
      });
      const data = await response.json().catch(() => ({}));
      if (!response.ok) {
        const message = data?.error?.message || `${response.status} ${response.statusText}`;
        throw new Error(message);
      }
      return data;
    }

    async function requestSoaraImage(apiKey, prompt, frameCount, signal) {
      const response = await fetch('https://api.soara.ai/v1/images', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${apiKey}`,
        },
        body: JSON.stringify({
          prompt,
          frames: frameCount,
          response_format: 'b64_json',
        }),
        signal,
      });
      const data = await response.json().catch(() => ({}));
      if (!response.ok) {
        const message = data?.error?.message || `${response.status} ${response.statusText}`;
        throw new Error(message);
      }
      return data;
    }

    function setupGenerationWorkflow() {
      setAiStatus('Ready');
      showAiResult(null);
      if (!aiGenerateButton || !aiPromptInput) return;

      aiGenerateButton.addEventListener('click', async () => {
        const prompt = aiPromptInput.value.trim();
        const provider = aiProviderSelect ? aiProviderSelect.value : 'gemini';
        const frameCount = Math.max(1, Math.min(12, Number(aiFrameInput ? aiFrameInput.value : 1) || 1));

        if (!prompt) {
          setAiStatus('Add a prompt first');
          aiPromptInput.focus();
          return;
        }

        const apiKey = provider === 'soara'
          ? storage.get(API_STORAGE_KEYS.soara)
          : storage.get(API_STORAGE_KEYS.gemini);

        if (!apiKey) {
          setAiStatus('Add your API key first');
          showAiResult({
            heading: 'Missing API key',
            rawText: 'Open the API manager to save a key for this provider before generating.',
          });
          if (apiManagerButton) {
            apiManagerButton.focus();
          }
          return;
        }

        storage.set(API_STORAGE_KEYS.provider, provider);
        setAiStatus('Contacting provider‚Ä¶');
        showAiResult(null);
        aiGenerateButton.disabled = true;

        const controller = new AbortController();
        const timeoutId = window.setTimeout(() => controller.abort(), 45000);
        const startedAt = performance.now();

        try {
          let data;
          if (provider === 'soara') {
            data = await requestSoaraImage(apiKey, prompt, frameCount, controller.signal);
            const duration = ((performance.now() - startedAt) / 1000).toFixed(1);
            const result = extractSoaraResult(data);
            result.meta = [`Frames requested: ${frameCount}`, `Completed in ${duration}s`];
            showAiResult(result);
          } else {
            data = await requestGeminiImage(apiKey, prompt, frameCount, controller.signal);
            const duration = ((performance.now() - startedAt) / 1000).toFixed(1);
            const result = extractGeminiResult(data);
            result.meta = [`Frames requested: ${frameCount}`, `Completed in ${duration}s`];
            showAiResult(result);
          }
          setAiStatus('Preview ready');
        } catch (error) {
          const message = error?.name === 'AbortError' ? 'Request timed out' : error?.message || 'Request failed';
          setAiStatus(message);
          showAiResult({
            heading: 'Request error',
            rawText: `${message}. Check the developer console for additional context.`,
          });
          console.error('Storyboard AI generation error:', error);
        } finally {
          window.clearTimeout(timeoutId);
          aiGenerateButton.disabled = false;
        }
      });
    }

    bootstrapScenes();
  </script>
  <script>document.getElementById('y').textContent = new Date().getFullYear();</script>
  <script type="module" src="/assets/main.js"></script>
</body>
</html>
