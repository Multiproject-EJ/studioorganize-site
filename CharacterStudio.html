<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Character Studio ‚Äî StudioOrganize</title>
  <meta
    name="description"
    content="Character Studio keeps every character's profile, arc, lookbook, and AI prompt in one dedicated workspace."
  />
  <link rel="stylesheet" href="/assets/styles.css" />
  <link rel="stylesheet" href="/assets/css/so-mobile-shell.css" />
  <link rel="icon" type="image/webp" href="/assets/img/studioorganizeFavicon.webp" />
  <script src="/assets/js/so-mobile-shell.js" defer></script>
</head>
<body>
  <div class="so-mobile-shell" data-page="character-studio">
    <nav class="so-mobile-bottom-nav" aria-label="Character Studio mobile navigation">
      <button type="button" data-target="characters" class="is-active">Characters</button>
      <button type="button" data-target="backstories">Backstories</button>
      <button type="button" data-target="relationships">Relations</button>
    </nav>
  </div>
  <header class="nav">
    <div class="brand-with-logo">
      <a class="brand brand--with-logo" href="/">
        <span class="brand__logo" aria-hidden="true"></span>
        <span class="sr-only">StudioOrganize</span>
      </a>
    </div>
    <nav class="menu">
      <a class="menu__link menu__link--plain menu__link--icon" href="/">
        <span aria-hidden="true">üè†</span>
        <span class="sr-only">Home</span>
      </a>
      <div class="dropdown">
        <button class="dropbtn dropbtn--plain" type="button">Use Cases</button>
        <div class="dropdown-content">
          <a href="/use-cases/">All Use Cases</a>
          <a href="/use-cases/generate-ideas.html">Generate Ideas</a>
          <a href="/use-cases/screenplay.html">Screenplay Script</a>
          <a href="/use-cases/character-design.html">Character Design</a>
          <a href="/use-cases/set-design.html">Set / Production Design</a>
        </div>
      </div>
      <a class="menu__link menu__link--plain" href="https://finishthatstory.com" target="_blank" rel="noopener noreferrer">FinishThatStory.com</a>
      <div class="menu__actions">
        <button class="theme-toggle theme-toggle--icon" type="button" data-theme-toggle aria-pressed="false">
          <span class="sr-only">Toggle theme</span>
          <span class="theme-toggle__icon" aria-hidden="true" data-theme-icon>‚òÄÔ∏è</span>
        </button>
        <a class="menu__cta" href="https://studioorganize.com/supabase-test.html" data-auth-link data-auth-intent="signin">Sign in</a>
        <div class="dropdown" data-account-menu hidden>
          <button class="menu__cta" type="button" data-account-button>Account</button>
          <div class="dropdown-content">
            <a href="/account.html">My Creator Page</a>
            <a href="/product/personal.html">My Subscription</a>
            <a href="#" data-account-logout>Log out</a>
          </div>
        </div>
      </div>
    </nav>
  </header>

  <div class="workspace-launcher" data-workspace-launcher>
    <div class="workspace-launcher__toggle-wrap">
      <button class="workspace-launcher__toggle" type="button" aria-expanded="false" aria-label="Workspace menu" data-workspace-toggle>
        <span class="sr-only">Workspace menu</span>
        <span class="workspace-launcher__icon" aria-hidden="true"></span>
      </button>
      <div class="workspace-launcher__chat" data-workspace-chat hidden aria-hidden="true">
        <div class="workspace-launcher__chat-bubble">
          <div class="workspace-launcher__chat-thread" data-workspace-chat-thread>
            <div class="workspace-launcher__chat-message workspace-launcher__chat-message--assistant">Hi there! Ready to build something great today?</div>
          </div>
            <div class="workspace-launcher__chat-suggestions">
              <button type="button" class="workspace-launcher__chat-chip" data-workspace-chat-suggestion data-workspace-chat-action="continue">Check my progress</button>
              <button type="button" class="workspace-launcher__chat-chip" data-workspace-chat-suggestion data-workspace-chat-action="new">Spin up something new</button>
              <button type="button" class="workspace-launcher__chat-chip" data-workspace-chat-suggestion data-workspace-chat-action="settings">How should you behave?</button>
            </div>
          <form class="workspace-launcher__chat-form" data-workspace-chat-form>
            <div class="workspace-launcher__chat-input">
              <input type="text" placeholder="Ask StudioOrganize‚Ä¶" aria-label="Ask the workspace assistant" data-workspace-chat-input />
              <button type="submit" class="workspace-launcher__chat-send" aria-label="Send chat message">
                <span aria-hidden="true">‚û§</span>
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
    <div class="workspace-launcher__panel" data-workspace-panel aria-hidden="true" hidden tabindex="-1">
      <div class="workspace-launcher__quick-actions">
        <p class="workspace-launcher__quick-actions-label">Quick actions</p>
        <div class="workspace-launcher__quick-actions-buttons" role="group" aria-label="Workspace quick actions">
          <button type="button" class="workspace-launcher__script" data-workspace-script>
            <span>Story</span>
          </button>
          <a class="workspace-launcher__script workspace-launcher__creator" href="/account.html" aria-label="Creator Page">
            <span>Creator Page</span>
          </a>
          <a
            class="workspace-launcher__module workspace-launcher__module--creative-hub"
            href="/creative-hub.html"
            data-label="Creative Hub"
          >
            <span class="workspace-launcher__module-icon" aria-hidden="true">
              <img src="/assets/img/IMG_6896.webp" alt="" loading="lazy" />
            </span>
            <span class="sr-only">Creative Hub</span>
          </a>
          <button
            type="button"
            class="workspace-launcher__module workspace-launcher__module--assistant"
            data-workspace-assistant-toggle
            data-label="Assistant"
            aria-pressed="false"
            aria-expanded="false"
            aria-label="Open StudioOrganize Assistant"
          >
            <span class="workspace-launcher__module-icon" aria-hidden="true">
              <span class="workspace-launcher__assistant-glyph" aria-hidden="true"></span>
            </span>
            <span class="sr-only">Open StudioOrganize Assistant</span>
          </button>
          <button type="button" class="workspace-launcher__module workspace-launcher__module--lessons" data-video-lessons-open data-label="Video Lessons" aria-label="Open video lesson library">
            <span class="workspace-launcher__module-icon workspace-launcher__module-icon--lessons" aria-hidden="true">
              <span aria-hidden="true">üé¨</span>
            </span>
            <span class="sr-only">Open video lesson library</span>
          </button>
          <button
            type="button"
            class="workspace-launcher__module workspace-launcher__module--music-note"
            data-music-library-open
            data-label="Create with Music"
            aria-label="Open Create with Music"
          >
            <span class="workspace-launcher__module-icon workspace-launcher__module-icon--music-note" aria-hidden="true">
              <span aria-hidden="true">üéµ</span>
            </span>
            <span class="sr-only">Open Create with Music</span>
          </button>
          <button type="button" class="workspace-launcher__module workspace-launcher__module--save" data-workspace-save data-label="Save Progress">
            <span class="workspace-launcher__module-icon" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                <polyline points="17 21 17 13 7 13 7 21"></polyline>
                <polyline points="7 3 7 8 15 8"></polyline>
              </svg>
            </span>
            <span class="sr-only">Save Progress</span>
          </button>
          <button type="button" class="workspace-launcher__module workspace-launcher__module--story" data-workspace-script data-label="New Story">
            <span class="workspace-launcher__module-icon" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
              </svg>
            </span>
            <span class="sr-only">New Story</span>
          </button>
        </div>
      </div>
      <div class="workspace-launcher__module-stack">
        <nav class="workspace-launcher__modules" aria-label="Workspace modules">
          <a class="workspace-launcher__module" href="/use-cases/screenplay-writing.html" data-label="Screenplay Writing">
            <span class="workspace-launcher__module-icon" aria-hidden="true">
              <img src="/assets/img/IMG_6892.webp" alt="" loading="lazy" />
            </span>
            <span class="sr-only">Screenplay Writing</span>
          </a>
          <a class="workspace-launcher__module workspace-launcher__module--active" href="/CharacterStudio.html" data-label="Character Studio">
            <span class="workspace-launcher__module-icon" aria-hidden="true">
              <img src="/assets/img/IMG_6894.webp" alt="" loading="lazy" />
            </span>
            <span class="sr-only">Character Studio</span>
          </a>
          <a class="workspace-launcher__module" href="/use-cases/set-design.html" data-label="Set Design">
            <span class="workspace-launcher__module-icon" aria-hidden="true">
              <img src="/assets/img/IMG_6903.webp" alt="" loading="lazy" />
            </span>
            <span class="sr-only">Set Design</span>
          </a>
          <a class="workspace-launcher__module" href="/MusicStudio.html" data-label="Music Workspace">
            <span class="workspace-launcher__module-icon workspace-launcher__module-icon--music" aria-hidden="true">
              <span aria-hidden="true">üéµ‚ù§Ô∏è</span>
            </span>
            <span class="sr-only">Music Workspace</span>
          </a>
          <a class="workspace-launcher__module" href="/StoryboardPro.html" data-label="Storyboard Pro">
            <span class="workspace-launcher__module-icon" aria-hidden="true">
              <img src="/assets/img/IMG_6893.webp" alt="" loading="lazy" />
            </span>
            <span class="sr-only">Storyboard Pro</span>
          </a>
          <a class="workspace-launcher__module" href="/VideoEditing.html" data-label="Video &amp; Editing">
            <span class="workspace-launcher__module-icon" aria-hidden="true">
              <img src="/assets/img/IMG_6893.webp" alt="" loading="lazy" />
            </span>
            <span class="sr-only">Video &amp; Editing</span>
          </a>
        </nav>
      </div>
    </div>
  </div>

  <main class="section">
    <style>
      .so-mobile-shell[data-page="character-studio"] .so-mobile-bottom-nav {
        display: none;
      }

      @media (max-width: 768px) {
        .so-mobile-shell[data-page="character-studio"] .so-mobile-bottom-nav {
          display: flex;
        }
      }

      html, body { height: 100%; font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Arial; }
      body {
        color: var(--ink);
        background: radial-gradient(circle at top right, rgba(123, 97, 255, 0.1), transparent 35%), var(--surface);
        --nav-height: 72px;
        min-height: 100dvh;
        display: flex;
        flex-direction: column;
      }
      main.section { flex: 1; display: flex; flex-direction: column; width: 100%; max-width: none; padding: 0; margin: 0; }
      .character-studio-app { flex: 1; display: flex; flex-direction: column; min-height: 0; padding: clamp(18px, 4vw, 32px); gap: 24px; }
      .character-studio-window {
        position: relative;
        width: 100%;
        min-height: 0;
        background: var(--panel);
        border: 1px solid var(--ring);
        border-radius: 24px;
        box-shadow: 0 36px 110px rgba(0, 0, 0, 0.35);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        flex: 1 1 auto;
      }
      .character-studio-poses-panel {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .character-studio-pose-grid {
        display: grid;
        gap: 16px;
        grid-template-columns: minmax(0, 320px) minmax(0, 1fr);
        align-items: start;
      }
      @media (max-width: 960px) {
        .character-studio-pose-grid {
          grid-template-columns: 1fr;
        }
      }
      .character-studio-pose-card {
        background: var(--chip);
        border: 1px solid var(--ring);
        border-radius: 16px;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      @media (max-width: 768px) {
        .footer {
          display: none;
        }
      }
      .character-studio-pose-preview {
        position: relative;
        background: var(--panel);
        border: 1px dashed var(--ring);
        border-radius: 12px;
        min-height: 220px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }
      .character-studio-pose-preview img {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        display: block;
      }
      .character-studio-pose-placeholder {
        font-size: 14px;
        color: var(--muted);
        text-align: center;
        padding: 12px;
      }
      .character-studio-pose-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .character-studio-pose-actions button {
        border: 1px solid var(--ring);
        border-radius: 10px;
        padding: 8px 12px;
        background: var(--panel);
        color: var(--ink);
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
      }
      .character-studio-pose-actions button:hover {
        border-color: var(--acc);
      }
      .character-studio-pose-actions button:focus-visible {
        outline: 2px solid var(--acc);
        outline-offset: 2px;
      }
      .character-studio-pose-form {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .character-studio-pose-form .character-studio-field {
        width: 100%;
      }
      .character-studio-pose-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 16px;
      }
      .character-studio-pose-list-item {
        border: 1px solid var(--ring);
        border-radius: 16px;
        padding: 12px;
        background: var(--panel);
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .character-studio-pose-list-item img {
        width: 100%;
        border-radius: 10px;
        background: var(--chip);
        object-fit: contain;
      }
      .character-studio-pose-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 12px;
        color: var(--muted);
      }
      .character-studio-pose-flag {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 6px;
        border-radius: 999px;
        font-size: 11px;
        text-transform: uppercase;
        background: rgba(79, 123, 255, 0.12);
        color: var(--acc);
        border: 1px solid rgba(79, 123, 255, 0.4);
      }
      .character-studio-small-note {
        font-size: 12px;
        line-height: 1.4;
        color: var(--muted);
      }
      .character-studio-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 18px;
        padding: 26px 30px;
        border-bottom: 1px solid var(--ring);
        background: var(--chip);
      }
      .character-studio-header-primary {
        display: flex;
        align-items: center;
        gap: 18px;
      }
      .brand-with-logo__badge--character {
        width: 36px;
        height: 36px;
        border-radius: 12px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        font-size: 14px;
        letter-spacing: .6px;
        background: linear-gradient(135deg, #7c3aed, #22d3ee);
        color: white;
        box-shadow: 0 8px 24px rgba(124, 58, 237, 0.35);
      }
      .character-studio-header h2 { margin: 0; font-size: 24px; font-weight: 600; }
      .character-studio-header .muted-text { margin: 6px 0 0; max-width: 60ch; font-size: 14px; }
      .character-studio-header-actions { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; justify-content: flex-end; }
      .character-studio-header-buttons { display: inline-flex; align-items: center; gap: 10px; flex-wrap: wrap; justify-content: flex-end; }
      .character-studio-project { font-size: 12px; color: var(--muted); }
      .character-studio-project[data-state="warning"] { color: #f97316; }
      .character-studio-project[data-state="error"] { color: #ef4444; }
      .character-studio-project[data-state="ready"] { color: var(--acc); }
      .character-studio-tabs { display: flex; flex-direction: column; gap: 18px; }
      .character-studio-tablist { display: flex; flex-wrap: wrap; gap: 8px; padding: 8px; border-radius: 14px; background: var(--card); border: 1px solid var(--ring); box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04); overflow-x: auto; }
      .character-studio-tablist::-webkit-scrollbar { height: 6px; }
      .character-studio-tab-button {
        appearance: none;
        border: 1px solid transparent;
        border-radius: 999px;
        background: transparent;
        color: var(--muted);
        font: inherit;
        font-size: 13px;
        padding: 8px 16px;
        cursor: pointer;
        transition: background .2s ease, color .2s ease, box-shadow .2s ease, transform .2s ease;
      }
      .character-studio-tab-button:hover { color: var(--ink); }
      .character-studio-tab-button[aria-selected="true"] {
        background: var(--acc);
        color: var(--active-tab-text);
        box-shadow: 0 14px 36px rgba(62, 114, 255, 0.28);
        border-color: var(--acc);
        transform: translateY(-1px);
      }
      .character-studio-tab-button:focus-visible {
        outline: none;
        box-shadow: 0 0 0 2px rgba(79, 123, 255, 0.45);
      }
      .character-studio-tabpanels { position: relative; }
      .character-studio-header-badge {
        font-size: 11px;
        letter-spacing: .3px;
        text-transform: uppercase;
        background: rgba(123, 97, 255, 0.16);
        border: 1px solid rgba(123, 97, 255, 0.35);
        color: var(--ink);
        border-radius: 999px;
        padding: 6px 12px;
        font-weight: 600;
      }
      .character-studio-add { 
        background: var(--acc);
        border: 1px solid var(--acc);
        color: var(--active-tab-text);
        border-radius: 999px;
        padding: 8px 18px;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: transform .2s ease, box-shadow .2s ease;
      }
      .character-studio-add:hover { box-shadow: 0 14px 32px rgba(79, 123, 255, 0.25); transform: translateY(-1px); }
      .character-studio-add:focus-visible { outline: none; box-shadow: 0 0 0 2px rgba(79,123,255,0.25); }
      .character-studio-save {
        background: linear-gradient(135deg, var(--brand-2), var(--brand));
        border: 1px solid transparent;
        color: var(--cta-text);
        border-radius: 999px;
        padding: 8px 20px;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 18px 48px rgba(124, 58, 237, 0.28);
        transition: transform .2s ease, box-shadow .2s ease, opacity .2s ease;
      }
      .character-studio-save:hover { box-shadow: 0 20px 52px rgba(124, 58, 237, 0.32); transform: translateY(-1px); }
      .character-studio-save:focus-visible { outline: none; box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.35); }
      .character-studio-save[disabled] { opacity: 0.6; cursor: not-allowed; box-shadow: none; transform: none; }
      .character-studio-body { padding: 26px 30px 32px; flex: 1; overflow: hidden; }
      .character-studio-layout { display: grid; grid-template-columns: 300px 1fr; gap: 24px; height: 100%; min-height: 0; }
      .character-studio-sidebar { display: flex; flex-direction: column; gap: 16px; min-height: 0; }
      .character-studio-sidebar-header { display: flex; justify-content: space-between; align-items: center; gap: 8px; }
      .character-studio-sidebar h3 { margin: 0; font-size: 12px; letter-spacing: .4px; text-transform: uppercase; color: var(--muted); }
      .character-studio-sidebar-note { font-size: 12px; color: var(--muted); line-height: 1.45; }
      .character-studio-sidebar-list { display: flex; flex-direction: column; gap: 10px; overflow: auto; padding-right: 4px; min-height: 0; }
      .character-studio-list-item {
        background: var(--card);
        border: 1px solid var(--ring);
        border-radius: 14px;
        padding: 12px 14px;
        text-align: left;
        display: flex;
        flex-direction: column;
        gap: 6px;
        cursor: pointer;
        color: inherit;
        font: inherit;
        transition: border-color .2s ease, box-shadow .2s ease, transform .2s ease;
      }
      .character-studio-list-item strong { font-size: 14px; font-weight: 600; }
      .character-studio-list-item span { font-size: 11px; color: var(--muted); letter-spacing: .3px; text-transform: uppercase; }
      .character-studio-list-item:hover { border-color: var(--acc); box-shadow: 0 18px 48px rgba(47, 110, 255, 0.18); transform: translateY(-1px); }
      .character-studio-list-item.active { border-color: var(--acc); box-shadow: 0 18px 48px rgba(47, 110, 255, 0.28); background: var(--acc); color: var(--active-tab-text); }
      .character-studio-list-item.active span { color: var(--active-tab-text); opacity: 0.85; }
      .character-studio-details { display: flex; flex-direction: column; gap: 20px; min-height: 0; overflow: auto; padding-right: 6px; }
      .character-studio-detail-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 18px; flex-wrap: wrap; }
      .character-studio-detail-header h2 { margin: 0; font-size: 26px; font-weight: 600; }
      .character-studio-detail-header .muted-text { margin: 6px 0 0; font-size: 13px; }
      .character-studio-profile-layout { display: flex; flex-wrap: wrap; gap: 18px; align-items: flex-start; }
      .character-studio-profile-portrait { flex: 0 0 220px; max-width: 260px; width: 100%; background: var(--chip); border: 1px solid var(--ring); border-radius: 16px; overflow: hidden; aspect-ratio: 3 / 4; display: flex; align-items: center; justify-content: center; }
      .character-studio-profile-portrait img { width: 100%; height: 100%; object-fit: cover; }
      .character-studio-profile-fields { flex: 1 1 260px; display: flex; flex-direction: column; gap: 16px; }
      .character-studio-tertiary {
        background: none;
        border: 1px solid var(--ring);
        border-radius: 12px;
        padding: 6px 14px;
        font-size: 12px;
        cursor: pointer;
        color: var(--muted);
      }
      .character-studio-tertiary:hover { border-color: var(--acc); color: var(--ink); }
      .character-studio-section {
        background: var(--card);
        border: 1px solid var(--ring);
        border-radius: 18px;
        padding: 22px 24px;
        display: flex;
        flex-direction: column;
        gap: 14px;
      }
      .character-studio-section[hidden] { display: none; }
      .character-studio-section h3 { margin: 0; font-size: 14px; font-weight: 600; }
      .character-studio-section p { margin: 0; }
      .character-studio-two-col { display: grid; gap: 14px; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
      .character-studio-field { display: flex; flex-direction: column; gap: 6px; font-size: 13px; }
      .character-studio-field span { font-size: 11px; color: var(--muted); letter-spacing: .3px; text-transform: uppercase; }
      .character-studio-field input,
      .character-studio-field textarea {
        background: var(--field);
        color: var(--ink);
        border: 1px solid var(--ring);
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 14px;
        width: 100%;
      }
      .character-studio-field textarea { min-height: 108px; resize: vertical; }
      .character-studio-field textarea.small { min-height: 78px; }
      .character-studio-field select {
        background: var(--field);
        color: var(--ink);
        border: 1px solid var(--ring);
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 14px;
        width: 100%;
        cursor: pointer;
      }
      .character-studio-field select:focus-visible {
        outline: 2px solid var(--acc);
        outline-offset: 2px;
        border-color: var(--acc);
      }
      .character-studio-stats-grid { display: grid; gap: 12px; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); }
      .character-studio-stat { background: var(--chip); border: 1px solid var(--ring); border-radius: 16px; padding: 16px; display: flex; flex-direction: column; gap: 6px; }
      .character-studio-stat-value { font-size: 22px; font-weight: 700; }
      .character-studio-stat-label { font-size: 11px; color: var(--muted); letter-spacing: .3px; text-transform: uppercase; }
      .character-studio-traits-preview { display: flex; flex-wrap: wrap; gap: 8px; min-height: 36px; align-items: flex-start; }
      .character-studio-chip { background: var(--chip); border: 1px solid var(--ring); border-radius: 999px; padding: 4px 10px; font-size: 12px; }
      .character-studio-look-grid { display: grid; gap: 16px; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
      .character-studio-look-card { position: relative; border: 1px solid var(--ring); border-radius: 16px; overflow: hidden; background: var(--chip); aspect-ratio: 4 / 3; display: flex; align-items: center; justify-content: center; text-align: center; }
      .character-studio-look-card [data-look-content] { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; }
      .character-studio-look-card img { width: 100%; height: 100%; object-fit: cover; }
      .character-studio-look-empty { padding: 0 16px; font-size: 12px; color: var(--muted); line-height: 1.45; }
      .character-studio-look-label { position: absolute; top: 10px; left: 10px; padding: 4px 8px; border-radius: 999px; font-size: 11px; text-transform: uppercase; letter-spacing: .3px; background: rgba(15, 18, 30, 0.65); color: #fff; }
      .character-studio-ai-actions { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
      .character-studio-ai-actions button { background: var(--acc); border: 1px solid var(--acc); color: var(--active-tab-text); border-radius: 999px; padding: 10px 18px; font-weight: 600; cursor: pointer; }
      .character-studio-status { font-size: 12px; color: var(--muted); min-height: 18px; }
      .character-studio-status[data-state="ready"] { color: var(--acc); }
      .character-studio-status[data-state="warning"] { color: #f97316; }
      .character-studio-dialog-grid { display: grid; gap: 18px; }
      @media (min-width: 960px) {
        .character-studio-dialog-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      }
      .character-studio-dialog-column { display: flex; flex-direction: column; gap: 14px; }
      .character-studio-dialog-header { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
      .character-studio-dialog-list,
      .character-studio-dialog-drafts { display: grid; gap: 12px; }
      .character-studio-dialog-entry,
      .character-studio-dialog-draft { border: 1px solid var(--ring); border-radius: 16px; padding: 16px; background: var(--panel); display: grid; gap: 8px; }
      .character-studio-dialog-entry header { display: flex; flex-wrap: wrap; gap: 8px; align-items: baseline; justify-content: space-between; }
      .character-studio-dialog-entry strong { font-size: 14px; }
      .character-studio-dialog-entry p { margin: 0; font-size: 13px; line-height: 1.55; }
      .character-studio-dialog-meta { font-size: 11px; color: var(--muted); letter-spacing: .25px; text-transform: uppercase; }
      .character-studio-dialog-draft-actions { display: flex; flex-wrap: wrap; gap: 10px; align-items: flex-start; }
      .character-studio-dialog-draft-actions .character-studio-field { flex: 1 1 220px; min-width: 180px; }
      .character-studio-dialog-draft-buttons { display: flex; flex-wrap: wrap; gap: 8px; }
      .character-studio-dialog-draft-buttons button { border: 1px solid var(--ring); border-radius: 12px; padding: 8px 14px; background: var(--panel); font-size: 12px; font-weight: 600; cursor: pointer; }
      .character-studio-dialog-draft-buttons button:hover { border-color: var(--acc); }
      .character-studio-dialog-draft-buttons button:focus-visible { outline: 2px solid var(--acc); outline-offset: 2px; }
      .character-studio-save-status { font-size: 12px; color: var(--muted); min-height: 18px; }
      .character-studio-save-status[data-state="ready"] { color: var(--acc); }
      .character-studio-save-status[data-state="warning"] { color: #f97316; }
      .character-studio-save-status[data-state="error"] { color: #ef4444; }
      .character-studio-save-status[data-state="saving"] { color: var(--brand); }
      .character-studio-empty,
      .character-studio-empty-list {
        border: 1px dashed var(--ring);
        border-radius: 16px;
        padding: 28px;
        text-align: center;
        display: flex;
        flex-direction: column;
        gap: 10px;
        color: var(--muted);
        align-items: center;
        justify-content: center;
      }
      .character-studio-empty h2 { margin: 0; font-size: 22px; color: var(--ink); }
      .character-studio-empty p { margin: 0; font-size: 14px; }
      .muted-text { color: var(--muted); font-size: 12px; }
      .character-studio-mobile { display: none; position: relative; }
      .character-studio-mobile-track { display: flex; }
      .character-studio-mobile-card { display: flex; cursor: pointer; }
      .character-studio-mobile-card-media { position: relative; overflow: hidden; }
      .character-studio-mobile-card-media img { width: 100%; height: 100%; object-fit: cover; display: block; }
      .character-studio-mobile-card-placeholder {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 48px;
        font-weight: 700;
        color: rgba(255, 255, 255, 0.85);
        background: linear-gradient(135deg, rgba(124, 58, 237, 0.9), rgba(56, 189, 248, 0.9));
      }
      .character-studio-mobile-card-body { display: flex; flex-direction: column; gap: 16px; padding: 20px 20px 24px; }
      .character-studio-mobile-card-meta { font-size: 13px; color: var(--muted); letter-spacing: .3px; text-transform: uppercase; }
      .character-studio-mobile-card-summary { font-size: 14px; line-height: 1.55; }
      .character-studio-mobile-card-traits { display: flex; flex-wrap: wrap; gap: 8px; }
      .character-studio-mobile-card-traits span { background: var(--chip); border: 1px solid var(--ring); border-radius: 999px; padding: 4px 10px; font-size: 12px; }
      .character-studio-mobile-card-stats { display: grid; gap: 12px; grid-template-columns: repeat(3, minmax(0, 1fr)); }
      .character-studio-mobile-card-stats div { display: flex; flex-direction: column; gap: 2px; }
      .character-studio-mobile-card-stats dt { font-size: 11px; letter-spacing: .3px; text-transform: uppercase; color: var(--muted); margin: 0; }
      .character-studio-mobile-card-stats dd { margin: 0; font-size: 22px; font-weight: 600; }
      .character-studio-mobile-open {
        align-self: flex-start;
        border: 1px solid var(--ring);
        border-radius: 999px;
        padding: 10px 18px;
        background: var(--panel);
        color: var(--ink);
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
      }
      .character-studio-mobile-open:hover { border-color: var(--acc); }
      .character-studio-mobile-pagination { display: none; }
      .character-studio-mobile-dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        border: none;
        background: var(--ring);
        padding: 0;
        cursor: pointer;
      }
      .character-studio-mobile-dot[aria-current="true"] { background: var(--acc); box-shadow: 0 0 0 4px rgba(79, 123, 255, 0.18); }
      .character-studio-mobile-arrow { display: none; position: absolute; top: 50%; transform: translateY(-50%); width: 42px; height: 42px; border: none; border-radius: 999px; background: rgba(15, 18, 30, 0.65); color: #fff; align-items: center; justify-content: center; z-index: 4; cursor: pointer; transition: background .2s ease, opacity .2s ease; }
      .character-studio-mobile-arrow span { font-size: 22px; line-height: 1; }
      .character-studio-mobile-arrow:hover { background: rgba(15, 18, 30, 0.8); }
      .character-studio-mobile-arrow:focus-visible { outline: 2px solid var(--acc); outline-offset: 2px; }
      .character-studio-mobile-arrow[disabled] { opacity: 0.35; cursor: default; pointer-events: none; }
      .character-studio-mobile-arrow--prev { left: 12px; }
      .character-studio-mobile-arrow--next { right: 12px; }
      .character-studio-mobile-close {
        display: none;
        align-items: center;
        gap: 6px;
        border: none;
        background: transparent;
        color: var(--ink);
        font-size: 13px;
        font-weight: 600;
        padding: 12px 0 0;
        cursor: pointer;
      }
      @media (max-width: 1100px) {
        .character-studio-layout { grid-template-columns: 260px 1fr; }
      }
      @media (max-width: 920px) {
        .character-studio-body { padding: 22px 20px 26px; }
        .character-studio-layout { grid-template-columns: 1fr; }
        .character-studio-sidebar { order: 2; }
        .character-studio-details { order: 1; }
      }
      @media (max-width: 640px) {
        .character-studio-app { padding: 16px 12px; }
        .character-studio-header {
          flex-direction: column;
          align-items: flex-start;
          gap: 12px;
          padding: 14px 16px;
        }
        .character-studio-header-primary {
          width: 100%;
          gap: 12px;
        }
        .character-studio-header h2 { font-size: 20px; }
        .character-studio-header .muted-text { font-size: 12px; }
        .character-studio-header-badge { font-size: 10px; padding: 4px 10px; }
        .character-studio-header-actions {
          width: 100%;
          justify-content: flex-start;
          align-items: stretch;
          flex-direction: column;
          gap: 8px;
        }
        .character-studio-header-buttons {
          display: grid;
          grid-template-columns: repeat(2, minmax(0, 1fr));
          width: 100%;
          gap: 8px;
        }
        .character-studio-add,
        .character-studio-save { padding: 10px 0; font-size: 12px; }
        .character-studio-save { min-height: 40px; }
        .character-studio-window { border-radius: 16px; box-shadow: 0 26px 64px rgba(15, 18, 30, 0.35); }
        .character-studio-body {
          padding: 18px 0 24px;
          display: flex;
          flex-direction: column;
        }
        .character-studio-mobile {
          display: flex;
          flex-direction: column;
          gap: 16px;
          padding: 0;
          min-height: 0;
          flex: 1 1 auto;
          height: 100%;
        }
        .character-studio-mobile-track {
          flex: 1;
          height: 100%;
          gap: 0;
          overflow-x: auto;
          scroll-snap-type: x mandatory;
          padding-bottom: 0;
          margin: 0;
          padding-left: 0;
          padding-right: 0;
          -webkit-overflow-scrolling: touch;
        }
        .character-studio-mobile-track::-webkit-scrollbar { display: none; }
        .character-studio-mobile-card {
          flex: 0 0 100%;
          max-width: 100%;
          height: 100%;
          background: var(--card);
          border: none;
          border-radius: 0;
          overflow: hidden;
          flex-direction: column;
          min-height: 100%;
          scroll-snap-align: center;
          box-shadow: none;
          position: relative;
        }
        .character-studio-mobile-card.is-active { box-shadow: 0 32px 80px rgba(62, 114, 255, 0.28); }
        .character-studio-mobile-card-media { flex: 1 1 auto; background: var(--chip); }
        .character-studio-mobile-card-body { flex: 1 1 50%; overflow-y: auto; min-height: 0; }
        .character-studio-mobile-pagination { display: flex; justify-content: center; gap: 10px; padding-bottom: 12px; }
        .character-studio-mobile-arrow { display: inline-flex; }
        .character-studio-layout { display: none; padding: 0 16px 24px; }
        .character-studio-window[data-mobile-editor-open="true"] .character-studio-mobile { display: none; }
        .character-studio-window[data-mobile-editor-open="true"] .character-studio-layout { display: grid; position: relative; }
        .character-studio-window[data-mobile-editor-open="true"] .character-studio-mobile-close {
          display: inline-flex;
          position: sticky;
          top: 0;
          z-index: 3;
          width: 100%;
          background: var(--panel);
          padding: 14px 0;
        }
        .character-studio-window[data-mobile-editor-open="true"] {
          min-height: 100vh;
        }
        .character-studio-window[data-mobile-editor-open="true"] .character-studio-body {
          padding: 16px 16px 32px;
          flex: 1 1 auto;
        }
        .character-studio-window[data-mobile-editor-open="true"] .character-studio-layout {
          gap: 18px;
          display: flex;
          flex-direction: column;
          flex: 1 1 auto;
        }
        .character-studio-window[data-mobile-editor-open="true"] .character-studio-sidebar { display: none; }
        .character-studio-window[data-mobile-editor-open="true"] .character-studio-details {
          max-height: none;
          overflow: auto;
          flex: 1 1 auto;
        }
        .so-mobile-shell[data-page="character-studio"] .so-mobile-bottom-nav { display: none; }
      }
      
      /* Visual Refinement Panel Styles */
      .character-studio-refine {
        display: flex;
        flex-direction: column;
        gap: 18px;
      }
      .character-studio-refine-grid {
        display: grid;
        gap: 20px;
        grid-template-columns: minmax(280px, 1fr) minmax(320px, 1.2fr);
        align-items: start;
      }
      @media (max-width: 960px) {
        .character-studio-refine-grid {
          grid-template-columns: 1fr;
        }
      }
      .character-studio-refine-controls {
        display: flex;
        flex-direction: column;
        gap: 14px;
      }
      .character-studio-refine-preview-box {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .character-studio-refine-previews {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 14px;
      }
      @media (max-width: 640px) {
        .character-studio-refine-previews {
          grid-template-columns: 1fr;
        }
      }
      .character-studio-refine-preview-item {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .character-studio-refine-preview-label {
        font-size: 11px;
        color: var(--muted);
        letter-spacing: .3px;
        text-transform: uppercase;
        font-weight: 600;
      }
      .character-studio-refine-preview {
        position: relative;
        background: var(--panel);
        border: 1px dashed var(--ring);
        border-radius: 12px;
        min-height: 200px;
        aspect-ratio: 3 / 4;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }
      .character-studio-refine-preview img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      .character-studio-refine-preview-empty {
        font-size: 13px;
        color: var(--muted);
        text-align: center;
        padding: 16px;
        line-height: 1.45;
      }
      .character-studio-refine-loading {
        font-size: 13px;
        color: var(--muted);
        text-align: center;
        padding: 16px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }
      .character-studio-refine-loading-spinner {
        width: 32px;
        height: 32px;
        border: 3px solid var(--ring);
        border-top-color: var(--acc);
        border-radius: 50%;
        animation: character-studio-refine-spin 1s linear infinite;
      }
      @keyframes character-studio-refine-spin {
        to { transform: rotate(360deg); }
      }
      .character-studio-refine-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }
      .character-studio-refine-actions button {
        flex: 1;
        min-width: 140px;
        border: 1px solid var(--ring);
        border-radius: 12px;
        padding: 10px 16px;
        background: var(--panel);
        color: var(--ink);
        cursor: pointer;
        font-size: 13px;
        font-weight: 600;
        transition: all 0.2s ease;
      }
      .character-studio-refine-actions button:hover {
        border-color: var(--acc);
        background: var(--chip);
      }
      .character-studio-refine-actions button:focus-visible {
        outline: 2px solid var(--acc);
        outline-offset: 2px;
      }
      .character-studio-refine-actions button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .character-studio-refine-actions button.primary {
        background: var(--acc);
        border-color: var(--acc);
        color: var(--active-tab-text);
      }
      .character-studio-refine-actions button.primary:hover {
        box-shadow: 0 8px 24px rgba(79, 123, 255, 0.25);
      }
      .character-studio-refine-status {
        font-size: 12px;
        color: var(--muted);
        min-height: 18px;
        text-align: center;
      }
      .character-studio-refine-status[data-state="ready"] {
        color: var(--acc);
      }
      .character-studio-refine-status[data-state="warning"] {
        color: #f97316;
      }
      .character-studio-refine-status[data-state="error"] {
        color: #ef4444;
      }
      .character-studio-refine-status[data-state="refining"] {
        color: var(--brand);
      }
      .character-studio-refine-pill-group {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .character-studio-refine-pill {
        border: 1px solid var(--ring);
        border-radius: 999px;
        padding: 6px 12px;
        background: var(--panel);
        color: var(--ink);
        cursor: pointer;
        font-size: 12px;
        font-weight: 500;
        transition: all 0.2s ease;
      }
      .character-studio-refine-pill:hover {
        border-color: var(--acc);
        background: var(--chip);
      }
      .character-studio-refine-pill.selected {
        background: var(--acc);
        border-color: var(--acc);
        color: var(--active-tab-text);
      }
      .character-studio-refine-pill:focus-visible {
        outline: 2px solid var(--acc);
        outline-offset: 2px;
      }
      
      /* FinishThatStory AI Assistant Styles */
      .fts-overlay {
        position: fixed;
        inset: 0;
        z-index: 9999;
        display: none;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        transition: opacity 0.3s ease;
      }
      .fts-overlay.active {
        display: block;
      }
      .fts-dimmed {
        filter: blur(4px) brightness(0.6);
        pointer-events: none;
        transition: filter 0.3s ease;
      }
      .fts-highlighted {
        position: relative;
        z-index: 10000;
        filter: none !important;
        pointer-events: auto;
        animation: fts-glow 2s ease-in-out infinite;
        border-radius: 12px;
        box-shadow: 0 0 0 3px var(--acc), 0 0 30px rgba(79, 123, 255, 0.6);
      }
      @keyframes fts-glow {
        0%, 100% {
          box-shadow: 0 0 0 3px var(--acc), 0 0 30px rgba(79, 123, 255, 0.6);
        }
        50% {
          box-shadow: 0 0 0 3px var(--acc), 0 0 50px rgba(79, 123, 255, 0.9), 0 0 70px rgba(79, 123, 255, 0.5);
        }
      }
      .fts-assistant {
        position: fixed;
        z-index: 10001;
        background: var(--panel);
        border: 2px solid var(--acc);
        border-radius: 24px;
        padding: 28px 32px;
        box-shadow: 0 20px 80px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.1);
        max-width: 450px;
        min-width: 350px;
        display: none;
        animation: fts-slide-in 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      .fts-assistant.active {
        display: block;
      }
      @keyframes fts-slide-in {
        from {
          opacity: 0;
          transform: scale(0.9) translateY(20px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }
      .fts-assistant-header {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 20px;
      }
      .fts-assistant-icon {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        background: linear-gradient(135deg, #7c3aed, #22d3ee);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        box-shadow: 0 8px 24px rgba(124, 58, 237, 0.4);
      }
      .fts-assistant-title {
        flex: 1;
      }
      .fts-assistant-title h3 {
        margin: 0;
        font-size: 20px;
        font-weight: 600;
        background: linear-gradient(135deg, #7c3aed, #22d3ee);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      .fts-assistant-title p {
        margin: 4px 0 0;
        font-size: 12px;
        color: var(--muted);
      }
      .fts-assistant-content {
        margin-bottom: 24px;
      }
      .fts-question {
        font-size: 15px;
        line-height: 1.6;
        color: var(--ink);
        margin-bottom: 16px;
        padding: 16px;
        background: var(--chip);
        border-radius: 12px;
        border: 1px solid var(--ring);
      }
      .fts-question strong {
        display: block;
        margin-bottom: 8px;
        color: var(--acc);
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .fts-advice {
        font-size: 13px;
        line-height: 1.5;
        color: var(--muted);
        padding: 12px;
        background: var(--card);
        border-left: 3px solid var(--acc);
        border-radius: 8px;
        margin-top: 12px;
      }
      .fts-actions {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
      }
      .fts-btn {
        padding: 10px 24px;
        border-radius: 999px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        border: 1px solid var(--ring);
      }
      .fts-btn-primary {
        background: linear-gradient(135deg, #7c3aed, #22d3ee);
        color: white;
        border: none;
        box-shadow: 0 8px 24px rgba(124, 58, 237, 0.3);
      }
      .fts-btn-primary:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 32px rgba(124, 58, 237, 0.4);
      }
      .fts-btn-secondary {
        background: var(--panel);
        color: var(--ink);
      }
      .fts-btn-secondary:hover {
        border-color: var(--acc);
        background: var(--chip);
      }
      .fts-progress {
        font-size: 12px;
        color: var(--muted);
        text-align: center;
        margin-top: 16px;
        padding-top: 16px;
        border-top: 1px solid var(--ring);
      }
      
      /* Character Creation Wizard Styles */
      .character-studio-wizard-overlay {
        position: fixed;
        inset: 0;
        z-index: 9998;
        display: none;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        align-items: center;
        justify-content: center;
        padding: 20px;
      }
      .character-studio-wizard-overlay.active {
        display: flex;
      }
      .character-studio-wizard {
        position: relative;
        z-index: 9999;
        background: var(--panel);
        border: 2px solid var(--ring);
        border-radius: 24px;
        padding: 32px 40px;
        box-shadow: 0 36px 110px rgba(0, 0, 0, 0.45);
        max-width: 600px;
        width: 100%;
        display: none;
        flex-direction: column;
        gap: 24px;
        animation: character-studio-wizard-slide-in 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      .character-studio-wizard.active {
        display: flex;
      }
      @keyframes character-studio-wizard-slide-in {
        from {
          opacity: 0;
          transform: scale(0.95) translateY(20px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }
      .character-studio-wizard-step {
        font-size: 13px;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        font-weight: 600;
      }
      .character-studio-wizard-title {
        margin: 0;
        font-size: 26px;
        font-weight: 600;
        color: var(--ink);
      }
      .character-studio-wizard-archetypes {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 12px;
      }
      .character-studio-wizard-archetype {
        background: var(--card);
        border: 2px solid var(--ring);
        border-radius: 16px;
        padding: 20px 16px;
        text-align: center;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: center;
        font-size: 14px;
        font-weight: 600;
        color: var(--ink);
      }
      .character-studio-wizard-archetype:hover {
        border-color: var(--acc);
        box-shadow: 0 12px 32px rgba(79, 123, 255, 0.18);
        transform: translateY(-2px);
      }
      .character-studio-wizard-archetype.selected {
        background: var(--acc);
        border-color: var(--acc);
        color: var(--active-tab-text);
        box-shadow: 0 14px 36px rgba(62, 114, 255, 0.35);
        transform: translateY(-2px);
      }
      .character-studio-wizard-archetype-icon {
        font-size: 32px;
        line-height: 1;
      }
      .character-studio-wizard-validation {
        font-size: 13px;
        color: #ef4444;
        text-align: center;
        min-height: 18px;
      }
      .character-studio-wizard-actions {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
        padding-top: 8px;
      }
      .character-studio-wizard-btn {
        padding: 10px 24px;
        border-radius: 999px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        border: 1px solid var(--ring);
      }
      .character-studio-wizard-btn-primary {
        background: var(--acc);
        color: var(--active-tab-text);
        border-color: var(--acc);
        box-shadow: 0 8px 24px rgba(79, 123, 255, 0.28);
      }
      .character-studio-wizard-btn-primary:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 32px rgba(79, 123, 255, 0.35);
      }
      .character-studio-wizard-btn-primary:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
      }
      .character-studio-wizard-btn-secondary {
        background: var(--panel);
        color: var(--ink);
      }
      .character-studio-wizard-btn-secondary:hover {
        border-color: var(--acc);
        background: var(--chip);
      }
      .character-studio-wizard-step-content {
        display: none;
      }
      .character-studio-wizard-step-content.active {
        display: block;
      }
      .character-studio-wizard-preview {
        position: relative;
        background: var(--panel);
        border: 1px dashed var(--ring);
        border-radius: 12px;
        min-height: 300px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        margin-bottom: 16px;
      }
      .character-studio-wizard-preview img {
        max-width: 100%;
        max-height: 400px;
        object-fit: contain;
        display: block;
      }
      .character-studio-wizard-loading {
        font-size: 14px;
        color: var(--muted);
        text-align: center;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
      }
      .character-studio-wizard-loading-spinner {
        width: 40px;
        height: 40px;
        border: 3px solid var(--ring);
        border-top-color: var(--acc);
        border-radius: 50%;
        animation: character-studio-wizard-spin 1s linear infinite;
      }
      @keyframes character-studio-wizard-spin {
        to { transform: rotate(360deg); }
      }
      .character-studio-wizard-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-bottom: 16px;
      }
      .character-studio-wizard-control-btn {
        flex: 1;
        min-width: 120px;
        border: 1px solid var(--ring);
        border-radius: 10px;
        padding: 10px 16px;
        background: var(--panel);
        color: var(--ink);
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        transition: all 0.2s ease;
      }
      .character-studio-wizard-control-btn:hover {
        border-color: var(--acc);
        background: var(--chip);
      }
      .character-studio-wizard-control-btn:focus-visible {
        outline: 2px solid var(--acc);
        outline-offset: 2px;
      }
      .character-studio-wizard-save-actions {
        display: flex;
        gap: 12px;
        justify-content: center;
        margin-top: 16px;
        flex-wrap: wrap;
      }
      .character-studio-wizard-save-actions button {
        min-width: 140px;
      }
      .character-studio-wizard-save-actions button[data-wizard-save-character] {
        min-width: 200px;
      }
      @media (max-width: 640px) {
        .character-studio-wizard {
          padding: 24px 20px;
        }
        .character-studio-wizard-archetypes {
          grid-template-columns: repeat(2, 1fr);
        }
      }
    </style>

    <div class="character-studio-app">
      <div class="character-studio-window" data-character-window>
        <div class="character-studio-header">
          <div class="character-studio-header-primary">
            <span class="topbar__badge" aria-hidden="true">
              <img src="/assets/img/IMG_6894.webp" alt="" />
            </span>
            <div>
              <h2>Character Studio</h2>
              <p class="muted-text">Craft multidimensional characters with dedicated planners, lookbooks, and AI prompts.</p>
            </div>
          </div>
          <div class="character-studio-header-actions">
            <span class="character-studio-header-badge">Cast</span>
            <span class="character-studio-project" data-project-label></span>
            <div class="character-studio-header-buttons">
              <button class="character-studio-add" type="button" id="characterStudioAddBtn">+ New</button>
              <button class="character-studio-save" type="button" id="characterStudioSaveBtn" disabled>Save</button>
            </div>
            <span class="character-studio-save-status" data-save-status aria-live="polite"></span>
          </div>
        </div>
        <div class="character-studio-body">
          <section class="character-studio-mobile" data-character-mobile hidden>
            <button
              class="character-studio-mobile-arrow character-studio-mobile-arrow--prev"
              type="button"
              data-character-mobile-prev
              aria-label="View previous character"
              hidden
            >
              <span aria-hidden="true">‚Äπ</span>
            </button>
            <div class="character-studio-mobile-track" data-character-mobile-track></div>
            <button
              class="character-studio-mobile-arrow character-studio-mobile-arrow--next"
              type="button"
              data-character-mobile-next
              aria-label="View next character"
              hidden
            >
              <span aria-hidden="true">‚Ä∫</span>
            </button>
            <div class="character-studio-mobile-pagination" data-character-mobile-pagination></div>
          </section>
          <div class="character-studio-layout">
            <aside class="character-studio-sidebar">
              <div class="character-studio-sidebar-header">
                <h3>Characters</h3>
              </div>
              <p class="character-studio-sidebar-note">Keep track of stats, arcs, and visual references for every character in one place.</p>
              <div class="character-studio-sidebar-list" data-character-list></div>
            </aside>
            <section class="character-studio-details" data-character-details></section>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Character Creation Wizard -->
  <div class="character-studio-wizard-overlay" data-wizard-overlay>
    <div class="character-studio-wizard" data-wizard>
      <div class="character-studio-wizard-step" data-wizard-step>Step 1 of 3: Choose an archetype</div>
      
      <!-- Step 1: Choose archetype -->
      <div class="character-studio-wizard-step-content active" data-wizard-step-content="1">
        <h2 class="character-studio-wizard-title">What kind of character are you creating?</h2>
        <div class="character-studio-wizard-archetypes" data-wizard-archetypes>
          <button type="button" class="character-studio-wizard-archetype" data-archetype="hero">
            <span class="character-studio-wizard-archetype-icon">ü¶∏</span>
            <span>Hero</span>
          </button>
          <button type="button" class="character-studio-wizard-archetype" data-archetype="villain">
            <span class="character-studio-wizard-archetype-icon">ü¶π</span>
            <span>Villain</span>
          </button>
          <button type="button" class="character-studio-wizard-archetype" data-archetype="sci-fi">
            <span class="character-studio-wizard-archetype-icon">üöÄ</span>
            <span>Sci-Fi</span>
          </button>
          <button type="button" class="character-studio-wizard-archetype" data-archetype="fantasy">
            <span class="character-studio-wizard-archetype-icon">üßô</span>
            <span>Fantasy</span>
          </button>
          <button type="button" class="character-studio-wizard-archetype" data-archetype="child">
            <span class="character-studio-wizard-archetype-icon">üë∂</span>
            <span>Child</span>
          </button>
          <button type="button" class="character-studio-wizard-archetype" data-archetype="robot">
            <span class="character-studio-wizard-archetype-icon">ü§ñ</span>
            <span>Robot</span>
          </button>
        </div>
        <div class="character-studio-wizard-validation" data-wizard-validation></div>
      </div>
      
      <!-- Step 2: First visual draft -->
      <div class="character-studio-wizard-step-content" data-wizard-step-content="2">
        <h2 class="character-studio-wizard-title">First visual draft</h2>
        <div class="character-studio-wizard-preview" data-wizard-preview>
          <div class="character-studio-wizard-loading" data-wizard-loading>
            <div class="character-studio-wizard-loading-spinner"></div>
            <span>Generating your first look‚Ä¶</span>
          </div>
        </div>
        <div class="character-studio-wizard-controls">
          <button type="button" class="character-studio-wizard-control-btn" data-wizard-regenerate>Regenerate</button>
          <button type="button" class="character-studio-wizard-control-btn" data-wizard-swap-style>Swap Style</button>
          <button type="button" class="character-studio-wizard-control-btn" data-wizard-try-another>Try Another Idea</button>
        </div>
      </div>
      
      <!-- Step 3: Save Character -->
      <div class="character-studio-wizard-step-content" data-wizard-step-content="3">
        <h2 class="character-studio-wizard-title">Save your character</h2>
        <div class="character-studio-wizard-preview" data-wizard-preview-step3>
          <!-- Preview will be copied here -->
        </div>
        <div class="character-studio-wizard-validation" data-wizard-save-status></div>
        <div class="character-studio-wizard-save-actions">
          <button type="button" class="character-studio-wizard-btn character-studio-wizard-btn-secondary" data-wizard-back-to-step2>‚Üê Back</button>
          <button type="button" class="character-studio-wizard-btn character-studio-wizard-btn-primary" data-wizard-save-character>Save Character</button>
        </div>
      </div>
      
      <div class="character-studio-wizard-actions">
        <button type="button" class="character-studio-wizard-btn character-studio-wizard-btn-secondary" data-wizard-cancel>Cancel</button>
        <button type="button" class="character-studio-wizard-btn character-studio-wizard-btn-primary" data-wizard-continue>Continue</button>
      </div>
    </div>
  </div>

  <!-- FinishThatStory AI Assistant Overlay -->
  <div class="fts-overlay" data-fts-overlay></div>
  <div class="fts-assistant" data-fts-assistant>
    <div class="fts-assistant-header">
      <div class="fts-assistant-icon">‚ú®</div>
      <div class="fts-assistant-title">
        <h3>FinishThatStory</h3>
        <p>AI Character Assistant</p>
      </div>
    </div>
    <div class="fts-assistant-content">
      <div class="fts-question" data-fts-question>
        <strong data-fts-field-name>Field Name</strong>
        <p data-fts-question-text>Question text will appear here...</p>
      </div>
      <div class="fts-advice" data-fts-advice></div>
    </div>
    <div class="fts-actions">
      <button class="fts-btn fts-btn-secondary" type="button" data-fts-skip>Skip</button>
      <button class="fts-btn fts-btn-primary" type="button" data-fts-next>Next</button>
    </div>
    <div class="fts-progress" data-fts-progress>Field 1 of 10</div>
  </div>

  <footer class="footer">
    <div class="footer__grid">
      <div>
        <strong>StudioOrganize</strong>
        <p class="muted">Tools for storytellers &amp; focused work.</p>
      </div>
      <div>
        <a href="/about.html">About</a><br />
      </div>
      <div>
        <a href="mailto:support@studioorganize.com">support@studioorganize.com</a><br />
        <span class="muted">¬© <span id="y"></span> StudioOrganize</span>
      </div>
    </div>
  </footer>

  <script>
    (function(){
      const CHARACTER_LOOK_LABELS = {
        portrait: 'Portrait',
        turnaround: 'Turnaround Sheet',
        expression: 'Expression Sheet'
      };

      const CHARACTER_TAB_CONFIG = [
        { id: 'profile', label: 'Profile' },
        { id: 'stats', label: 'Stats & Spotlight' },
        { id: 'dialog', label: 'Dialog' },
        { id: 'traits', label: 'Traits & Personality' },
        { id: 'background', label: 'Background & Family' },
        { id: 'arc', label: 'Character Arc' },
        { id: 'lookbook', label: 'Lookbook' },
        { id: 'poses', label: 'Pose Library' },
        { id: 'ai', label: 'AI Concepting' }
      ];

      const initialCharacters = [];

      const UUID_V4_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

      function isValidUuid(value){
        if (typeof value !== 'string') return false;
        const trimmed = value.trim();
        return UUID_V4_REGEX.test(trimmed);
      }

      function normalizeProjectId(value){
        if (typeof value !== 'string') return null;
        const trimmed = value.trim();
        return trimmed ? trimmed : null;
      }

      function getStoredProjectId(){
        try {
          const raw = localStorage.getItem('SW_LAST_PROJECT_ID');
          return normalizeProjectId(raw);
        } catch (err){
          return null;
        }
      }

      function setStoredProjectId(projectId){
        try {
          if (projectId){
            localStorage.setItem('SW_LAST_PROJECT_ID', projectId);
          } else {
            localStorage.removeItem('SW_LAST_PROJECT_ID');
          }
        } catch (err){
          /* ignore storage errors */
        }
      }

      function getProjectIdFromQuery(){
        try {
          const params = new URLSearchParams(window.location.search);
          const keys = ['projectId', 'project', 'scriptId', 'script'];
          for (const key of keys){
            const value = params.get(key);
            const normalized = normalizeProjectId(value);
            if (normalized) return normalized;
          }
        } catch (err){
          /* ignore malformed query strings */
        }
        return null;
      }

      const queryProjectId = getProjectIdFromQuery();
      if (queryProjectId) setStoredProjectId(queryProjectId);

      const storedProjectId = queryProjectId || getStoredProjectId();

      const state = {
        characters: initialCharacters.map(normalizeCharacter),
        activeId: initialCharacters.length ? initialCharacters[0].id : null,
        activeTabId: 'profile',
        projectId: storedProjectId,
        supabase: null,
        session: null,
        ownerId: null,
        projectLabel: '',
        projectLabelState: '',
        loading: Boolean(storedProjectId),
        saving: false,
        dirty: false,
        saveStatus: '',
        saveStatusState: '',
        remoteIds: new Set(initialCharacters.map(char => char.id)),
        signedUrlCache: new Map(),
        poseCache: new Map(),
        scenes: [],
        scenesLoaded: false,
        scenesLoading: false,
        scenesError: '',
        dialogDrafts: new Map(),
        dialogDraftsLoaded: false,
        dialogStatus: '',
        dialogStatusState: '',
        dialogStatusCharacterId: null
      };

      const DIALOG_DRAFT_STORAGE_PREFIX = 'SW_DIALOG_DRAFTS_';

      const mobileViewportQuery = window.matchMedia('(max-width: 640px)');
      let mobileGalleryScrollTimer = null;
      let mobileGallerySyncingFromScroll = false;

      const LOCAL_DB_NAME = 'sw_db_v1';
      const LOCAL_DB_STORE = 'projects';
      const LOCAL_PERSIST_DELAY_MS = 400;
      let localDb = null;
      let localPersistTimer = null;

      function openLocalProjectDb(){
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(LOCAL_DB_NAME, 1);
          request.onupgradeneeded = event => {
            const database = event.target.result;
            if (!database.objectStoreNames.contains(LOCAL_DB_STORE)){
              database.createObjectStore(LOCAL_DB_STORE, { keyPath: 'projectId' });
            }
          };
          request.onsuccess = event => {
            localDb = event.target.result;
            resolve();
          };
          request.onerror = event => reject(event);
        });
      }

      async function ensureLocalDb(){
        if (localDb) return true;
        try {
          await openLocalProjectDb();
          return !!localDb;
        } catch (err){
          console.warn('Character Studio failed to open local project database', err);
          return false;
        }
      }

      function loadProjectFromLocalStore(projectId){
        return new Promise((resolve, reject) => {
          if (!localDb){
            resolve(null);
            return;
          }
          const tx = localDb.transaction([LOCAL_DB_STORE], 'readonly');
          const store = tx.objectStore(LOCAL_DB_STORE);
          const request = store.get(projectId);
          request.onsuccess = () => resolve(request.result || null);
          request.onerror = event => reject(event);
        });
      }

      function saveProjectToLocalStore(project){
        return new Promise((resolve, reject) => {
          if (!localDb){
            resolve();
            return;
          }
          const tx = localDb.transaction([LOCAL_DB_STORE], 'readwrite');
          tx.objectStore(LOCAL_DB_STORE).put(project);
          tx.oncomplete = () => resolve();
          tx.onerror = event => reject(event);
        });
      }

      async function persistCharactersToLocal(){
        if (!state.projectId) return;
        localPersistTimer = null;
        const ready = await ensureLocalDb();
        if (!ready) return;
        try {
          const project = await loadProjectFromLocalStore(state.projectId);
          if (!project || typeof project !== 'object') return;
          const nextCharacters = state.characters.map(normalizeCharacter);
          const catalogs = project.catalogs && typeof project.catalogs === 'object'
            ? project.catalogs
            : {};
          const previous = Array.isArray(catalogs.characters) ? catalogs.characters : [];
          const previousJson = JSON.stringify(previous);
          const nextJson = JSON.stringify(nextCharacters);
          if (previousJson === nextJson) return;
          catalogs.characters = nextCharacters;
          project.catalogs = catalogs;
          project.updatedAt = Date.now();
          await saveProjectToLocalStore(project);
        } catch (err){
          console.warn('Character Studio failed to persist characters locally', err);
        }
      }

      function scheduleLocalPersist(){
        if (!state.projectId) return;
        if (localPersistTimer) window.clearTimeout(localPersistTimer);
        localPersistTimer = window.setTimeout(() => {
          persistCharactersToLocal().catch(err => {
            console.warn('Character Studio failed to schedule local character save', err);
          });
        }, LOCAL_PERSIST_DELAY_MS);
      }

      async function hydrateCharactersFromLocal(){
        if (!state.projectId) return;
        const ready = await ensureLocalDb();
        if (!ready) return;
        try {
          const project = await loadProjectFromLocalStore(state.projectId);
          if (!project || typeof project !== 'object') return;
          const list = Array.isArray(project?.catalogs?.characters)
            ? project.catalogs.characters.map(normalizeCharacter)
            : [];
          if (!list.length) return;
          state.characters = list;
          ensureStateCharacterIds();
          if (!list.some(char => char.id === state.activeId)){
            state.activeId = list.length ? list[0].id : null;
          }
          state.dirty = true;
          renderCharacterList();
          renderCharacterDetails();
          updateSaveButtonState();
          if (state.session && state.projectId){
            setSaveStatus('Unsaved changes', 'warning');
          } else {
            setSaveStatus('Unsaved changes (sign in to sync)', 'warning');
          }
        } catch (err){
          console.warn('Character Studio failed to load characters from the Writer workspace', err);
        }
      }

      function getDialogDraftStorageKey(projectId){
        if (!projectId) return null;
        return `${DIALOG_DRAFT_STORAGE_PREFIX}${projectId}`;
      }

      function normalizeDialogDraft(draft){
        if (!draft || typeof draft !== 'object') return null;
        const text = typeof draft.text === 'string' ? draft.text.trim() : '';
        if (!text) return null;
        const id = typeof draft.id === 'string' && draft.id ? draft.id : createId();
        const createdAtRaw = draft.createdAt;
        const createdAt = Number.isFinite(Number(createdAtRaw)) ? Number(createdAtRaw) : Date.now();
        return { id, text, createdAt };
      }

      function ensureDialogDraftMap(){
        if (!(state.dialogDrafts instanceof Map)){
          state.dialogDrafts = new Map();
        }
      }

      function hydrateDialogDrafts(){
        if (!state.projectId || state.dialogDraftsLoaded) return;
        ensureDialogDraftMap();
        state.dialogDraftsLoaded = true;
        const key = getDialogDraftStorageKey(state.projectId);
        if (!key) return;
        try {
          const raw = localStorage.getItem(key);
          if (!raw) return;
          const parsed = JSON.parse(raw);
          if (!parsed || typeof parsed !== 'object') return;
          Object.entries(parsed).forEach(([characterId, list]) => {
            if (!characterId || !Array.isArray(list)) return;
            const normalized = list.map(normalizeDialogDraft).filter(Boolean);
            if (normalized.length){
              state.dialogDrafts.set(characterId, normalized);
            }
          });
        } catch (err){
          console.warn('Character Studio failed to load dialog drafts', err);
        }
      }

      function persistDialogDrafts(){
        if (!state.projectId) return;
        ensureDialogDraftMap();
        const key = getDialogDraftStorageKey(state.projectId);
        if (!key) return;
        try {
          const payload = {};
          state.dialogDrafts.forEach((drafts, characterId) => {
            if (!Array.isArray(drafts) || !drafts.length) return;
            payload[characterId] = drafts.map(entry => ({
              id: entry.id,
              text: entry.text,
              createdAt: Number.isFinite(Number(entry.createdAt)) ? Number(entry.createdAt) : Date.now()
            }));
          });
          if (Object.keys(payload).length){
            localStorage.setItem(key, JSON.stringify(payload));
          } else {
            localStorage.removeItem(key);
          }
        } catch (err){
          console.warn('Character Studio failed to persist dialog drafts', err);
        }
      }

      function getDialogDraftsForCharacter(characterId){
        if (!characterId) return [];
        ensureDialogDraftMap();
        const drafts = state.dialogDrafts.get(characterId);
        if (!Array.isArray(drafts)) return [];
        return drafts.slice().sort((a, b) => {
          const aTime = Number.isFinite(Number(a.createdAt)) ? Number(a.createdAt) : 0;
          const bTime = Number.isFinite(Number(b.createdAt)) ? Number(b.createdAt) : 0;
          return aTime - bTime;
        });
      }

      function addDialogDraftForCharacter(characterId, text){
        const trimmed = typeof text === 'string' ? text.trim() : '';
        if (!characterId || !trimmed) return null;
        const draft = normalizeDialogDraft({ id: createId(), text: trimmed, createdAt: Date.now() });
        if (!draft) return null;
        const current = getDialogDraftsForCharacter(characterId);
        state.dialogDrafts.set(characterId, [...current, draft]);
        persistDialogDrafts();
        return draft;
      }

      function removeDialogDraft(characterId, draftId){
        if (!characterId || !draftId) return false;
        const current = getDialogDraftsForCharacter(characterId);
        const next = current.filter(entry => entry.id !== draftId);
        if (next.length === current.length) return false;
        if (next.length){
          state.dialogDrafts.set(characterId, next);
        } else {
          state.dialogDrafts.delete(characterId);
        }
        persistDialogDrafts();
        return true;
      }

      function applyDialogStatus(context){
        const root = context || document;
        const statusEl = root.querySelector('[data-character-dialog-status]');
        if (!statusEl) return;
        statusEl.textContent = state.dialogStatus || '';
        if (state.dialogStatusState){
          statusEl.dataset.state = state.dialogStatusState;
        } else {
          statusEl.removeAttribute('data-state');
        }
      }

      function setDialogStatus(message, status = '', characterId = state.activeId){
        state.dialogStatus = message || '';
        state.dialogStatusState = status || '';
        state.dialogStatusCharacterId = characterId || null;
        applyDialogStatus(document);
      }

      function setProjectLabel(text, status = ''){
        state.projectLabel = text || '';
        state.projectLabelState = status || '';
        const labelEl = document.querySelector('[data-project-label]');
        if (!labelEl) return;
        const content = state.projectLabel || '';
        labelEl.textContent = content;
        if (status){
          labelEl.dataset.state = status;
        } else {
          labelEl.removeAttribute('data-state');
        }
        labelEl.hidden = false;
      }

      function setSaveStatus(message, status = ''){
        state.saveStatus = message || '';
        state.saveStatusState = status || '';
        const statusEl = document.querySelector('[data-save-status]');
        if (!statusEl) return;
        statusEl.textContent = state.saveStatus;
        if (status){
          statusEl.dataset.state = status;
        } else {
          statusEl.removeAttribute('data-state');
        }
      }

      function updateSaveButtonState(){
        const btn = document.getElementById('characterStudioSaveBtn');
        if (!btn) return;
        const disabled = state.saving || state.loading || !state.supabase || !state.session || !state.ownerId || !state.projectId || !state.dirty;
        btn.disabled = disabled;
        btn.setAttribute('aria-disabled', disabled ? 'true' : 'false');
        btn.textContent = state.saving ? 'Saving‚Ä¶' : 'Save';
      }

      function markDirty(){
        state.dirty = true;
        updateSaveButtonState();
        scheduleLocalPersist();
        if (state.saving) return;
        if (state.session && state.projectId){
          setSaveStatus('Unsaved changes', 'warning');
        } else {
          setSaveStatus('Unsaved changes (sign in to sync)', 'warning');
        }
      }

      function ensureStateCharacterIds(){
        let updated = false;
        const replacements = new Map();
        state.characters.forEach(character => {
          if (!character || typeof character !== 'object') return;
          const rawId = typeof character.id === 'string' ? character.id.trim() : '';
          if (isValidUuid(rawId)) return;
          const nextId = createId();
          const previousId = rawId;
          character.id = nextId;
          replacements.set(previousId, nextId);
          updated = true;
        });
        if (!updated) return false;
        replacements.forEach((nextId, previousId) => {
          if (state.remoteIds?.has(previousId)){
            state.remoteIds.delete(previousId);
          }
          if (state.activeId === previousId){
            state.activeId = nextId;
          }
        });
        markDirty();
        return true;
      }

      function escapeHtml(value){
        return String(value ?? '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function normalizeList(value){
        if (Array.isArray(value)) return value.map(v => String(v || '').trim()).filter(Boolean);
        if (typeof value === 'string') return value.split(/\r?\n+/).map(v => v.trim()).filter(Boolean);
        return [];
      }

      function parseStorageUrl(value){
        if (typeof value !== 'string') return null;
        const trimmed = value.trim();
        if (!trimmed) return null;
        const [bucket, ...rest] = trimmed.split('/');
        if (!bucket || !rest.length) return null;
        return { bucket, path: rest.join('/') };
      }

      function invalidateSignedUrl(path){
        if (!path || !state?.signedUrlCache) return;
        state.signedUrlCache.delete(path);
      }

      async function getSignedUrlForPath(path){
        if (!path || !state.supabase) return null;
        if (state.signedUrlCache.has(path)){
          return state.signedUrlCache.get(path);
        }
        const storage = parseStorageUrl(path);
        if (!storage) return null;
        try {
          const { data, error } = await state.supabase.storage
            .from(storage.bucket)
            .createSignedUrl(storage.path, 3600);
          if (error) throw error;
          const url = data?.signedUrl || null;
          if (url) state.signedUrlCache.set(path, url);
          return url;
        } catch (err){
          console.warn('Character Studio failed to sign storage path', err);
          return null;
        }
      }

      function readFileAsDataUrl(file){
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = event => reject(event);
          reader.readAsDataURL(file);
        });
      }

      function createId(){
        if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function'){
          try { return crypto.randomUUID(); }
          catch (err){}
        }
        let d = Date.now();
        let d2 = (typeof performance !== 'undefined' && typeof performance.now === 'function')
          ? performance.now() * 1000
          : 0;
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
          let r = Math.random() * 16;
          if (d > 0){
            r = (d + r) % 16 | 0;
            d = Math.floor(d / 16);
          } else {
            r = (d2 + r) % 16 | 0;
            d2 = Math.floor(d2 / 16);
          }
          return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);
        });
      }

      function createCharacterData(name = ''){
        return {
          id: createId(),
          name,
          role: '',
          archetype: '',
          pronouns: '',
          age: '',
          summary: '',
          traits: [],
          background: '',
          familyTree: '',
          stats: { scenes: 0, dialogue: 0, screenTime: 0 },
          arc: { setup: '', development: '', resolution: '' },
          looks: { portrait: '', turnarounds: [], expressions: [] },
          ai: { prompt: '', notes: '' },
          baseImageUrl: '',
          hasPoseLibrary: false
        };
      }

      function normalizeCharacter(item){
        const base = createCharacterData(item?.name || 'Untitled Character');
        if (!item || typeof item !== 'object') return base;
        const normalized = { ...base, ...item };
        const rawId = typeof item.id === 'string' ? item.id.trim() : '';
        const hasValidId = isValidUuid(rawId);
        normalized.id = hasValidId ? rawId : base.id;
        if (!hasValidId && item && typeof item === 'object'){
          item.id = normalized.id;
        }
        normalized.name = typeof item.name === 'string' ? item.name : base.name;
        normalized.role = typeof item.role === 'string' ? item.role : '';
        normalized.archetype = typeof item.archetype === 'string' ? item.archetype : '';
        normalized.pronouns = typeof item.pronouns === 'string' ? item.pronouns : '';
        if (typeof item.age === 'number') normalized.age = String(item.age);
        else if (typeof item.age === 'string') normalized.age = item.age;
        normalized.summary = typeof item.summary === 'string' ? item.summary : '';
        normalized.background = typeof item.background === 'string' ? item.background : '';
        normalized.familyTree = typeof item.familyTree === 'string' ? item.familyTree : '';
        normalized.traits = normalizeList(item.traits);
        normalized.stats = { ...base.stats, ...(item.stats || {}) };
        normalized.arc = { ...base.arc, ...(item.arc || {}) };
        normalized.looks = { ...base.looks, ...(item.looks || {}) };
        normalized.looks.turnarounds = normalizeList(normalized.looks.turnarounds);
        normalized.looks.expressions = normalizeList(normalized.looks.expressions);
        normalized.ai = { ...base.ai, ...(item.ai || {}) };
        normalized.baseImageUrl = typeof item.baseImageUrl === 'string' ? item.baseImageUrl : '';
        normalized.hasPoseLibrary = Boolean(item.hasPoseLibrary);
        return normalized;
      }

      function supabaseRowToCharacter(row){
        if (!row || typeof row !== 'object') return createCharacterData('Untitled Character');
        const screenTimeValue = typeof row.stats_screen_time === 'number'
          ? row.stats_screen_time
          : Number(row.stats_screen_time);
        const normalized = {
          id: row.id || createId(),
          name: typeof row.name === 'string' ? row.name : '',
          role: typeof row.role === 'string' ? row.role : '',
          archetype: typeof row.archetype === 'string' ? row.archetype : '',
          pronouns: typeof row.pronouns === 'string' ? row.pronouns : '',
          age: typeof row.age === 'string' ? row.age : (typeof row.age === 'number' ? String(row.age) : ''),
          summary: typeof row.summary === 'string' ? row.summary : '',
          background: typeof row.background === 'string' ? row.background : '',
          familyTree: typeof row.family_tree === 'string' ? row.family_tree : '',
          traits: Array.isArray(row.traits) ? row.traits : [],
          stats: {
            scenes: Number.isFinite(row.stats_scenes) ? row.stats_scenes : 0,
            dialogue: Number.isFinite(row.stats_dialogue) ? row.stats_dialogue : 0,
            screenTime: Number.isFinite(screenTimeValue) ? Number(screenTimeValue) : 0
          },
          arc: {
            setup: typeof row.arc_setup === 'string' ? row.arc_setup : '',
            development: typeof row.arc_development === 'string' ? row.arc_development : '',
            resolution: typeof row.arc_resolution === 'string' ? row.arc_resolution : ''
          },
          looks: {
            portrait: typeof row.look_portrait_url === 'string' ? row.look_portrait_url : '',
            turnarounds: Array.isArray(row.look_turnaround_urls) ? row.look_turnaround_urls : [],
            expressions: Array.isArray(row.look_expression_urls) ? row.look_expression_urls : []
          },
          ai: {
            prompt: typeof row.ai_prompt === 'string' ? row.ai_prompt : '',
            notes: typeof row.ai_notes === 'string' ? row.ai_notes : ''
          },
          baseImageUrl: typeof row.base_image_url === 'string' ? row.base_image_url : '',
          hasPoseLibrary: Boolean(row.has_pose_library)
        };
        return normalizeCharacter(normalized);
      }

      function characterToSupabaseRow(character){
        const normalized = normalizeCharacter(character);
        const traits = normalizeList(normalized.traits);
        const turnarounds = normalizeList(normalized.looks?.turnarounds || []);
        const expressions = normalizeList(normalized.looks?.expressions || []);
        const statsScenes = Number.isFinite(normalized.stats?.scenes) ? normalized.stats.scenes : 0;
        const statsDialogue = Number.isFinite(normalized.stats?.dialogue) ? normalized.stats.dialogue : 0;
        const statsScreenTime = Number.isFinite(normalized.stats?.screenTime)
          ? Number(normalized.stats.screenTime)
          : 0;
        return {
          id: normalized.id,
          owner_id: state.ownerId,
          project_id: state.projectId,
          name: normalized.name || '',
          role: normalized.role || null,
          archetype: normalized.archetype || null,
          pronouns: normalized.pronouns || null,
          age: normalized.age || null,
          summary: normalized.summary || null,
          background: normalized.background || null,
          family_tree: normalized.familyTree || null,
          traits,
          stats_scenes: statsScenes,
          stats_dialogue: statsDialogue,
          stats_screen_time: statsScreenTime,
          arc_setup: normalized.arc?.setup || null,
          arc_development: normalized.arc?.development || null,
          arc_resolution: normalized.arc?.resolution || null,
          look_portrait_url: normalized.looks?.portrait || null,
          look_turnaround_urls: turnarounds,
          look_expression_urls: expressions,
          base_image_url: normalized.baseImageUrl || null,
          has_pose_library: Boolean(normalized.hasPoseLibrary),
          ai_prompt: normalized.ai?.prompt || null,
          ai_notes: normalized.ai?.notes || null,
          updated_at: new Date().toISOString()
        };
      }

      function canonicalizeCharacterRowForVerification(row){
        const toList = value => Array.isArray(value)
          ? value.map(item => String(item || '').trim()).filter(Boolean)
          : [];
        const id = typeof row.id === 'string' ? row.id : (row.id ? String(row.id) : '');
        return {
          id,
          owner_id: typeof row.owner_id === 'string' ? row.owner_id : (row.owner_id ? String(row.owner_id) : null),
          project_id: typeof row.project_id === 'string' ? row.project_id : (row.project_id ? String(row.project_id) : null),
          name: typeof row.name === 'string' ? row.name : '',
          role: typeof row.role === 'string' && row.role ? row.role : null,
          archetype: typeof row.archetype === 'string' && row.archetype ? row.archetype : null,
          pronouns: typeof row.pronouns === 'string' && row.pronouns ? row.pronouns : null,
          age: typeof row.age === 'string' ? row.age : (row.age === null || typeof row.age === 'undefined' ? null : String(row.age)),
          summary: typeof row.summary === 'string' && row.summary ? row.summary : null,
          background: typeof row.background === 'string' && row.background ? row.background : null,
          family_tree: typeof row.family_tree === 'string' && row.family_tree ? row.family_tree : null,
          traits: toList(row.traits),
          stats_scenes: Number.isFinite(row.stats_scenes) ? Number(row.stats_scenes) : 0,
          stats_dialogue: Number.isFinite(row.stats_dialogue) ? Number(row.stats_dialogue) : 0,
          stats_screen_time: Number.isFinite(row.stats_screen_time) ? Number(row.stats_screen_time) : 0,
          arc_setup: typeof row.arc_setup === 'string' && row.arc_setup ? row.arc_setup : null,
          arc_development: typeof row.arc_development === 'string' && row.arc_development ? row.arc_development : null,
          arc_resolution: typeof row.arc_resolution === 'string' && row.arc_resolution ? row.arc_resolution : null,
          look_portrait_url: typeof row.look_portrait_url === 'string' && row.look_portrait_url ? row.look_portrait_url : null,
          look_turnaround_urls: toList(row.look_turnaround_urls),
          look_expression_urls: toList(row.look_expression_urls),
          base_image_url: typeof row.base_image_url === 'string' && row.base_image_url ? row.base_image_url : null,
          has_pose_library: Boolean(row.has_pose_library),
          ai_prompt: typeof row.ai_prompt === 'string' && row.ai_prompt ? row.ai_prompt : null,
          ai_notes: typeof row.ai_notes === 'string' && row.ai_notes ? row.ai_notes : null
        };
      }

      function prepareCharacterRowsForVerification(rows){
        if (!Array.isArray(rows)) return [];
        return rows
          .map(canonicalizeCharacterRowForVerification)
          .sort((a, b) => {
            const idA = a.id || '';
            const idB = b.id || '';
            return idA.localeCompare(idB);
          })
          .map(row => ({
            ...row,
            traits: row.traits.slice(),
            look_turnaround_urls: row.look_turnaround_urls.slice(),
            look_expression_urls: row.look_expression_urls.slice()
          }));
      }

      function getActiveCharacter(){
        if (!state.activeId) return null;
        return state.characters.find(char => char.id === state.activeId) || null;
      }

      function characterSidebarMeta(character){
        if (!character) return '';
        if (character.role) return character.role;
        if (character.archetype) return character.archetype;
        const identity = [character.pronouns, character.age].filter(Boolean).join(' ‚Ä¢ ');
        if (identity) return identity;
        return 'Tap to detail profile';
      }

      function buildCharacterSubheading(character){
        if (!character) return '';
        const parts = [];
        if (character.role) parts.push(character.role);
        const identity = [character.pronouns, character.age].filter(Boolean).join(' ‚Ä¢ ');
        if (identity) parts.push(identity);
        if (character.archetype) parts.push(character.archetype);
        return parts.join(' ‚Äî ');
      }

      function buildTraitsPreviewMarkup(character){
        const traits = Array.isArray(character?.traits) ? character.traits : [];
        if (!traits.length) return '<span class="muted-text">Add traits to see quick reference chips.</span>';
        return traits.map(trait => `<span class="character-studio-chip"><strong>${escapeHtml(trait)}</strong></span>`).join('');
      }

      function normalizeSceneElementLite(element){
        if (!element || typeof element !== 'object'){
          return { t: 'action', txt: '', ownerId: null, storyPart: null, storyBeat: null };
        }
        const type = typeof element.t === 'string' && element.t ? element.t : 'action';
        const text = typeof element.txt === 'string' ? element.txt : '';
        const ownerId = typeof element.ownerId === 'string' && element.ownerId ? element.ownerId : null;
        const storyPart = typeof element.storyPart === 'string' ? element.storyPart : null;
        const storyBeat = typeof element.storyBeat === 'string' ? element.storyBeat : null;
        return { t: type, txt: text, ownerId, storyPart, storyBeat };
      }

      function supabaseRowToScene(row){
        if (!row || typeof row !== 'object') return null;
        const elements = Array.isArray(row.elements) ? row.elements.map(normalizeSceneElementLite) : [];
        const rawOrder = Number.isFinite(row.script_order) ? Number(row.script_order) : null;
        const sceneNumber = Number.isFinite(row.scene_number) ? Number(row.scene_number) : null;
        const title = typeof row.title === 'string' ? row.title : '';
        const slug = typeof row.slug === 'string' ? row.slug : '';
        return {
          id: row.id || createId(),
          title,
          slug,
          scriptOrder: rawOrder !== null ? rawOrder : (sceneNumber !== null ? sceneNumber - 1 : 0),
          sceneNumber,
          elements
        };
      }

      function getSceneDisplayLabel(scene){
        if (!scene) return 'Untitled scene';
        const title = typeof scene.title === 'string' ? scene.title.trim() : '';
        const slug = typeof scene.slug === 'string' ? scene.slug.trim() : '';
        const sceneNumber = Number.isFinite(scene.sceneNumber) ? scene.sceneNumber : null;
        if (sceneNumber && title) return `Scene ${sceneNumber}: ${title}`;
        if (sceneNumber && slug) return `Scene ${sceneNumber}: ${slug}`;
        if (sceneNumber) return `Scene ${sceneNumber}`;
        return title || slug || 'Untitled scene';
      }

      function buildSceneOptionsMarkup(selectedId = ''){
        const scenes = Array.isArray(state.scenes) ? state.scenes : [];
        if (!scenes.length){
          return '<option value="">No scenes available</option>';
        }
        const options = scenes.map(scene => {
          const value = typeof scene.id === 'string' ? scene.id : '';
          const selected = value && value === selectedId ? ' selected' : '';
          return `<option value="${escapeHtml(value)}"${selected}>${escapeHtml(getSceneDisplayLabel(scene))}</option>`;
        }).join('');
        return `<option value="">Select a scene‚Ä¶</option>${options}`;
      }

      function formatDialogText(text){
        const trimmed = typeof text === 'string' ? text.trim() : '';
        if (!trimmed) return '';
        return escapeHtml(trimmed).replace(/\r?\n/g, '<br />');
      }

      function gatherCharacterDialogues(character){
        if (!character) return [];
        const scenes = Array.isArray(state.scenes) ? state.scenes : [];
        const characterId = typeof character.id === 'string' ? character.id : '';
        const name = typeof character.name === 'string' ? character.name.trim() : '';
        const lowerName = name.toLowerCase();
        const results = [];
        scenes.forEach(scene => {
          const elements = Array.isArray(scene.elements) ? scene.elements : [];
          elements.forEach((element, index) => {
            const normalized = normalizeSceneElementLite(element);
            if (normalized.t !== 'dialogue') return;
            const text = typeof normalized.txt === 'string' ? normalized.txt.trim() : '';
            if (!text) return;
            const ownerId = typeof normalized.ownerId === 'string' ? normalized.ownerId : '';
            let matchedByName = false;
            let matches = ownerId && characterId ? ownerId === characterId : false;
            if (!matches && lowerName){
              if (text.toLowerCase().includes(lowerName)){
                matches = true;
                matchedByName = true;
              }
            }
            if (!matches) return;
            results.push({
              id: `${scene.id || 'scene'}-${index}`,
              sceneId: scene.id || null,
              sceneLabel: getSceneDisplayLabel(scene),
              text,
              index,
              scriptOrder: Number.isFinite(scene.scriptOrder) ? Number(scene.scriptOrder) : index,
              matchedByName
            });
          });
        });
        results.sort((a, b) => {
          const orderDiff = a.scriptOrder - b.scriptOrder;
          if (orderDiff !== 0) return orderDiff;
          return a.index - b.index;
        });
        return results;
      }

      function isMobileViewport(){
        return mobileViewportQuery.matches;
      }

      function getCharacterWindowElement(){
        return document.querySelector('[data-character-window]');
      }

      function openMobileEditor(){
        const windowEl = getCharacterWindowElement();
        if (!windowEl) return;
        windowEl.setAttribute('data-mobile-editor-open', 'true');
        window.requestAnimationFrame(() => {
          const top = windowEl.getBoundingClientRect().top + window.scrollY;
          window.scrollTo({ top, behavior: 'smooth' });
          const container = document.querySelector('[data-character-details]');
          if (container){
            container.scrollTop = 0;
          }
        });
      }

      function closeMobileEditor(){
        const windowEl = getCharacterWindowElement();
        if (!windowEl) return;
        windowEl.removeAttribute('data-mobile-editor-open');
        scrollMobileGalleryToActive({ smooth: true });
      }

      function ensureMobileCloseButton(container){
        if (!container) return;
        let closeButton = container.querySelector('[data-character-mobile-close]');
        if (!closeButton){
          closeButton = document.createElement('button');
          closeButton.type = 'button';
          closeButton.className = 'character-studio-mobile-close';
          closeButton.setAttribute('data-character-mobile-close', '');
          closeButton.innerHTML = '<span aria-hidden="true">‚Üê</span><span>Back to cards</span>';
          container.prepend(closeButton);
        }
        if (!closeButton.dataset.bound){
          closeButton.addEventListener('click', closeMobileEditor);
          closeButton.dataset.bound = 'true';
        }
      }

      function buildMobileCardMarkup(character){
        if (!character) return '';
        const portraitUrl = typeof character?.looks?.portrait === 'string' ? character.looks.portrait.trim() : '';
        const name = character?.name ? character.name : 'Untitled Character';
        const meta = characterSidebarMeta(character) || 'Add role or pronouns';
        const summary = typeof character?.summary === 'string' ? character.summary.trim() : '';
        const statsScenes = Number.isFinite(character?.stats?.scenes) ? character.stats.scenes : 0;
        const statsDialogue = Number.isFinite(character?.stats?.dialogue) ? character.stats.dialogue : 0;
        const statsScreenTime = Number.isFinite(character?.stats?.screenTime) ? character.stats.screenTime : 0;
        const traits = Array.isArray(character?.traits) ? character.traits.filter(Boolean).slice(0, 4) : [];
        const traitMarkup = traits.length
          ? traits.map(trait => `<span>${escapeHtml(trait)}</span>`).join('')
          : '<span class="muted-text">Add traits to spotlight personality.</span>';
        const initial = name.trim().charAt(0).toUpperCase() || 'C';
        const portraitMarkup = portraitUrl
          ? `<img src="${escapeHtml(portraitUrl)}" alt="${escapeHtml(`${name} portrait`)}" loading="lazy" />`
          : `<div class="character-studio-mobile-card-placeholder" aria-hidden="true">${escapeHtml(initial)}</div>`;
        return `
          <article class="character-studio-mobile-card${character.id === state.activeId ? ' is-active' : ''}" data-character-id="${escapeHtml(character.id)}" tabindex="0">
            <div class="character-studio-mobile-card-media">
              ${portraitMarkup}
            </div>
            <div class="character-studio-mobile-card-body">
              <div>
                <h3>${escapeHtml(name)}</h3>
                <p class="character-studio-mobile-card-meta">${escapeHtml(meta)}</p>
              </div>
              ${summary ? `<p class="character-studio-mobile-card-summary">${escapeHtml(summary)}</p>` : ''}
              <div class="character-studio-mobile-card-stats">
                <div>
                  <dt>Scenes</dt>
                  <dd>${escapeHtml(String(statsScenes))}</dd>
                </div>
                <div>
                  <dt>Dialogue</dt>
                  <dd>${escapeHtml(String(statsDialogue))}</dd>
                </div>
                <div>
                  <dt>Minutes</dt>
                  <dd>${escapeHtml(String(statsScreenTime))}</dd>
                </div>
              </div>
              <div class="character-studio-mobile-card-traits">${traitMarkup}</div>
              <button class="character-studio-mobile-open" type="button" data-character-mobile-open="${escapeHtml(character.id)}">Open editor</button>
            </div>
          </article>`;
      }

      function updateMobileActiveCard(){
        const track = document.querySelector('[data-character-mobile-track]');
        if (!track) return;
        const cards = track.querySelectorAll('[data-character-id]');
        cards.forEach(card => {
          const id = card.getAttribute('data-character-id');
          card.classList.toggle('is-active', id === state.activeId);
        });
        document.querySelectorAll('[data-character-mobile-dot]').forEach(dot => {
          const id = dot.getAttribute('data-character-mobile-dot');
          if (id === state.activeId){
            dot.setAttribute('aria-current', 'true');
          } else {
            dot.removeAttribute('aria-current');
          }
        });
        syncMobileArrowState();
      }

      function scrollMobileGalleryToActive(options = {}){
        if (!isMobileViewport() || mobileGallerySyncingFromScroll) return;
        const track = document.querySelector('[data-character-mobile-track]');
        if (!track) return;
        const activeId = state.activeId;
        if (!activeId) return;
        const cards = Array.from(track.querySelectorAll('[data-character-id]'));
        const activeCard = cards.find(card => card.getAttribute('data-character-id') === activeId);
        if (!activeCard) return;
        const behavior = options.smooth === false ? 'auto' : 'smooth';
        activeCard.scrollIntoView({ behavior, inline: 'center', block: 'nearest' });
      }

      function syncMobileArrowState(){
        const prevButton = document.querySelector('[data-character-mobile-prev]');
        const nextButton = document.querySelector('[data-character-mobile-next]');
        const total = state.characters.length;
        const index = state.characters.findIndex(char => char.id === state.activeId);
        const hideArrows = !isMobileViewport() || total <= 1;

        [prevButton, nextButton].forEach(btn => {
          if (!btn) return;
          btn.hidden = hideArrows;
          btn.disabled = hideArrows;
        });

        if (hideArrows) return;

        if (prevButton){
          prevButton.disabled = index <= 0;
        }
        if (nextButton){
          nextButton.disabled = index === -1 || index >= total - 1;
        }
      }

      function focusMobileCharacterByOffset(offset){
        if (!Number.isInteger(offset) || !isMobileViewport()) return;
        const total = state.characters.length;
        if (!total) return;
        const currentIndex = state.characters.findIndex(char => char.id === state.activeId);
        if (currentIndex === -1) return;
        const targetIndex = currentIndex + offset;
        if (targetIndex < 0 || targetIndex >= total){
          scrollMobileGalleryToActive({ smooth: true });
          return;
        }
        const target = state.characters[targetIndex];
        if (!target || target.id === state.activeId) {
          scrollMobileGalleryToActive({ smooth: true });
          return;
        }
        state.activeId = target.id;
        renderCharacterList();
        renderCharacterDetails();
      }

      function renderCharacterMobileGallery(){
        const wrapper = document.querySelector('[data-character-mobile]');
        if (!wrapper) return;
        const track = wrapper.querySelector('[data-character-mobile-track]');
        const pagination = wrapper.querySelector('[data-character-mobile-pagination]');
        if (!track || !pagination) return;
        const prevButton = wrapper.querySelector('[data-character-mobile-prev]');
        const nextButton = wrapper.querySelector('[data-character-mobile-next]');

        if (!isMobileViewport() || !state.projectId || !state.characters.length){
          wrapper.hidden = true;
          if (!mobileGallerySyncingFromScroll){
            track.innerHTML = '';
            pagination.innerHTML = '';
          }
          if (prevButton){
            prevButton.hidden = true;
            prevButton.disabled = true;
          }
          if (nextButton){
            nextButton.hidden = true;
            nextButton.disabled = true;
          }
          return;
        }

        wrapper.hidden = false;

        if (prevButton && !prevButton.dataset.bound){
          prevButton.addEventListener('click', () => focusMobileCharacterByOffset(-1));
          prevButton.dataset.bound = 'true';
        }
        if (nextButton && !nextButton.dataset.bound){
          nextButton.addEventListener('click', () => focusMobileCharacterByOffset(1));
          nextButton.dataset.bound = 'true';
        }

        if (!mobileGallerySyncingFromScroll){
          track.innerHTML = state.characters.map(buildMobileCardMarkup).join('');
          pagination.innerHTML = state.characters.length > 1
            ? state.characters.map(char => `<button type="button" class="character-studio-mobile-dot" data-character-mobile-dot="${escapeHtml(char.id)}" aria-label="View ${escapeHtml(char.name || 'Character')}"${char.id === state.activeId ? ' aria-current="true"' : ''}></button>`).join('')
            : '';

          track.querySelectorAll('[data-character-mobile-open]').forEach(button => {
            button.addEventListener('click', event => {
              event.stopPropagation();
              const id = button.getAttribute('data-character-mobile-open');
              if (!id) return;
              if (state.activeId !== id){
                state.activeId = id;
                renderCharacterList();
                renderCharacterDetails();
              } else {
                updateMobileActiveCard();
              }
              openMobileEditor();
            });
          });

          track.querySelectorAll('[data-character-id]').forEach(card => {
            card.addEventListener('click', () => {
              const id = card.getAttribute('data-character-id');
              if (!id || id === state.activeId) return;
              state.activeId = id;
              renderCharacterList();
              renderCharacterDetails();
            });
          });

          if (!track.dataset.scrollHandlerAttached){
            track.addEventListener('scroll', handleMobileGalleryScroll, { passive: true });
            track.dataset.scrollHandlerAttached = 'true';
          }

          pagination.querySelectorAll('[data-character-mobile-dot]').forEach(dot => {
            dot.addEventListener('click', () => {
              const id = dot.getAttribute('data-character-mobile-dot');
              if (!id) return;
              if (state.activeId !== id){
                state.activeId = id;
                renderCharacterList();
                renderCharacterDetails();
              } else {
                scrollMobileGalleryToActive({ smooth: true });
              }
            });
          });
        }

        updateMobileActiveCard();
        scrollMobileGalleryToActive({ smooth: false });
        syncMobileArrowState();
      }

      function handleMobileGalleryScroll(){
        if (!isMobileViewport()) return;
        if (mobileGalleryScrollTimer) window.clearTimeout(mobileGalleryScrollTimer);
        mobileGalleryScrollTimer = window.setTimeout(() => {
          mobileGalleryScrollTimer = null;
          const track = document.querySelector('[data-character-mobile-track]');
          if (!track) return;
          const cards = Array.from(track.querySelectorAll('[data-character-id]'));
          if (!cards.length) return;
          const trackRect = track.getBoundingClientRect();
          const center = trackRect.left + trackRect.width / 2;
          let closestId = null;
          let minDistance = Infinity;
          cards.forEach(card => {
            const rect = card.getBoundingClientRect();
            const cardCenter = rect.left + rect.width / 2;
            const distance = Math.abs(cardCenter - center);
            if (distance < minDistance){
              minDistance = distance;
              closestId = card.getAttribute('data-character-id');
            }
          });
          if (closestId && closestId !== state.activeId){
            mobileGallerySyncingFromScroll = true;
            state.activeId = closestId;
            renderCharacterList();
            renderCharacterDetails();
            mobileGallerySyncingFromScroll = false;
          } else {
            updateMobileActiveCard();
          }
        }, 120);
      }

      function handleMobileViewportChange(event){
        if (!event.matches){
          closeMobileEditor();
        }
        renderCharacterMobileGallery();
      }

      function characterLookPreviewMarkup(kind, url, character){
        const label = CHARACTER_LOOK_LABELS[kind] || 'Reference';
        const name = character?.name ? character.name : 'Character';
        if (url){
          return `<img src="${escapeHtml(url)}" alt="${escapeHtml(`${name} ${label.toLowerCase()}`)}" />`;
        }
        return `<div class="character-studio-look-empty">Add a ${escapeHtml(label.toLowerCase())} URL to preview.</div>`;
      }

      async function fetchPoseLibraryForCharacter(characterId, { force = false } = {}){
        if (!characterId) return [];
        if (!state.supabase){
          console.warn('Supabase client not ready for pose fetch');
          return [];
        }
        if (!force && state.poseCache.has(characterId)){
          return state.poseCache.get(characterId) || [];
        }
        const { data, error } = await state.supabase
          .from('character_poses')
          .select('id, pose_label, pose_description, scene_use_case, generated_image_url, score, approved_for_scene, updated_at')
          .eq('character_id', characterId)
          .order('approved_for_scene', { ascending: false })
          .order('score', { ascending: false })
          .order('updated_at', { ascending: false });
        if (error){
          throw error;
        }
        const list = Array.isArray(data) ? data : [];
        const poses = [];
        for (const entry of list){
          const scoreValue = Number.isFinite(entry.score) ? Number(entry.score) : Number(entry.score || 0);
          const signedUrl = await getSignedUrlForPath(entry.generated_image_url);
          poses.push({
            id: entry.id,
            pose_label: entry.pose_label || 'Untitled pose',
            pose_description: entry.pose_description || '',
            scene_use_case: entry.scene_use_case || '',
            generated_image_url: entry.generated_image_url || '',
            score: Number.isFinite(scoreValue) ? scoreValue : 0,
            approved_for_scene: Boolean(entry.approved_for_scene),
            signedUrl: signedUrl || null,
          });
        }
        state.poseCache.set(characterId, poses);
        return poses;
      }

      async function refreshBasePreview(container, character){
        if (!container) return;
        const preview = container.querySelector('[data-character-base-preview]');
        if (!preview) return;
        const empty = preview.querySelector('[data-character-base-empty]');
        const img = preview.querySelector('[data-character-base-image]');
        if (!img || !empty) return;
        const path = character?.baseImageUrl || '';
        if (!path){
          img.hidden = true;
          img.removeAttribute('src');
          empty.hidden = false;
          return;
        }
        const signedUrl = await getSignedUrlForPath(path);
        if (signedUrl){
          img.src = signedUrl;
          img.hidden = false;
          empty.hidden = true;
        } else {
          img.hidden = true;
          img.removeAttribute('src');
          empty.hidden = false;
        }
      }

      function renderPoseLibrary(container, character, poses){
        if (!container) return;
        const list = container.querySelector('[data-character-pose-list]');
        if (!list) return;
        list.innerHTML = '';
        const safeName = character?.name || 'Character';
        if (!poses || !poses.length){
          const placeholder = document.createElement('div');
          placeholder.className = 'character-studio-pose-placeholder';
          placeholder.textContent = 'No poses generated yet. Generate a pose to populate this library.';
          list.appendChild(placeholder);
          return;
        }
        poses.forEach(pose => {
          const item = document.createElement('div');
          item.className = 'character-studio-pose-list-item';
          if (pose.signedUrl){
            const img = document.createElement('img');
            img.src = pose.signedUrl;
            img.alt = `${safeName} pose ${pose.pose_label}`;
            img.loading = 'lazy';
            item.appendChild(img);
          }
          const title = document.createElement('strong');
          title.textContent = pose.pose_label || 'Untitled pose';
          item.appendChild(title);
          if (pose.pose_description){
            const description = document.createElement('p');
            description.className = 'character-studio-small-note';
            description.textContent = pose.pose_description;
            item.appendChild(description);
          }
          const meta = document.createElement('div');
          meta.className = 'character-studio-pose-meta';
          const score = document.createElement('span');
          score.textContent = `Score ${(Number(pose.score) || 0).toFixed(2)}`;
          meta.appendChild(score);
          if (pose.approved_for_scene){
            const flag = document.createElement('span');
            flag.className = 'character-studio-pose-flag';
            flag.textContent = 'Storyboard ready';
            meta.appendChild(flag);
          }
          list.appendChild(item);
          item.appendChild(meta);
        });
      }

      function parseIntegerInput(value){
        const num = parseInt(value, 10);
        return Number.isFinite(num) && num >= 0 ? num : 0;
      }

      function parseFloatInput(value){
        const num = parseFloat(value);
        return Number.isFinite(num) && num >= 0 ? Number(num.toFixed(2)) : 0;
      }

      function updateCharacterField(id, path, value){
        const character = state.characters.find(c => c.id === id);
        if (!character) return;
        const parts = path.split('.');
        let target = character;
        for (let i = 0; i < parts.length - 1; i++){
          const key = parts[i];
          if (typeof target[key] !== 'object' || target[key] === null) target[key] = {};
          target = target[key];
        }
        const finalKey = parts[parts.length - 1];
        const previous = target[finalKey];
        target[finalKey] = value;
        let changed = previous !== value;
        if (Array.isArray(previous) && Array.isArray(value)){
          changed = previous.length !== value.length || previous.some((entry, index) => entry !== value[index]);
        }
        if (changed) markDirty();
      }

      function renderCharacterList(){
        const listEl = document.querySelector('[data-character-list]');
        if (!listEl) return;
        listEl.innerHTML = '';
        const showMessage = (title, detail) => {
          const empty = document.createElement('div');
          empty.className = 'character-studio-empty-list';
          empty.innerHTML = `<strong>${escapeHtml(title)}</strong><span>${escapeHtml(detail)}</span>`;
          listEl.appendChild(empty);
        };
        if (!state.projectId){
          state.activeId = null;
          showMessage('No story linked', 'Open your story in the Writer to connect Character Studio.');
          renderCharacterMobileGallery();
          return;
        }
        if (!state.characters.length){
          state.activeId = null;
          if (state.loading){
            showMessage('Loading characters‚Ä¶', 'Syncing the cast from Supabase.');
          } else if (!state.supabase){
            showMessage('Connecting to Supabase‚Ä¶', 'One moment while we prepare your workspace.');
          } else if (!state.session){
            showMessage('Sign in to continue', 'Sign in to load and save your cast.');
          } else {
            showMessage('No characters yet', 'Add the first member of your cast to begin planning.');
          }
          renderCharacterMobileGallery();
          return;
        }
        state.characters.forEach(char => {
          const item = document.createElement('button');
          item.type = 'button';
          item.className = 'character-studio-list-item' + (char.id === state.activeId ? ' active' : '');
          item.innerHTML = `<strong>${escapeHtml(char.name || 'Untitled Character')}</strong><span>${escapeHtml(characterSidebarMeta(char))}</span>`;
          item.setAttribute('data-character-id', char.id);
          item.addEventListener('click', () => {
            if (state.activeId === char.id) return;
            state.activeId = char.id;
            renderCharacterList();
            renderCharacterDetails();
          });
          listEl.appendChild(item);
        });
        renderCharacterMobileGallery();
      }

      function renderCharacterDetails(){
        const container = document.querySelector('[data-character-details]');
        if (!container) return;
        if (!state.dialogDraftsLoaded) hydrateDialogDrafts();
        if (state.dialogStatusCharacterId !== state.activeId){
          state.dialogStatus = '';
          state.dialogStatusState = '';
          state.dialogStatusCharacterId = state.activeId || null;
        }
        if (!state.projectId){
          container.innerHTML = `
            <div class="character-studio-empty">
              <h2>No story linked</h2>
              <p>Open your story in the Writer to connect Character Studio.</p>
            </div>`;
          ensureMobileCloseButton(container);
          return;
        }
        if (!state.characters.length){
          if (state.loading){
            container.innerHTML = `
              <div class="character-studio-empty">
                <h2>Loading characters‚Ä¶</h2>
                <p>Syncing the cast from Supabase.</p>
              </div>`;
            ensureMobileCloseButton(container);
          } else if (!state.supabase){
            container.innerHTML = `
              <div class="character-studio-empty">
                <h2>Connecting to Supabase‚Ä¶</h2>
                <p>One moment while we prepare your workspace.</p>
              </div>`;
            ensureMobileCloseButton(container);
          } else if (!state.session){
            container.innerHTML = `
              <div class="character-studio-empty">
                <h2>Sign in to continue</h2>
                <p>Sign in to view and save this cast.</p>
              </div>`;
            ensureMobileCloseButton(container);
          } else {
            container.innerHTML = `
              <div class="character-studio-empty">
                <h2>No characters yet</h2>
                <p>Use the + New button to start building your cast.</p>
              </div>`;
            ensureMobileCloseButton(container);
          }
          return;
        }
        const active = getActiveCharacter();
        if (!active){
          container.innerHTML = `
            <div class="character-studio-empty">
              <h2>No character selected</h2>
              <p>Choose a character from the list to begin planning.</p>
            </div>`;
          ensureMobileCloseButton(container);
          return;
        }

        const statsScenes = Number.isFinite(active.stats?.scenes) ? active.stats.scenes : 0;
        const statsDialogue = Number.isFinite(active.stats?.dialogue) ? active.stats.dialogue : 0;
        const statsScreenTime = Number.isFinite(active.stats?.screenTime) ? active.stats.screenTime : 0;
        const traitsText = Array.isArray(active.traits) ? active.traits.join('\n') : '';
        const portraitUrl = active.looks?.portrait || '';
        const turnaroundsText = Array.isArray(active.looks?.turnarounds) ? active.looks.turnarounds.join('\n') : '';
        const expressionsText = Array.isArray(active.looks?.expressions) ? active.looks.expressions.join('\n') : '';
        const turnaroundPreview = Array.isArray(active.looks?.turnarounds) ? active.looks.turnarounds[0] || '' : '';
        const expressionPreview = Array.isArray(active.looks?.expressions) ? active.looks.expressions[0] || '' : '';
        const subheading = buildCharacterSubheading(active);
        const traitsPreview = buildTraitsPreviewMarkup(active);
        const aiPrompt = active.ai?.prompt || '';
        const aiNotes = active.ai?.notes || '';
        const scriptDialogues = gatherCharacterDialogues(active);
        const dialogDrafts = getDialogDraftsForCharacter(active.id);
        const canRefreshDialog = Boolean(state.supabase && state.session && state.ownerId && state.projectId);
        const refreshLabel = state.scenesLoading ? 'Refreshing‚Ä¶' : 'Refresh script lines';
        const refreshDisabledAttr = state.scenesLoading ? ' disabled' : '';
        const dialogRefreshButton = canRefreshDialog
          ? `<button type="button" class="character-studio-tertiary" data-character-dialog-refresh${refreshDisabledAttr}>${escapeHtml(refreshLabel)}</button>`
          : '';
        let scriptDialogSection = '';
        if (!state.projectId){
          scriptDialogSection = '<p class="muted-text">Link a story to sync script dialog.</p>';
        } else if (!state.session || !state.ownerId){
          scriptDialogSection = '<p class="muted-text">Sign in to sync script dialog.</p>';
        } else if (!state.supabase){
          scriptDialogSection = '<p class="muted-text">Connecting to Supabase‚Ä¶</p>';
        } else if (state.scenesLoading){
          scriptDialogSection = '<p class="muted-text">Loading script dialog‚Ä¶</p>';
        } else if (state.scenesError){
          scriptDialogSection = `<p class="muted-text">${escapeHtml(state.scenesError)}</p>`;
        } else if (!state.scenesLoaded){
          scriptDialogSection = '<p class="muted-text">Script dialog not synced yet. Use Refresh script lines.</p>';
        } else if (!state.scenes.length){
          scriptDialogSection = '<p class="muted-text">No scenes saved yet for this story.</p>';
        } else if (!scriptDialogues.length){
          const name = active.name ? escapeHtml(active.name) : 'this character';
          scriptDialogSection = `<p class="muted-text">No dialogue tagged for ${name} yet.</p>`;
        } else {
          const entries = scriptDialogues.map(entry => {
            const note = entry.matchedByName ? '<span class="character-studio-dialog-meta">Matched by name</span>' : '';
            return `<article class="character-studio-dialog-entry"><header><strong>${escapeHtml(entry.sceneLabel)}</strong>${note}</header><p>${formatDialogText(entry.text)}</p></article>`;
          }).join('');
          scriptDialogSection = `<div class="character-studio-dialog-list">${entries}</div>`;
        }
        const disableSceneSelection = !canRefreshDialog || state.scenesLoading || !state.scenes.length;
        const selectDisabledAttr = disableSceneSelection ? ' disabled' : '';
        const assignDisabledAttr = disableSceneSelection ? ' disabled' : '';
        const dialogDraftsMarkup = dialogDrafts.length
          ? dialogDrafts.map(draft => `
              <article class="character-studio-dialog-draft" data-dialog-draft="${escapeHtml(draft.id)}">
                <p>${formatDialogText(draft.text)}</p>
                <div class="character-studio-dialog-draft-actions">
                  <label class="character-studio-field">
                    <span>Assign to scene</span>
                    <select data-dialog-draft-scene${selectDisabledAttr}>
                      ${buildSceneOptionsMarkup()}
                    </select>
                  </label>
                  <div class="character-studio-dialog-draft-buttons">
                    <button type="button" data-dialog-draft-assign="${escapeHtml(draft.id)}"${assignDisabledAttr}>Insert into scene</button>
                    <button type="button" data-dialog-draft-delete="${escapeHtml(draft.id)}">Remove</button>
                  </div>
                </div>
              </article>
            `).join('')
          : '<p class="muted-text">No unassigned lines yet. Draft a new line below.</p>';

        if (!CHARACTER_TAB_CONFIG.some(tab => tab.id === state.activeTabId)){
          state.activeTabId = CHARACTER_TAB_CONFIG[0].id;
        }

        const tabButtonsMarkup = CHARACTER_TAB_CONFIG.map(tab => {
          const isActive = tab.id === state.activeTabId;
          return `<button type="button" class="character-studio-tab-button" role="tab" id="character-tab-${tab.id}" data-tab-id="${tab.id}" aria-controls="character-panel-${tab.id}" aria-selected="${isActive ? 'true' : 'false'}" tabindex="${isActive ? '0' : '-1'}">${escapeHtml(tab.label)}</button>`;
        }).join('');

        const panelAttributes = id => {
          const isActive = state.activeTabId === id;
          return `${isActive ? '' : ' hidden'} aria-hidden="${isActive ? 'false' : 'true'}"`;
        };

        container.innerHTML = `
          <div class="character-studio-detail-header">
            <div>
              <h2 data-character-heading>${escapeHtml(active.name || 'Untitled Character')}</h2>
              <p class="muted-text" data-character-subheading>${escapeHtml(subheading || 'Add role, pronouns, or age details.')}</p>
            </div>
            <div class="character-studio-header-actions">
              <button class="character-studio-tertiary" type="button" data-character-finish-story>FinishThatStory</button>
              <button class="character-studio-tertiary" type="button" data-character-delete>Delete Character</button>
            </div>
          </div>
          <div class="character-studio-tabs">
            <div class="character-studio-tablist" role="tablist" aria-label="Character sections" data-character-tablist>
              ${tabButtonsMarkup}
            </div>
            <div class="character-studio-tabpanels">
              <section class="character-studio-section" role="tabpanel" tabindex="0" id="character-panel-profile" aria-labelledby="character-tab-profile" data-tab-panel="profile"${panelAttributes('profile')}>
                <h3>Profile</h3>
                <p class="muted-text">Keep the essentials handy when writing.</p>
                <div class="character-studio-profile-layout">
                  <div class="character-studio-profile-portrait" data-profile-portrait>
                    ${characterLookPreviewMarkup('portrait', portraitUrl, active)}
                  </div>
                  <div class="character-studio-profile-fields">
                    <div class="character-studio-two-col">
                      <label class="character-studio-field">
                        <span>Name</span>
                        <input type="text" value="${escapeHtml(active.name || '')}" data-character-field="name" placeholder="Character name" />
                      </label>
                      <label class="character-studio-field">
                        <span>Role</span>
                        <input type="text" value="${escapeHtml(active.role || '')}" data-character-field="role" placeholder="Protagonist, Antagonist..." />
                      </label>
                      <label class="character-studio-field">
                        <span>Archetype</span>
                        <input type="text" value="${escapeHtml(active.archetype || '')}" data-character-field="archetype" placeholder="e.g. Reluctant hero" />
                      </label>
                      <label class="character-studio-field">
                        <span>Pronouns</span>
                        <input type="text" value="${escapeHtml(active.pronouns || '')}" data-character-field="pronouns" placeholder="They/Them" />
                      </label>
                      <label class="character-studio-field">
                        <span>Age</span>
                        <input type="text" value="${escapeHtml(active.age || '')}" data-character-field="age" placeholder="32" />
                      </label>
                    </div>
                    <label class="character-studio-field">
                      <span>Summary</span>
                      <textarea class="small" data-character-field="summary" placeholder="Logline summary">${escapeHtml(active.summary || '')}</textarea>
                    </label>
                  </div>
                </div>
              </section>
              <section class="character-studio-section" role="tabpanel" tabindex="0" id="character-panel-stats" aria-labelledby="character-tab-stats" data-tab-panel="stats"${panelAttributes('stats')}>
                <h3>Stats &amp; Spotlight</h3>
                <p class="muted-text">Track how often this character appears in the script.</p>
                <div class="character-studio-stats-grid">
                  <div class="character-studio-stat">
                    <span class="character-studio-stat-value" data-character-stat="scenes">${escapeHtml(String(statsScenes))}</span>
                    <span class="character-studio-stat-label">Scenes</span>
                  </div>
                  <div class="character-studio-stat">
                    <span class="character-studio-stat-value" data-character-stat="dialogue">${escapeHtml(String(statsDialogue))}</span>
                    <span class="character-studio-stat-label">Dialogue Lines</span>
                  </div>
                  <div class="character-studio-stat">
                    <span class="character-studio-stat-value" data-character-stat="screenTime">${escapeHtml(String(statsScreenTime))}</span>
                    <span class="character-studio-stat-label">Estimated Minutes</span>
                  </div>
                </div>
                <div class="character-studio-two-col">
                  <label class="character-studio-field">
                    <span>Total scenes</span>
                    <input type="number" min="0" value="${escapeHtml(String(statsScenes))}" data-character-field="stats.scenes" />
                  </label>
                  <label class="character-studio-field">
                    <span>Dialogue lines</span>
                    <input type="number" min="0" value="${escapeHtml(String(statsDialogue))}" data-character-field="stats.dialogue"/>
                  </label>
                  <label class="character-studio-field">
                    <span>Screen time (minutes)</span>
                    <input type="number" min="0" step="0.1" value="${escapeHtml(String(statsScreenTime))}" data-character-field="stats.screenTime" />
                  </label>
                </div>
              </section>
              <section class="character-studio-section" role="tabpanel" tabindex="0" id="character-panel-dialog" aria-labelledby="character-tab-dialog" data-tab-panel="dialog"${panelAttributes('dialog')}>
                <h3>Dialog</h3>
                <p class="muted-text">Review lines assigned to this character and prep new dialog.</p>
                <div class="character-studio-dialog-grid">
                  <div class="character-studio-dialog-column">
                    <div class="character-studio-dialog-header">
                      <h4>Script highlights</h4>
                      ${dialogRefreshButton}
                    </div>
                    ${scriptDialogSection}
                  </div>
                  <div class="character-studio-dialog-column">
                    <div class="character-studio-dialog-header">
                      <h4>Scratchpad</h4>
                    </div>
                    <form class="character-studio-dialog-form" data-character-dialog-form>
                      <label class="character-studio-field">
                        <span>Draft new line</span>
                        <textarea data-character-dialog-input placeholder="Capture a new line or beat for this character."></textarea>
                      </label>
                      <button type="submit" class="character-studio-tertiary">Save to scratchpad</button>
                    </form>
                    <span class="character-studio-status" data-character-dialog-status></span>
                    <div class="character-studio-dialog-drafts" data-character-dialog-drafts>
                      ${dialogDraftsMarkup}
                    </div>
                  </div>
                </div>
              </section>
              <section class="character-studio-section" role="tabpanel" tabindex="0" id="character-panel-traits" aria-labelledby="character-tab-traits" data-tab-panel="traits"${panelAttributes('traits')}>
                <h3>Traits &amp; Personality</h3>
                <p class="muted-text">List defining qualities, habits, and secrets.</p>
                <div class="character-studio-traits-preview" data-traits-preview>${traitsPreview}</div>
                <label class="character-studio-field">
                  <span>Traits (one per line)</span>
                  <textarea data-character-field="traits" placeholder="Resilient&#10;Impulsive&#10;Secret romantic">${escapeHtml(traitsText)}</textarea>
                </label>
              </section>
              <section class="character-studio-section" role="tabpanel" tabindex="0" id="character-panel-background" aria-labelledby="character-tab-background" data-tab-panel="background"${panelAttributes('background')}>
                <h3>Background &amp; Family</h3>
                <div class="character-studio-two-col">
                  <label class="character-studio-field">
                    <span>Background story</span>
                    <textarea data-character-field="background" placeholder="Origin story, formative experiences">${escapeHtml(active.background || '')}</textarea>
                  </label>
                  <label class="character-studio-field">
                    <span>Family tree / relationships</span>
                    <textarea data-character-field="familyTree" placeholder="Parents, siblings, key relationships">${escapeHtml(active.familyTree || '')}</textarea>
                  </label>
                </div>
              </section>
              <section class="character-studio-section" role="tabpanel" tabindex="0" id="character-panel-arc" aria-labelledby="character-tab-arc" data-tab-panel="arc"${panelAttributes('arc')}>
                <h3>Character Arc</h3>
                <p class="muted-text">Map how the character transforms across the story.</p>
                <div class="character-studio-two-col">
                  <label class="character-studio-field">
                    <span>Setup</span>
                    <textarea data-character-field="arc.setup" placeholder="Who are they at the beginning?">${escapeHtml(active.arc?.setup || '')}</textarea>
                  </label>
                  <label class="character-studio-field">
                    <span>Development</span>
                    <textarea data-character-field="arc.development" placeholder="Challenges, midpoint, reversals">${escapeHtml(active.arc?.development || '')}</textarea>
                  </label>
                  <label class="character-studio-field">
                    <span>Resolution</span>
                    <textarea data-character-field="arc.resolution" placeholder="Where do they end up?">${escapeHtml(active.arc?.resolution || '')}</textarea>
                  </label>
                </div>
              </section>
              <section class="character-studio-section" role="tabpanel" tabindex="0" id="character-panel-lookbook" aria-labelledby="character-tab-lookbook" data-tab-panel="lookbook"${panelAttributes('lookbook')}>
                <h3>Lookbook</h3>
                <p class="muted-text">Collect portrait, turnaround, and expression references.</p>
                <div class="character-studio-two-col">
                  <label class="character-studio-field">
                    <span>Portrait URL</span>
                    <input type="url" data-character-field="looks.portrait" value="${escapeHtml(portraitUrl)}" placeholder="https://..." />
                  </label>
                  <label class="character-studio-field">
                    <span>Turnarounds (one per line)</span>
                    <textarea data-character-field="looks.turnarounds" class="small" placeholder="Link to turnaround sheets">${escapeHtml(turnaroundsText)}</textarea>
                  </label>
                  <label class="character-studio-field">
                    <span>Expression sheets (one per line)</span>
                    <textarea data-character-field="looks.expressions" class="small" placeholder="Link to expressions">${escapeHtml(expressionsText)}</textarea>
                  </label>
                </div>
                <div class="character-studio-look-grid">
                  <div class="character-studio-look-card" data-look-preview="portrait">
                    <span class="character-studio-look-label">Portrait</span>
                    <div data-look-content>
                      ${characterLookPreviewMarkup('portrait', portraitUrl, active)}
                    </div>
                  </div>
                  <div class="character-studio-look-card" data-look-preview="turnaround">
                    <span class="character-studio-look-label">Turnaround</span>
                    <div data-look-content>
                      ${characterLookPreviewMarkup('turnaround', turnaroundPreview, active)}
                    </div>
                  </div>
                  <div class="character-studio-look-card" data-look-preview="expression">
                    <span class="character-studio-look-label">Expressions</span>
                    <div data-look-content>
                      ${characterLookPreviewMarkup('expression', expressionPreview, active)}
                    </div>
                  </div>
                </div>
              </section>
              <section class="character-studio-section character-studio-refine" data-character-refine>
                <h3>Visual Refinement</h3>
                <p class="muted-text">Fine-tune your character's appearance with adjustable parameters and preview before/after changes.</p>
                <div class="character-studio-refine-grid">
                  <div class="character-studio-refine-controls">
                    <label class="character-studio-field">
                      <span>Age</span>
                      <select data-refine-control="age">
                        <option value="default">Default</option>
                        <option value="child">Child</option>
                        <option value="teen">Teen</option>
                        <option value="young-adult">Young Adult</option>
                        <option value="middle-aged">Middle Aged</option>
                        <option value="elderly">Elderly</option>
                      </select>
                    </label>
                    <label class="character-studio-field">
                      <span>Mood / Expression</span>
                      <div class="character-studio-refine-pill-group">
                        <button type="button" class="character-studio-refine-pill selected" data-refine-pill="mood" data-value="neutral">Neutral</button>
                        <button type="button" class="character-studio-refine-pill" data-refine-pill="mood" data-value="happy">Happy</button>
                        <button type="button" class="character-studio-refine-pill" data-refine-pill="mood" data-value="sad">Sad</button>
                        <button type="button" class="character-studio-refine-pill" data-refine-pill="mood" data-value="angry">Angry</button>
                        <button type="button" class="character-studio-refine-pill" data-refine-pill="mood" data-value="surprised">Surprised</button>
                      </div>
                    </label>
                    <label class="character-studio-field">
                      <span>Hair Length</span>
                      <div class="character-studio-refine-pill-group">
                        <button type="button" class="character-studio-refine-pill" data-refine-pill="hairLength" data-value="short">Short</button>
                        <button type="button" class="character-studio-refine-pill selected" data-refine-pill="hairLength" data-value="medium">Medium</button>
                        <button type="button" class="character-studio-refine-pill" data-refine-pill="hairLength" data-value="long">Long</button>
                      </div>
                    </label>
                    <label class="character-studio-field">
                      <span>Eyebrow Shape</span>
                      <div class="character-studio-refine-pill-group">
                        <button type="button" class="character-studio-refine-pill selected" data-refine-pill="eyebrowShape" data-value="soft">Soft</button>
                        <button type="button" class="character-studio-refine-pill" data-refine-pill="eyebrowShape" data-value="sharp">Sharp</button>
                        <button type="button" class="character-studio-refine-pill" data-refine-pill="eyebrowShape" data-value="thick">Thick</button>
                        <button type="button" class="character-studio-refine-pill" data-refine-pill="eyebrowShape" data-value="thin">Thin</button>
                      </div>
                    </label>
                    <label class="character-studio-field">
                      <span>Style</span>
                      <div class="character-studio-refine-pill-group">
                        <button type="button" class="character-studio-refine-pill" data-refine-pill="style" data-value="anime">Anime</button>
                        <button type="button" class="character-studio-refine-pill selected" data-refine-pill="style" data-value="realistic">Realistic</button>
                        <button type="button" class="character-studio-refine-pill" data-refine-pill="style" data-value="painterly">Painterly</button>
                      </div>
                    </label>
                    <label class="character-studio-field">
                      <span>Detail Level</span>
                      <div class="character-studio-refine-pill-group">
                        <button type="button" class="character-studio-refine-pill" data-refine-pill="detail" data-value="cheap">Cheap</button>
                        <button type="button" class="character-studio-refine-pill selected" data-refine-pill="detail" data-value="standard">Standard</button>
                        <button type="button" class="character-studio-refine-pill" data-refine-pill="detail" data-value="pro">Pro</button>
                      </div>
                    </label>
                  </div>
                  <div class="character-studio-refine-preview-box">
                    <div class="character-studio-refine-previews">
                      <div class="character-studio-refine-preview-item">
                        <div class="character-studio-refine-preview-label">Before</div>
                        <div class="character-studio-refine-preview" data-refine-preview-before>
                          <div class="character-studio-refine-preview-empty">No character portrait available</div>
                        </div>
                      </div>
                      <div class="character-studio-refine-preview-item">
                        <div class="character-studio-refine-preview-label">After</div>
                        <div class="character-studio-refine-preview" data-refine-preview-after>
                          <div class="character-studio-refine-preview-empty">No refinement generated yet</div>
                        </div>
                      </div>
                    </div>
                    <div class="character-studio-refine-actions">
                      <button type="button" class="primary" data-refine-regenerate>Regenerate</button>
                      <button type="button" data-refine-save-variant>Save Variant</button>
                    </div>
                    <div class="character-studio-refine-status" data-refine-status>Ready</div>
                  </div>
                </div>
              </section>
              <section class="character-studio-section" role="tabpanel" tabindex="0" id="character-panel-poses" aria-labelledby="character-tab-poses" data-tab-panel="poses"${panelAttributes('poses')}>
                <h3>Pose Library</h3>
                <p class="muted-text">Lock in a transparent base PNG, then spin up labeled poses and expressions that stay true to this character.</p>
                <div class="character-studio-poses-panel" data-character-poses-panel>
                  <div class="character-studio-pose-grid">
                    <div class="character-studio-pose-card">
                      <h4>Base character PNG</h4>
                      <div class="character-studio-pose-preview" data-character-base-preview>
                        <div class="character-studio-pose-placeholder" data-character-base-empty>Upload a transparent PNG export to become the source of truth for this character.</div>
                        <img src="" alt="${escapeHtml(active.name || 'Character')} base PNG" data-character-base-image hidden />
                      </div>
                      <div class="character-studio-pose-actions">
                        <input type="file" accept="image/png" data-character-base-upload hidden />
                        <button type="button" data-character-base-trigger>Upload PNG</button>
                        <button type="button" data-character-base-refresh>Refresh</button>
                      </div>
                      <p class="character-studio-small-note">PNG should be at least 1024px on the long edge with no background. We store it privately in your Supabase project.</p>
                    </div>
                    <div class="character-studio-pose-card">
                      <h4>Generate new pose or expression</h4>
                      <form class="character-studio-pose-form" data-character-pose-form>
                        <label class="character-studio-field">
                          <span>Pose label</span>
                          <input type="text" required data-character-pose-label placeholder="e.g. Hero landing" />
                        </label>
                        <label class="character-studio-field">
                          <span>Description</span>
                          <textarea required data-character-pose-description placeholder="Describe the action, expression, camera, and props."></textarea>
                        </label>
                        <label class="character-studio-field">
                          <span>Scene use case (optional)</span>
                          <input type="text" data-character-pose-use-case placeholder="Battle, dialog, close-up" />
                        </label>
                        <div class="character-studio-pose-actions">
                          <button type="submit" data-character-pose-submit>Generate pose</button>
                          <button type="button" data-character-pose-refresh>Reload library</button>
                        </div>
                        <span class="character-studio-status" data-character-pose-status></span>
                      </form>
                    </div>
                  </div>
                  <div>
                    <h4>Saved poses</h4>
                    <p class="character-studio-small-note">The highest scoring poses are automatically marked for Storyboard Pro.</p>
                    <div class="character-studio-pose-list" data-character-pose-list>
                      <div class="character-studio-pose-placeholder" data-character-pose-empty>No poses generated yet.</div>
                    </div>
                  </div>
                </div>
              </section>
              <section class="character-studio-section" role="tabpanel" tabindex="0" id="character-panel-ai" aria-labelledby="character-tab-ai" data-tab-panel="ai"${panelAttributes('ai')}>
                <h3>AI Concepting</h3>
                <p class="muted-text">Draft prompts for StudioOrganize AI or export for other tools.</p>
                <label class="character-studio-field">
                  <span>AI prompt</span>
                  <textarea data-character-field="ai.prompt" placeholder="Describe the character's look, vibe, and scene">${escapeHtml(aiPrompt)}</textarea>
                </label>
                <label class="character-studio-field">
                  <span>Notes / references</span>
                  <textarea data-character-field="ai.notes" class="small" placeholder="Shot list, wardrobe callouts, artist references">${escapeHtml(aiNotes)}</textarea>
                </label>
                <div class="character-studio-ai-actions">
                  <button type="button" data-character-ai-generate>Save prompt &amp; prep AI render</button>
                  <span class="character-studio-status" data-ai-status></span>
                </div>
              </section>
            </div>
          </div>
        `;

        setupCharacterTabs(container);
        bindCharacterStudioFields(container, active);
        updateTimelineCharacterMeta();
        updateTimelineHighlights();
      }

      function refreshCharacterMeta(character){
        const heading = document.querySelector('[data-character-heading]');
        if (heading) heading.textContent = character?.name ? character.name : 'Untitled Character';
        const subheading = document.querySelector('[data-character-subheading]');
        if (subheading){
          const text = buildCharacterSubheading(character);
          subheading.textContent = text || 'Add role, pronouns, or age details.';
        }
        updateTimelineCharacterMeta();
        updateTimelineHighlights();
      }

      function refreshTraitsPreview(character){
        const preview = document.querySelector('[data-traits-preview]');
        if (preview) preview.innerHTML = buildTraitsPreviewMarkup(character);
      }

      function updateLookPreview(kind, character){
        const slot = document.querySelector(`[data-look-preview="${kind}"]`);
        if (!slot) return;
        let url = '';
        if (kind === 'portrait') url = (character?.looks?.portrait || '').trim();
        else if (kind === 'turnaround') url = Array.isArray(character?.looks?.turnarounds) ? character.looks.turnarounds[0] || '' : '';
        else if (kind === 'expression') url = Array.isArray(character?.looks?.expressions) ? character.looks.expressions[0] || '' : '';
        const content = slot.querySelector('[data-look-content]');
        if (content) content.innerHTML = characterLookPreviewMarkup(kind, url, character);
        if (kind === 'portrait'){
          const profileSlot = document.querySelector('[data-profile-portrait]');
          if (profileSlot) profileSlot.innerHTML = characterLookPreviewMarkup('portrait', url, character);
        }
      }

      function setupCharacterTabs(container){
        if (!container) return;
        const tablist = container.querySelector('[data-character-tablist]');
        if (!tablist) return;
        const buttons = Array.from(tablist.querySelectorAll('[data-tab-id]'));
        const panels = Array.from(container.querySelectorAll('[data-tab-panel]'));
        if (!buttons.length || !panels.length) return;

        const tabIds = buttons.map(btn => btn.getAttribute('data-tab-id'));
        if (!tabIds.includes(state.activeTabId)){
          state.activeTabId = tabIds[0];
        }

        const activate = (id, { focus } = { focus: true }) => {
          if (!tabIds.includes(id)) id = tabIds[0];
          state.activeTabId = id;
          buttons.forEach(btn => {
            const tabId = btn.getAttribute('data-tab-id');
            const isActive = tabId === id;
            btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
            btn.tabIndex = isActive ? 0 : -1;
            if (isActive && focus) btn.focus();
          });
          panels.forEach(panel => {
            const panelId = panel.getAttribute('data-tab-panel');
            const isActive = panelId === id;
            panel.hidden = !isActive;
            panel.setAttribute('aria-hidden', isActive ? 'false' : 'true');
          });
        };

        buttons.forEach((btn, index) => {
          const tabId = btn.getAttribute('data-tab-id');
          btn.addEventListener('click', () => activate(tabId, { focus: false }));
          btn.addEventListener('keydown', event => {
            if (!['ArrowRight', 'ArrowDown', 'ArrowLeft', 'ArrowUp', 'Home', 'End'].includes(event.key)) return;
            event.preventDefault();
            let targetIndex = index;
            if (event.key === 'ArrowRight' || event.key === 'ArrowDown'){
              targetIndex = (index + 1) % buttons.length;
            } else if (event.key === 'ArrowLeft' || event.key === 'ArrowUp'){
              targetIndex = (index - 1 + buttons.length) % buttons.length;
            } else if (event.key === 'Home'){
              targetIndex = 0;
            } else if (event.key === 'End'){
              targetIndex = buttons.length - 1;
            }
            activate(buttons[targetIndex].getAttribute('data-tab-id'));
          });
        });

        activate(state.activeTabId, { focus: false });
      }

      function setupDialogTab(container, active){
        if (!container || !active) return;
        const form = container.querySelector('[data-character-dialog-form]');
        if (form && form.dataset.bound !== 'true'){
          form.addEventListener('submit', event => {
            event.preventDefault();
            const textarea = form.querySelector('[data-character-dialog-input]');
            const value = textarea ? textarea.value.trim() : '';
            if (!value){
              setDialogStatus('Add some dialog before saving.', 'warning', active.id);
              applyDialogStatus(container);
              return;
            }
            addDialogDraftForCharacter(active.id, value);
            if (textarea) textarea.value = '';
            setDialogStatus('Saved to scratchpad.', 'ready', active.id);
            renderCharacterDetails();
          });
          form.dataset.bound = 'true';
        }
        const refreshBtn = container.querySelector('[data-character-dialog-refresh]');
        if (refreshBtn && refreshBtn.dataset.bound !== 'true'){
          refreshBtn.addEventListener('click', () => {
            loadScenesFromSupabase({ showStatus: true });
          });
          refreshBtn.dataset.bound = 'true';
        }
        const draftsContainer = container.querySelector('[data-character-dialog-drafts]');
        if (draftsContainer && draftsContainer.dataset.bound !== 'true'){
          draftsContainer.addEventListener('click', event => {
            const target = event.target;
            if (!(target instanceof Element)) return;
            const deleteBtn = target.closest('[data-dialog-draft-delete]');
            if (deleteBtn){
              const draftId = deleteBtn.getAttribute('data-dialog-draft-delete');
              if (draftId && removeDialogDraft(active.id, draftId)){
                setDialogStatus('Removed from scratchpad.', 'ready', active.id);
                renderCharacterDetails();
              }
              return;
            }
            const assignBtn = target.closest('[data-dialog-draft-assign]');
            if (assignBtn){
              const draftId = assignBtn.getAttribute('data-dialog-draft-assign');
              if (!draftId) return;
              const wrapper = assignBtn.closest('[data-dialog-draft]');
              const select = wrapper ? wrapper.querySelector('[data-dialog-draft-scene]') : null;
              const sceneId = select ? select.value : '';
              assignDialogDraftToScene(active.id, draftId, sceneId);
            }
          });
          draftsContainer.dataset.bound = 'true';
        }
        applyDialogStatus(container);
      }

      function bindCharacterStudioFields(container, active){
        if (!container || !active) return;
        const id = active.id;
        const aiStatus = container.querySelector('[data-ai-status]');
        const clearAiStatus = () => {
          if (aiStatus){
            aiStatus.textContent = '';
            aiStatus.removeAttribute('data-state');
          }
        };

        const nameInput = container.querySelector('[data-character-field="name"]');
        if (nameInput){
          nameInput.addEventListener('input', e => {
            updateCharacterField(id, 'name', e.target.value);
            renderCharacterList();
            refreshCharacterMeta(active);
            updateLookPreview('portrait', active);
            updateLookPreview('turnaround', active);
            updateLookPreview('expression', active);
          });
        }

        const roleInput = container.querySelector('[data-character-field="role"]');
        if (roleInput){
          roleInput.addEventListener('input', e => {
            updateCharacterField(id, 'role', e.target.value);
            renderCharacterList();
            refreshCharacterMeta(active);
          });
        }

        const archetypeInput = container.querySelector('[data-character-field="archetype"]');
        if (archetypeInput){
          archetypeInput.addEventListener('input', e => {
            updateCharacterField(id, 'archetype', e.target.value);
            renderCharacterList();
            refreshCharacterMeta(active);
          });
        }

        const pronounsInput = container.querySelector('[data-character-field="pronouns"]');
        if (pronounsInput){
          pronounsInput.addEventListener('input', e => {
            updateCharacterField(id, 'pronouns', e.target.value);
            renderCharacterList();
            refreshCharacterMeta(active);
          });
        }

        const ageInput = container.querySelector('[data-character-field="age"]');
        if (ageInput){
          ageInput.addEventListener('input', e => {
            updateCharacterField(id, 'age', e.target.value);
            renderCharacterList();
            refreshCharacterMeta(active);
          });
        }

        const summaryInput = container.querySelector('[data-character-field="summary"]');
        if (summaryInput){
          summaryInput.addEventListener('input', e => {
            updateCharacterField(id, 'summary', e.target.value);
            renderCharacterMobileGallery();
          });
        }

        const statsScenesInput = container.querySelector('[data-character-field="stats.scenes"]');
        if (statsScenesInput){
          statsScenesInput.addEventListener('input', e => {
            const value = parseIntegerInput(e.target.value);
            updateCharacterField(id, 'stats.scenes', value);
            const display = container.querySelector('[data-character-stat="scenes"]');
            if (display) display.textContent = value;
            renderCharacterMobileGallery();
          });
        }

        const statsDialogueInput = container.querySelector('[data-character-field="stats.dialogue"]');
        if (statsDialogueInput){
          statsDialogueInput.addEventListener('input', e => {
            const value = parseIntegerInput(e.target.value);
            updateCharacterField(id, 'stats.dialogue', value);
            const display = container.querySelector('[data-character-stat="dialogue"]');
            if (display) display.textContent = value;
            renderCharacterMobileGallery();
          });
        }

        const statsScreenTimeInput = container.querySelector('[data-character-field="stats.screenTime"]');
        if (statsScreenTimeInput){
          statsScreenTimeInput.addEventListener('input', e => {
            const value = parseFloatInput(e.target.value);
            updateCharacterField(id, 'stats.screenTime', value);
            const display = container.querySelector('[data-character-stat="screenTime"]');
            if (display) display.textContent = value;
            renderCharacterMobileGallery();
          });
        }

        const traitsInput = container.querySelector('[data-character-field="traits"]');
        if (traitsInput){
          traitsInput.addEventListener('input', e => {
            const list = normalizeList(e.target.value);
            updateCharacterField(id, 'traits', list);
            refreshTraitsPreview(active);
            renderCharacterMobileGallery();
          });
        }

        const backgroundInput = container.querySelector('[data-character-field="background"]');
        if (backgroundInput){
          backgroundInput.addEventListener('input', e => {
            updateCharacterField(id, 'background', e.target.value);
          });
        }

        const familyInput = container.querySelector('[data-character-field="familyTree"]');
        if (familyInput){
          familyInput.addEventListener('input', e => {
            updateCharacterField(id, 'familyTree', e.target.value);
          });
        }

        const arcSetupInput = container.querySelector('[data-character-field="arc.setup"]');
        if (arcSetupInput){
          arcSetupInput.addEventListener('input', e => {
            updateCharacterField(id, 'arc.setup', e.target.value);
          });
        }

        const arcDevInput = container.querySelector('[data-character-field="arc.development"]');
        if (arcDevInput){
          arcDevInput.addEventListener('input', e => {
            updateCharacterField(id, 'arc.development', e.target.value);
          });
        }

        const arcResolutionInput = container.querySelector('[data-character-field="arc.resolution"]');
        if (arcResolutionInput){
          arcResolutionInput.addEventListener('input', e => {
            updateCharacterField(id, 'arc.resolution', e.target.value);
          });
        }

        const portraitInput = container.querySelector('[data-character-field="looks.portrait"]');
        if (portraitInput){
          portraitInput.addEventListener('input', e => {
            const value = e.target.value.trim();
            updateCharacterField(id, 'looks.portrait', value);
            updateLookPreview('portrait', active);
            renderCharacterMobileGallery();
          });
        }

        const turnaroundsInput = container.querySelector('[data-character-field="looks.turnarounds"]');
        if (turnaroundsInput){
          turnaroundsInput.addEventListener('input', e => {
            const list = normalizeList(e.target.value);
            updateCharacterField(id, 'looks.turnarounds', list);
            updateLookPreview('turnaround', active);
          });
        }

        const expressionsInput = container.querySelector('[data-character-field="looks.expressions"]');
        if (expressionsInput){
          expressionsInput.addEventListener('input', e => {
            const list = normalizeList(e.target.value);
            updateCharacterField(id, 'looks.expressions', list);
            updateLookPreview('expression', active);
          });
        }

        const aiPromptInput = container.querySelector('[data-character-field="ai.prompt"]');
        if (aiPromptInput){
          aiPromptInput.addEventListener('input', e => {
            updateCharacterField(id, 'ai.prompt', e.target.value);
            clearAiStatus();
          });
        }

        const aiNotesInput = container.querySelector('[data-character-field="ai.notes"]');
        if (aiNotesInput){
          aiNotesInput.addEventListener('input', e => {
            updateCharacterField(id, 'ai.notes', e.target.value);
            clearAiStatus();
          });
        }

        const aiButton = container.querySelector('[data-character-ai-generate]');
        if (aiButton){
          aiButton.addEventListener('click', () => {
            const prompt = (active.ai?.prompt || '').trim();
            if (!prompt){
              if (aiStatus){
                aiStatus.textContent = 'Add an AI prompt to generate concept art.';
                aiStatus.dataset.state = 'warning';
              }
              return;
            }
            if (aiStatus){
              aiStatus.textContent = 'Prompt saved! Connect to StudioOrganize AI to generate character images.';
              aiStatus.dataset.state = 'ready';
            }
          });
        }

        const posePanel = container.querySelector('[data-character-poses-panel]');
        const poseStatusEl = container.querySelector('[data-character-pose-status]');
        const setPoseStatus = (message, state = '') => {
          if (!poseStatusEl) return;
          poseStatusEl.textContent = message || '';
          if (state){
            poseStatusEl.dataset.state = state;
          } else {
            poseStatusEl.removeAttribute('data-state');
          }
        };

        const handlePoseLibraryRender = async (force = false) => {
          if (!posePanel) return;
          try {
            if (force) setPoseStatus('Refreshing pose library‚Ä¶', 'saving');
            const poses = await fetchPoseLibraryForCharacter(id, { force });
            renderPoseLibrary(posePanel, active, poses);
            if (force) setPoseStatus('Pose library synced.', 'ready');
          } catch (err){
            console.error('Character Studio pose library fetch failed', err);
            renderPoseLibrary(posePanel, active, []);
            setPoseStatus('Unable to load pose library.', 'error');
          }
        };

        const baseUploadInput = container.querySelector('[data-character-base-upload]');
        const baseTrigger = container.querySelector('[data-character-base-trigger]');
        const baseRefresh = container.querySelector('[data-character-base-refresh]');
        if (baseTrigger && baseUploadInput){
          baseTrigger.addEventListener('click', () => baseUploadInput.click());
        }
        if (baseUploadInput){
          baseUploadInput.addEventListener('change', async event => {
            const file = event.target.files && event.target.files[0];
            if (!file) return;
            if (file.type !== 'image/png'){
              setPoseStatus('Upload a transparent PNG file.', 'warning');
              baseUploadInput.value = '';
              return;
            }
            try {
              setPoseStatus('Uploading base PNG‚Ä¶', 'saving');
              const dataUrl = await readFileAsDataUrl(file);
              const result = await invokeImagePipeline('upload-base', { character_id: id, image: dataUrl });
              const basePath = result?.base_image_url || '';
              if (basePath){
                invalidateSignedUrl(basePath);
                updateCharacterField(id, 'baseImageUrl', basePath);
                active.baseImageUrl = basePath;
                if (result?.signed_url){
                  state.signedUrlCache.set(basePath, result.signed_url);
                }
                state.poseCache.delete(id);
                await refreshBasePreview(container, active);
                setPoseStatus('Base PNG saved.', 'ready');
              } else {
                setPoseStatus('Upload succeeded but no image URL returned.', 'warning');
              }
            } catch (err){
              console.error('Character Studio base PNG upload failed', err);
              setPoseStatus('Upload failed. Try again.', 'error');
            } finally {
              baseUploadInput.value = '';
            }
          });
        }
        if (baseRefresh){
          baseRefresh.addEventListener('click', () => {
            if (active.baseImageUrl) invalidateSignedUrl(active.baseImageUrl);
            refreshBasePreview(container, active);
          });
        }

        const poseForm = container.querySelector('[data-character-pose-form]');
        const poseSubmit = poseForm ? poseForm.querySelector('[data-character-pose-submit]') : null;
        if (poseForm){
          poseForm.addEventListener('submit', async event => {
            event.preventDefault();
            const labelInput = poseForm.querySelector('[data-character-pose-label]');
            const descriptionInput = poseForm.querySelector('[data-character-pose-description]');
            const useCaseInput = poseForm.querySelector('[data-character-pose-use-case]');
            const label = labelInput ? labelInput.value.trim() : '';
            const description = descriptionInput ? descriptionInput.value.trim() : '';
            const useCase = useCaseInput ? useCaseInput.value.trim() : '';
            if (!active.baseImageUrl){
              setPoseStatus('Upload a base PNG before generating poses.', 'warning');
              return;
            }
            if (!label || !description){
              setPoseStatus('Add a label and description for the pose.', 'warning');
              return;
            }
            try {
              setPoseStatus('Generating pose‚Ä¶', 'saving');
              if (poseSubmit) poseSubmit.disabled = true;
              const response = await invokeImagePipeline('generate-poses', {
                character_id: id,
                poses: [{ label, description, scene_use_case: useCase || undefined }],
              });
              const generated = Array.isArray(response?.poses) ? response.poses : [];
              if (generated.length){
                const poses = generated.map(item => ({
                  id: item.id,
                  pose_label: item.pose_label,
                  pose_description: item.pose_description,
                  scene_use_case: item.scene_use_case || '',
                  generated_image_url: item.generated_image_url,
                  score: Number(item.score) || 0,
                  approved_for_scene: Boolean(item.approved_for_scene),
                  signedUrl: item.signed_url || null,
                }));
                state.poseCache.set(id, poses);
                updateCharacterField(id, 'hasPoseLibrary', true);
                active.hasPoseLibrary = true;
                renderPoseLibrary(posePanel, active, poses);
                poseForm.reset();
                setPoseStatus('Pose generated! Review the library below.', 'ready');
              } else {
                setPoseStatus('Pose generation completed without new results.', 'warning');
              }
            } catch (err){
              console.error('Character Studio pose generation failed', err);
              setPoseStatus('Pose generation failed. Try again.', 'error');
            } finally {
              if (poseSubmit) poseSubmit.disabled = false;
            }
          });
        }

        container.querySelectorAll('[data-character-pose-refresh]').forEach(button => {
          button.addEventListener('click', () => {
            handlePoseLibraryRender(true);
          });
        });

        refreshBasePreview(container, active);
        handlePoseLibraryRender(false);

        const deleteBtn = container.querySelector('[data-character-delete]');
        if (deleteBtn){
          deleteBtn.addEventListener('click', () => {
            const name = active.name || 'this character';
            const ok = window.confirm(`Delete ${name}? This will remove their notes and stats.`);
            if (!ok) return;
            const index = state.characters.findIndex(c => c.id === id);
            if (index !== -1) state.characters.splice(index, 1);
            if (state.characters.length){
              state.activeId = state.characters[0].id;
            } else {
              state.activeId = null;
            }
            markDirty();
            renderCharacterList();
            renderCharacterDetails();
          });
        }
        
        const finishStoryBtn = container.querySelector('[data-character-finish-story]');
        if (finishStoryBtn){
          finishStoryBtn.addEventListener('click', () => {
            startFinishThatStory(container, active);
          });
        }

        setupDialogTab(container, active);
        ensureMobileCloseButton(container);
        updateMobileActiveCard();
        scrollMobileGalleryToActive({ smooth: true });
        
        // Initialize refinement panel for this character
        enterRefineModeForCharacter(active);
      }

      // =========================================================================
      // Visual Refinement Panel (UI + Stubs)
      // =========================================================================
      //
      // Stage 2: Visual Refinement Tools (UI only, no real API calls yet)
      //
      // State:
      //   - currentRefineState: Holds refinement parameters (age, mood, hair, etc.)
      //   - isDirty: Tracks if settings have changed
      //
      // Functions:
      //   - enterRefineModeForCharacter(): Populates "before" preview and syncs UI
      //   - regenerateRefinement(): Stub - simulates refine call with timeout
      //   - saveRefinedVariant(): Stub - shows status message
      // =========================================================================

      const currentRefineState = {
        age: 'default',
        mood: 'neutral',
        hairLength: 'medium',
        eyebrowShape: 'soft',
        style: 'realistic',
        detail: 'standard',
        isDirty: false
      };

      function setRefineStatus(message, state = '') {
        const statusEl = document.querySelector('[data-refine-status]');
        if (!statusEl) return;
        statusEl.textContent = message;
        if (state) {
          statusEl.setAttribute('data-state', state);
        } else {
          statusEl.removeAttribute('data-state');
        }
      }

      function enterRefineModeForCharacter(character) {
        if (!character) {
          setRefineStatus('No character selected', 'warning');
          return;
        }

        // Reset state to defaults
        currentRefineState.age = 'default';
        currentRefineState.mood = 'neutral';
        currentRefineState.hairLength = 'medium';
        currentRefineState.eyebrowShape = 'soft';
        currentRefineState.style = 'realistic';
        currentRefineState.detail = 'standard';
        currentRefineState.isDirty = false;

        // Update "before" preview with current character portrait
        const beforePreview = document.querySelector('[data-refine-preview-before]');
        if (beforePreview) {
          const portraitUrl = character.looks?.portrait || character.lookPortraitUrl || '';
          if (portraitUrl) {
            beforePreview.innerHTML = `<img src="${escapeHtml(portraitUrl)}" alt="Current character portrait" />`;
          } else {
            beforePreview.innerHTML = '<div class="character-studio-refine-preview-empty">No character portrait available</div>';
          }
        }

        // Clear "after" preview
        const afterPreview = document.querySelector('[data-refine-preview-after]');
        if (afterPreview) {
          afterPreview.innerHTML = '<div class="character-studio-refine-preview-empty">No refinement generated yet</div>';
        }

        // Reset all controls to default values
        const ageSelect = document.querySelector('[data-refine-control="age"]');
        if (ageSelect) {
          ageSelect.value = 'default';
        }

        // Reset pill buttons
        document.querySelectorAll('[data-refine-pill]').forEach(pill => {
          const group = pill.getAttribute('data-refine-pill');
          const value = pill.getAttribute('data-value');
          if (
            (group === 'mood' && value === 'neutral') ||
            (group === 'hairLength' && value === 'medium') ||
            (group === 'eyebrowShape' && value === 'soft') ||
            (group === 'style' && value === 'realistic') ||
            (group === 'detail' && value === 'standard')
          ) {
            pill.classList.add('selected');
          } else {
            pill.classList.remove('selected');
          }
        });

        setRefineStatus('Ready', 'ready');
      }

      function regenerateRefinement() {
        const beforePreview = document.querySelector('[data-refine-preview-before]');
        const afterPreview = document.querySelector('[data-refine-preview-after]');
        const regenerateBtn = document.querySelector('[data-refine-regenerate]');
        const saveBtn = document.querySelector('[data-refine-save-variant]');

        if (!beforePreview || !afterPreview) return;

        // Check if we have a "before" image
        const beforeImg = beforePreview.querySelector('img');
        if (!beforeImg) {
          setRefineStatus('No character portrait to refine', 'warning');
          return;
        }

        // Disable buttons during generation
        if (regenerateBtn) regenerateBtn.disabled = true;
        if (saveBtn) saveBtn.disabled = true;

        // Show loading state
        afterPreview.innerHTML = `
          <div class="character-studio-refine-loading">
            <div class="character-studio-refine-loading-spinner"></div>
            <span>Refining character...</span>
          </div>
        `;
        setRefineStatus('Refining‚Ä¶', 'refining');

        // Simulate API call with setTimeout (stub)
        setTimeout(() => {
          // For stub: copy the "before" image to "after" (or use a placeholder)
          const beforeImgSrc = beforeImg.src;
          afterPreview.innerHTML = `<img src="${beforeImgSrc}" alt="Refined character preview" />`;
          
          setRefineStatus('Refined preview ready (stub)', 'ready');
          
          // Re-enable buttons
          if (regenerateBtn) regenerateBtn.disabled = false;
          if (saveBtn) saveBtn.disabled = false;
        }, 1500); // 1.5 second simulation
      }

      function saveRefinedVariant() {
        const afterPreview = document.querySelector('[data-refine-preview-after]');
        if (!afterPreview) return;

        const afterImg = afterPreview.querySelector('img');
        if (!afterImg) {
          setRefineStatus('Generate a refinement first', 'warning');
          return;
        }

        // Stub: Show success message
        setRefineStatus('Variant would be saved here (stub)', 'ready');
        
        // In real implementation, this would:
        // 1. Call refine API to save the variant
        // 2. Update character.looks.portrait or add to variants array
        // 3. Trigger re-render of lookbook
      }

      // Set up event listeners for refinement controls
      function setupRefineControls() {
        // Age select
        const ageSelect = document.querySelector('[data-refine-control="age"]');
        if (ageSelect) {
          ageSelect.addEventListener('change', (e) => {
            currentRefineState.age = e.target.value;
            currentRefineState.isDirty = true;
          });
        }

        // Pill button groups
        document.querySelectorAll('[data-refine-pill]').forEach(pill => {
          pill.addEventListener('click', () => {
            const group = pill.getAttribute('data-refine-pill');
            const value = pill.getAttribute('data-value');
            
            // Update state
            if (group === 'mood') currentRefineState.mood = value;
            else if (group === 'hairLength') currentRefineState.hairLength = value;
            else if (group === 'eyebrowShape') currentRefineState.eyebrowShape = value;
            else if (group === 'style') currentRefineState.style = value;
            else if (group === 'detail') currentRefineState.detail = value;
            
            currentRefineState.isDirty = true;

            // Update UI: toggle selected class within the group
            document.querySelectorAll(`[data-refine-pill="${group}"]`).forEach(p => {
              p.classList.remove('selected');
            });
            pill.classList.add('selected');
          });
        });

        // Regenerate button
        const regenerateBtn = document.querySelector('[data-refine-regenerate]');
        if (regenerateBtn) {
          regenerateBtn.addEventListener('click', regenerateRefinement);
        }

        // Save variant button
        const saveBtn = document.querySelector('[data-refine-save-variant]');
        if (saveBtn) {
          saveBtn.addEventListener('click', saveRefinedVariant);
        }
      }

      async function waitForSupabaseClient(timeoutMs = 6000){
        if (window.supabaseClient) return window.supabaseClient;
        const start = Date.now();
        while (Date.now() - start < timeoutMs){
          await new Promise(resolve => setTimeout(resolve, 50));
          if (window.supabaseClient) return window.supabaseClient;
        }
        return window.supabaseClient || null;
      }

      async function fetchSupabaseSession(client){
        try {
          const { data, error } = await client.auth.getSession();
          if (error) throw error;
          return data?.session ?? null;
        } catch (err){
          console.error('Character Studio failed to fetch Supabase session', err);
          return null;
        }
      }

      async function invokeImagePipeline(action, payload){
        if (!state.supabase){
          throw new Error('Supabase client not ready');
        }
        if (!state.session?.access_token){
          throw new Error('Sign in to generate AI assets.');
        }
        const body = { ...(payload || {}), action };
        const { data, error } = await state.supabase.functions.invoke('ai-image-pipeline', {
          body,
          headers: { Authorization: `Bearer ${state.session.access_token}` },
        });
        if (error) throw error;
        return data;
      }

      async function loadProjectMetadata(){
        if (!state.supabase || !state.projectId || !state.ownerId) return;
        try {
          const filters = [`id.eq.${state.projectId}`, `project_id.eq.${state.projectId}`, `script_id.eq.${state.projectId}`];
          const { data, error } = await state.supabase
            .from('project_data')
            .select('id, project_id, script_id, script_name, name, title, description, updated_at')
            .or(filters.join(','))
            .order('updated_at', { ascending: false })
            .limit(1)
            .maybeSingle();
          if (error) throw error;
          if (data){
            const label = data.script_name || data.name || data.title || 'Untitled Story';
            setProjectLabel(`Story: ${label}`, 'ready');
            return;
          }
        } catch (err){
          console.warn('Character Studio project metadata fetch failed:', err);
        }
        const fallback = state.projectId ? `Story ID: ${state.projectId.slice(0, 8).toUpperCase()}` : 'No story selected';
        setProjectLabel(fallback, state.projectId ? '' : 'warning');
      }

      async function loadScenesFromSupabase({ showStatus = false } = {}){
        if (!state.supabase || !state.projectId || !state.ownerId){
          state.scenes = [];
          state.scenesLoaded = false;
          state.scenesError = '';
          if (showStatus){
            setDialogStatus('Sign in to sync script dialog.', 'warning', state.activeId);
          }
          return;
        }
        state.scenesLoading = true;
        if (showStatus){
          setDialogStatus('Refreshing script dialog‚Ä¶', 'saving', state.activeId);
        }
        try {
          const { data, error } = await state.supabase
            .from('scenes')
            .select('id, title, slug, scene_number, script_order, elements')
            .eq('project_id', state.projectId)
            .eq('owner_id', state.ownerId)
            .order('script_order', { ascending: true })
            .order('scene_number', { ascending: true });
          if (error) throw error;
          const list = Array.isArray(data) ? data.map(supabaseRowToScene).filter(Boolean) : [];
          state.scenes = list;
          state.scenesLoaded = true;
          state.scenesError = '';
          if (showStatus){
            setDialogStatus('Script dialog synced.', 'ready', state.activeId);
          }
        } catch (err){
          console.warn('Character Studio failed to load scenes', err);
          state.scenesError = 'Unable to load script dialog.';
          state.scenesLoaded = false;
          if (showStatus){
            setDialogStatus('Unable to load script dialog.', 'error', state.activeId);
          }
        } finally {
          state.scenesLoading = false;
          if (state.activeId){
            renderCharacterDetails();
          }
        }
      }

      async function loadCharactersFromSupabase(){
        if (!state.supabase || !state.projectId || !state.ownerId){
          state.loading = false;
          renderCharacterList();
          renderCharacterDetails();
          updateSaveButtonState();
          return;
        }
        state.loading = true;
        renderCharacterList();
        renderCharacterDetails();
        updateSaveButtonState();
        setSaveStatus('Loading characters‚Ä¶', 'saving');
        try {
          const { data, error } = await state.supabase
            .from('characters')
            .select('id, name, role, archetype, pronouns, age, summary, background, family_tree, traits, stats_scenes, stats_dialogue, stats_screen_time, arc_setup, arc_development, arc_resolution, look_portrait_url, look_turnaround_urls, look_expression_urls, base_image_url, has_pose_library, ai_prompt, ai_notes, created_at')
            .eq('project_id', state.projectId)
            .order('created_at', { ascending: true });
          if (error) throw error;
          const list = Array.isArray(data) ? data.map(supabaseRowToCharacter) : [];
          state.characters = list;
          ensureStateCharacterIds();
          state.poseCache.clear();
          state.activeId = list.length ? list[0].id : null;
          state.remoteIds = new Set(list.map(char => char.id));
          state.dirty = false;
          await persistCharactersToLocal();
          if (list.length){
            setSaveStatus('Characters synced.', 'ready');
          } else {
            setSaveStatus('No characters saved yet for this story.', 'warning');
          }
        } catch (err){
          console.error('Failed to load characters from Supabase', err);
          setSaveStatus('Unable to load characters from Supabase.', 'error');
        } finally {
          state.loading = false;
          renderCharacterList();
          renderCharacterDetails();
          updateSaveButtonState();
        }
      }

      async function assignDialogDraftToScene(characterId, draftId, sceneId){
        const activeId = characterId || state.activeId;
        if (!characterId || !draftId){
          setDialogStatus('Select a dialog draft to insert.', 'warning', activeId);
          return false;
        }
        if (!sceneId){
          setDialogStatus('Choose a scene before inserting dialog.', 'warning', activeId);
          return false;
        }
        if (!state.supabase || !state.session || !state.ownerId || !state.projectId){
          setDialogStatus('Sign in to sync dialog to scenes.', 'warning', activeId);
          return false;
        }
        const scene = Array.isArray(state.scenes) ? state.scenes.find(entry => entry && entry.id === sceneId) : null;
        if (!scene){
          setDialogStatus('Scene not found. Refresh script lines and try again.', 'error', activeId);
          return false;
        }
        const draft = getDialogDraftsForCharacter(characterId).find(entry => entry.id === draftId);
        if (!draft){
          setDialogStatus('Dialog draft not found.', 'error', activeId);
          return false;
        }
        const text = typeof draft.text === 'string' ? draft.text.trim() : '';
        if (!text){
          setDialogStatus('Dialog draft is empty.', 'warning', activeId);
          return false;
        }
        setDialogStatus('Inserting dialog into scene‚Ä¶', 'saving', activeId);
        const dialogElement = normalizeSceneElementLite({ t: 'dialogue', txt: text, ownerId: characterId });
        const spacing = [normalizeSceneElementLite({ t: 'action', txt: '' }), normalizeSceneElementLite({ t: 'action', txt: '' })];
        const existing = Array.isArray(scene.elements) ? scene.elements.map(normalizeSceneElementLite) : [];
        const nextElements = [dialogElement, ...spacing, ...existing];
        try {
          const { error } = await state.supabase
            .from('scenes')
            .update({ elements: nextElements })
            .eq('id', sceneId)
            .eq('owner_id', state.ownerId)
            .eq('project_id', state.projectId);
          if (error) throw error;
          scene.elements = nextElements.map(normalizeSceneElementLite);
          removeDialogDraft(characterId, draftId);
          setDialogStatus(`Dialog added to ${getSceneDisplayLabel(scene)}.`, 'ready', activeId);
          renderCharacterDetails();
          return true;
        } catch (err){
          console.error('Character Studio failed to assign dialog to scene', err);
          setDialogStatus('Insert failed. Please try again.', 'error', activeId);
          return false;
        }
      }

      async function handleSession(session){
        state.session = session;
        const ownerId = session?.user?.id || null;
        const previousOwner = state.ownerId;
        state.ownerId = ownerId;
        updateSaveButtonState();
        if (!ownerId){
          state.remoteIds = new Set();
          state.characters = [];
          state.activeId = null;
          state.dirty = false;
          state.loading = false;
          state.scenes = [];
          state.scenesLoaded = false;
          state.scenesError = '';
          state.scenesLoading = false;
          renderCharacterList();
          renderCharacterDetails();
          if (state.projectId){
            setSaveStatus('Sign in to load and save your cast.', 'warning');
          }
          return;
        }
        if (!state.projectId){
          state.loading = false;
          state.scenes = [];
          state.scenesLoaded = false;
          state.scenesError = '';
          state.scenesLoading = false;
          renderCharacterList();
          renderCharacterDetails();
          setSaveStatus('Open your story in the Writer to link characters.', 'warning');
          return;
        }
        if (previousOwner !== ownerId){
          state.remoteIds = new Set();
          state.scenes = [];
          state.scenesLoaded = false;
          state.scenesError = '';
        }
        await Promise.all([loadProjectMetadata(), loadCharactersFromSupabase(), loadScenesFromSupabase()]);
      }

      async function handleSaveClick(){
        if (state.saving) return { success: false, reason: 'busy' };
        if (!state.supabase){
          setSaveStatus('Supabase is still initializing. Please try again.', 'warning');
          return { success: false, reason: 'supabase_unavailable' };
        }
        if (!state.session || !state.ownerId){
          setSaveStatus('Sign in to save your cast.', 'warning');
          return { success: false, reason: 'unauthenticated' };
        }
        if (!state.projectId){
          setSaveStatus('Open your story in the Writer to link characters.', 'warning');
          return { success: false, reason: 'missing_project' };
        }
        ensureStateCharacterIds();
        const rows = state.characters.map(characterToSupabaseRow);
        const verificationSnapshot = prepareCharacterRowsForVerification(rows);
        if (!state.dirty){
          setSaveStatus('Everything is up to date.', 'ready');
          return { success: true, expectedRows: verificationSnapshot, skipped: true };
        }
        state.saving = true;
        updateSaveButtonState();
        setSaveStatus('Saving‚Ä¶', 'saving');
        try {
          if (rows.length){
            const { error } = await state.supabase
              .from('characters')
              .upsert(rows, { onConflict: 'id' });
            if (error) throw error;
          }
          const localIds = new Set(rows.map(row => row.id));
          const remoteIds = Array.from(state.remoteIds || []);
          const idsToDelete = remoteIds.filter(id => !localIds.has(id));
          if (idsToDelete.length){
            const { error: deleteError } = await state.supabase
              .from('characters')
              .delete()
              .in('id', idsToDelete);
            if (deleteError) throw deleteError;
          }
          state.remoteIds = localIds;
          state.dirty = false;
          await persistCharactersToLocal();
          setSaveStatus('Characters saved!', 'ready');
          return { success: true, expectedRows: verificationSnapshot };
        } catch (err){
          console.error('Failed to save characters to Supabase', err);
          setSaveStatus('Save failed. Please try again.', 'error');
          return { success: false, expectedRows: verificationSnapshot, error: err };
        } finally {
          state.saving = false;
          updateSaveButtonState();
        }
      }

      // FinishThatStory AI Assistant functionality
      function startFinishThatStory(container, character){
        if (!container || !character) return;
        
        // Define all fields that can be filled with their questions and advice
        const fieldDefinitions = [
          {
            selector: '[data-character-field="name"]',
            name: 'Character Name',
            question: 'What\'s your character\'s name?',
            advice: 'Tip: Choose a name that reflects your character\'s background, culture, or personality. Consider the time period and setting of your story.'
          },
          {
            selector: '[data-character-field="role"]',
            name: 'Role',
            question: 'What role does this character play in your story?',
            advice: 'Common roles include: Protagonist, Antagonist, Mentor, Sidekick, Love Interest. Think about how they drive the plot forward.'
          },
          {
            selector: '[data-character-field="archetype"]',
            name: 'Archetype',
            question: 'What archetype best describes your character?',
            advice: 'Examples: The Hero, The Rebel, The Caregiver, The Explorer. Archetypes help readers quickly understand character motivations.'
          },
          {
            selector: '[data-character-field="pronouns"]',
            name: 'Pronouns',
            question: 'What pronouns does your character use?',
            advice: 'Common options: He/Him, She/Her, They/Them. This helps establish how other characters refer to them.'
          },
          {
            selector: '[data-character-field="age"]',
            name: 'Age',
            question: 'How old is your character?',
            advice: 'Age affects perspective, maturity, and life experience. Consider how their age impacts their decisions and relationships.'
          },
          {
            selector: '[data-character-field="summary"]',
            name: 'Summary',
            question: 'Can you describe your character in a brief summary?',
            advice: 'Aim for 1-3 sentences that capture the essence of who they are and what makes them unique.'
          },
          {
            selector: '[data-character-field="traits"]',
            name: 'Traits & Personality',
            question: 'What are your character\'s defining personality traits?',
            advice: 'Include both positive and negative traits. Consider: Are they brave or cautious? Honest or secretive? Optimistic or cynical?'
          },
          {
            selector: '[data-character-field="background"]',
            name: 'Background',
            question: 'What\'s your character\'s background story?',
            advice: 'Where did they come from? What key experiences shaped who they are today? What do they care most about?'
          },
          {
            selector: '[data-character-field="familyTree"]',
            name: 'Family & Relationships',
            question: 'Who are the important people in your character\'s life?',
            advice: 'Consider family members, friends, rivals, or romantic interests. How do these relationships influence your character?'
          },
          {
            selector: '[data-character-field="arc.setup"]',
            name: 'Character Arc - Setup',
            question: 'Who is your character at the beginning of the story?',
            advice: 'Describe their initial state: beliefs, fears, goals. What is their normal world before the story events?'
          },
          {
            selector: '[data-character-field="arc.development"]',
            name: 'Character Arc - Development',
            question: 'How does your character change throughout the story?',
            advice: 'What challenges do they face? What do they learn? How are they tested? This is where growth happens.'
          },
          {
            selector: '[data-character-field="arc.resolution"]',
            name: 'Character Arc - Resolution',
            question: 'Who is your character at the end of the story?',
            advice: 'How have they transformed? What have they learned or overcome? How are they different from the beginning?'
          }
        ];
        
        // Shuffle the fields randomly
        const shuffledFields = [...fieldDefinitions].sort(() => Math.random() - 0.5);
        
        // Filter to only include fields that exist in the DOM
        const availableFields = shuffledFields.filter(field => {
          return container.querySelector(field.selector) !== null;
        });
        
        if (availableFields.length === 0) {
          alert('No fields available to fill. Please make sure you have a character selected.');
          return;
        }
        
        let currentFieldIndex = 0;
        let activeFieldElement = null;
        
        const overlay = document.querySelector('[data-fts-overlay]');
        const assistant = document.querySelector('[data-fts-assistant]');
        const questionEl = document.querySelector('[data-fts-question-text]');
        const fieldNameEl = document.querySelector('[data-fts-field-name]');
        const adviceEl = document.querySelector('[data-fts-advice]');
        const progressEl = document.querySelector('[data-fts-progress]');
        const nextBtn = document.querySelector('[data-fts-next]');
        const skipBtn = document.querySelector('[data-fts-skip]');
        
        if (!overlay || !assistant) return;
        
        // Show overlay and dim the page
        overlay.classList.add('active');
        const mainContent = document.querySelector('.character-studio-window');
        if (mainContent) {
          mainContent.classList.add('fts-dimmed');
        }
        
        function showField(index){
          // Remove highlight from previous field
          if (activeFieldElement){
            activeFieldElement.classList.remove('fts-highlighted');
          }
          
          if (index >= availableFields.length){
            // All fields completed
            closeAssistant();
            alert('Great job! You\'ve completed the character development walkthrough. Your character is now more fully developed!');
            return;
          }
          
          const fieldDef = availableFields[index];
          const fieldElement = container.querySelector(fieldDef.selector);
          
          if (!fieldElement){
            // Field not found, skip to next
            currentFieldIndex++;
            showField(currentFieldIndex);
            return;
          }
          
          activeFieldElement = fieldElement;
          
          // Highlight the current field
          fieldElement.classList.add('fts-highlighted');
          
          // Update assistant content
          if (fieldNameEl) fieldNameEl.textContent = fieldDef.name;
          if (questionEl) questionEl.textContent = fieldDef.question;
          if (adviceEl) adviceEl.textContent = fieldDef.advice;
          if (progressEl) progressEl.textContent = `Field ${index + 1} of ${availableFields.length}`;
          
          // Position assistant near the field
          positionAssistant(fieldElement);
          
          // Show assistant
          assistant.classList.add('active');
          
          // Focus the field
          setTimeout(() => {
            fieldElement.focus();
            fieldElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 100);
        }
        
        function positionAssistant(fieldElement){
          if (!fieldElement || !assistant) return;
          
          const fieldRect = fieldElement.getBoundingClientRect();
          const assistantWidth = 400;
          const assistantHeight = 300;
          const padding = 30;
          
          let top = fieldRect.top - assistantHeight - padding;
          let left = fieldRect.left + (fieldRect.width / 2) - (assistantWidth / 2);
          
          // Adjust if assistant goes off screen
          if (top < 20){
            top = fieldRect.bottom + padding;
          }
          
          if (left < 20){
            left = 20;
          } else if (left + assistantWidth > window.innerWidth - 20){
            left = window.innerWidth - assistantWidth - 20;
          }
          
          assistant.style.top = `${top}px`;
          assistant.style.left = `${left}px`;
        }
        
        function closeAssistant(){
          overlay.classList.remove('active');
          assistant.classList.remove('active');
          if (mainContent){
            mainContent.classList.remove('fts-dimmed');
          }
          if (activeFieldElement){
            activeFieldElement.classList.remove('fts-highlighted');
          }
        }
        
        function handleNext(){
          currentFieldIndex++;
          showField(currentFieldIndex);
        }
        
        function handleSkip(){
          currentFieldIndex++;
          showField(currentFieldIndex);
        }
        
        // Add event listeners
        nextBtn.addEventListener('click', handleNext);
        skipBtn.addEventListener('click', handleSkip);
        overlay.addEventListener('click', closeAssistant);
        
        // Handle keyboard shortcuts
        const handleKeydown = (e) => {
          if (e.key === 'Escape'){
            closeAssistant();
            document.removeEventListener('keydown', handleKeydown);
          } else if (e.key === 'Enter' && e.ctrlKey){
            handleNext();
          }
        };
        document.addEventListener('keydown', handleKeydown);
        
        // Start with the first field
        showField(currentFieldIndex);
      }

      async function initializeSupabase(){
        if (!state.projectId){
          setProjectLabel('No story selected ‚Äî open the Writer to choose a story.', 'warning');
          state.loading = false;
          renderCharacterList();
          renderCharacterDetails();
          updateSaveButtonState();
          return;
        }
        const supabase = await waitForSupabaseClient();
        if (!supabase){
          state.loading = false;
          setSaveStatus('Supabase is unavailable. Reload to try again.', 'error');
          renderCharacterList();
          renderCharacterDetails();
          updateSaveButtonState();
          return;
        }
        state.supabase = supabase;
        updateSaveButtonState();
        const session = await fetchSupabaseSession(supabase);
        await handleSession(session);
        supabase.auth.onAuthStateChange((event, nextSession) => {
          if (event === 'TOKEN_REFRESHED'){
            state.session = nextSession;
            state.ownerId = nextSession?.user?.id || null;
            updateSaveButtonState();
            return;
          }
          handleSession(nextSession).catch(err => console.error('Character Studio auth change failed', err));
        });
      }

      // =========================================================================
      // Character Creation Wizard
      // =========================================================================
      //
      // Three-step wizard for creating characters with AI-generated images:
      //
      // STEP 1: Archetype Selection
      //   - User selects from: hero, villain, sci-fi, fantasy, child, robot
      //   - Stored in currentCharacterDraft.archetype
      //   - Validation ensures archetype is selected before continuing
      //
      // STEP 2: Visual Draft Generation
      //   - Automatically generates AI image using archetype + style tier
      //   - Calls generateCharacterDraft() ‚Üí ai-image-pipeline Supabase function
      //   - Returns: image_url, storage_path, draft_id
      //   - User can:
      //     * Regenerate: Generate new image with same archetype/tier
      //     * Swap Style: Toggle between standard/premium tiers
      //     * Try Another: Reset and go back to Step 1
      //   - Continue button advances to Step 3 when image_url exists
      //
      // STEP 3: Save Character
      //   - Shows preview of generated image
      //   - "Save Character" button calls saveCharacterFromDraft()
      //   - Inserts into characters table with:
      //     * Default name based on archetype (e.g., "New Hero")
      //     * look_portrait_url: image_url from draft
      //     * base_image_url: storage_path from draft
      //     * archetype: selected archetype
      //   - On success:
      //     * Adds to state.characters and sets as active
      //     * Updates sidebar and detail view
      //     * Shows "Character saved!" message
      //     * Closes wizard after 800ms delay
      //   - Back button returns to Step 2 for modifications
      //
      // State Management:
      //   - currentCharacterDraft: Temporary draft data during wizard flow
      //   - wizardCurrentStep: Current step number (1, 2, or 3)
      //   - Wizard resets on close or cancel
      //
      // UI Behavior:
      //   - Steps 1-2: Show Cancel + Continue buttons
      //   - Step 3: Hide default buttons, show Back + Save Character
      //   - Status messages show loading, errors, and success states
      // =========================================================================
      
      const currentCharacterDraft = {
        archetype: null,
        style: 'default',
        image_url: null,
        storage_path: null,
        draft_id: null
      };

      let wizardCurrentStep = 1;

      /**
       * Save a character from the wizard draft to Supabase.
       * Creates a new character row in the 'characters' table with data from currentCharacterDraft.
       * 
       * Assumptions about the characters table (from supabase/schema.sql):
       * - Table name: 'characters'
       * - Required fields: owner_id, project_id (can be null for now)
       * - Name field: 'name' (text, not null, defaults to '')
       * - Archetype field: 'archetype' (text, nullable)
       * - Portrait field: 'look_portrait_url' (text, nullable) - we'll use image_url from draft
       * - Storage path: can use 'base_image_url' (text, nullable) to store storage_path
       * 
       * @returns {Promise<Object>} The saved character object
       */
      async function saveCharacterFromDraft() {
        const saveStatusEl = document.querySelector('[data-wizard-save-status]');
        const saveButton = document.querySelector('[data-wizard-save-character]');
        
        // Helper to set status message
        const setStatus = (message, state = '') => {
          if (saveStatusEl) {
            saveStatusEl.textContent = message;
            if (state === 'error') {
              saveStatusEl.style.color = '#ef4444';
            } else if (state === 'saving') {
              saveStatusEl.style.color = 'var(--brand)';
            } else if (state === 'success') {
              saveStatusEl.style.color = 'var(--acc)';
            } else {
              saveStatusEl.style.color = 'var(--muted)';
            }
          }
        };

        // Validate that we have an image_url
        if (!currentCharacterDraft.image_url) {
          setStatus('Please generate a character image before saving.', 'error');
          return null;
        }

        // Check Supabase availability
        if (!state.supabase) {
          setStatus('Supabase client not ready. Please try again.', 'error');
          return null;
        }

        // Check authentication
        if (!state.session || !state.ownerId) {
          setStatus('Please sign in to save characters.', 'error');
          return null;
        }

        // Disable the save button while saving
        if (saveButton) {
          saveButton.disabled = true;
        }

        setStatus('Saving character‚Ä¶', 'saving');

        try {
          // Generate a default name based on archetype
          const archetypeNames = {
            'hero': 'New Hero',
            'villain': 'New Villain',
            'sci-fi': 'New Sci-Fi Character',
            'fantasy': 'New Fantasy Character',
            'child': 'New Child Character',
            'robot': 'New Robot'
          };
          const defaultName = archetypeNames[currentCharacterDraft.archetype] || 'New Character';

          // Build the character payload
          // Note: Using look_portrait_url for the main image URL (as per schema)
          // and base_image_url for the storage path (optional metadata)
          const characterPayload = {
            owner_id: state.ownerId,
            project_id: state.projectId || null, // Can be null if no project selected
            name: defaultName,
            archetype: currentCharacterDraft.archetype || '',
            look_portrait_url: currentCharacterDraft.image_url,
            base_image_url: currentCharacterDraft.storage_path || null,
            // Initialize with defaults for required fields
            traits: [],
            stats_scenes: 0,
            stats_dialogue: 0,
            stats_screen_time: 0,
            look_turnaround_urls: [],
            look_expression_urls: [],
            has_pose_library: false
          };

          // Insert into Supabase and return the new row
          const { data, error } = await state.supabase
            .from('characters')
            .insert([characterPayload])
            .select()
            .single();

          if (error) {
            throw error;
          }

          if (!data) {
            throw new Error('No data returned from insert');
          }

          // Convert the Supabase row to our internal character format
          const newCharacter = supabaseRowToCharacter(data);
          
          // Add to state
          state.characters.push(newCharacter);
          ensureStateCharacterIds();
          state.remoteIds.add(newCharacter.id);
          state.dirty = false; // We just saved, so not dirty
          
          // Set as active character
          state.activeId = newCharacter.id;
          
          // Update UI
          await persistCharactersToLocal();
          renderCharacterList();
          renderCharacterDetails();
          
          // Show success and close wizard
          setStatus('Character saved!', 'success');
          
          setTimeout(() => {
            closeWizard();
            
            // Focus the character in the detail view for accessibility
            const detailsContainer = document.querySelector('[data-character-details]');
            if (detailsContainer) {
              detailsContainer.focus();
              detailsContainer.scrollTop = 0;
            }
          }, 800);

          return newCharacter;
        } catch (error) {
          console.error('Failed to save character from draft:', error);
          setStatus('Failed to save character. Please try again.', 'error');
          return null;
        } finally {
          // Re-enable the save button
          if (saveButton) {
            saveButton.disabled = false;
          }
        }
      }

      /**
       * Generate a character draft using the AI image pipeline.
       * Calls the Supabase function to create a character image based on archetype and tier.
       * @param {Object} draft - Draft configuration with archetype and style
       * @returns {Promise<Object>} Result with image_url and storage_path
       */
      async function generateCharacterDraft(draft) {
        if (!state.supabase) {
          throw new Error('Supabase client not initialized');
        }
        if (!state.session?.access_token) {
          throw new Error('Sign in required to generate character drafts');
        }

        const archetype = draft.archetype || 'hero';
        const tier = draft.style === 'premium' ? 'premium' : 'standard';

        try {
          // Call the ai-image-pipeline Supabase function
          const { data, error } = await state.supabase.functions.invoke('ai-image-pipeline', {
            body: {
              action: 'generate-character-draft',
              archetype: archetype,
              tier: tier
            },
            headers: { 
              Authorization: `Bearer ${state.session.access_token}` 
            },
          });

          if (error) {
            console.error('Character draft generation error:', error);
            throw error;
          }

          // Extract the response
          const imageUrl = data?.image_url;
          const storagePath = data?.storage_path;
          const draftId = data?.draft_id;

          if (!imageUrl || !storagePath) {
            throw new Error('Invalid response from image pipeline');
          }

          return {
            image_url: imageUrl,
            storage_path: storagePath,
            draft_id: draftId,
            provider: data?.provider,
            archetype: data?.archetype,
            tier: data?.tier
          };
        } catch (error) {
          console.error('Failed to generate character draft:', error);
          throw error;
        }
      }

      function showWizardLoading(show, message = 'Generating your first look‚Ä¶') {
        const previewEl = document.querySelector('[data-wizard-preview]');
        if (!previewEl) return;
        
        if (show) {
          previewEl.innerHTML = `<div class="character-studio-wizard-loading" data-wizard-loading><div class="character-studio-wizard-loading-spinner"></div><span>${message}</span></div>`;
        }
      }

      function updateWizardPreview(imageUrl) {
        const previewEl = document.querySelector('[data-wizard-preview]');
        if (!previewEl) return;
        
        if (imageUrl) {
          previewEl.innerHTML = `<img src="${imageUrl}" alt="Character preview" />`;
        }
      }

      async function enterStep2() {
        wizardCurrentStep = 2;
        showWizardStep(2);
        updateWizardStepIndicator();
        
        // Show loading state
        showWizardLoading(true, 'Generating your first look‚Ä¶');
        
        // Generate the first draft
        try {
          const result = await generateCharacterDraft(currentCharacterDraft);
          
          // Store the result in currentCharacterDraft
          currentCharacterDraft.image_url = result.image_url;
          currentCharacterDraft.storage_path = result.storage_path;
          currentCharacterDraft.draft_id = result.draft_id;
          
          // Update the preview
          updateWizardPreview(result.image_url);
        } catch (error) {
          console.error('Failed to generate character draft:', error);
          const previewEl = document.querySelector('[data-wizard-preview]');
          if (previewEl) {
            previewEl.innerHTML = '<div class="character-studio-wizard-loading"><span>Failed to generate preview. Please try again.</span></div>';
          }
        }
      }

      function showWizardStep(stepNumber) {
        const stepContents = document.querySelectorAll('[data-wizard-step-content]');
        stepContents.forEach(content => {
          const step = content.getAttribute('data-wizard-step-content');
          if (step === String(stepNumber)) {
            content.classList.add('active');
          } else {
            content.classList.remove('active');
          }
        });
        
        // Show/hide wizard actions based on step
        const wizardActions = document.querySelector('.character-studio-wizard-actions');
        const continueBtn = document.querySelector('[data-wizard-continue]');
        
        if (stepNumber === 3) {
          // On step 3, hide the default actions (user uses Save Character button instead)
          if (wizardActions) {
            wizardActions.style.display = 'none';
          }
        } else {
          // On steps 1 and 2, show the default actions
          if (wizardActions) {
            wizardActions.style.display = 'flex';
          }
        }
      }

      function updateWizardStepIndicator() {
        const stepIndicator = document.querySelector('[data-wizard-step]');
        if (!stepIndicator) return;
        
        if (wizardCurrentStep === 1) {
          stepIndicator.textContent = 'Step 1 of 3: Choose an archetype';
        } else if (wizardCurrentStep === 2) {
          stepIndicator.textContent = 'Step 2 of 3: First visual draft';
        } else if (wizardCurrentStep === 3) {
          stepIndicator.textContent = 'Step 3 of 3: Save your character';
        }
      }

      function openWizard(){
        const overlay = document.querySelector('[data-wizard-overlay]');
        const wizard = document.querySelector('[data-wizard]');
        if (overlay) overlay.classList.add('active');
        if (wizard) wizard.classList.add('active');
        resetWizard();
      }

      function closeWizard(){
        const overlay = document.querySelector('[data-wizard-overlay]');
        const wizard = document.querySelector('[data-wizard]');
        if (overlay) overlay.classList.remove('active');
        if (wizard) wizard.classList.remove('active');
        resetWizard();
      }

      function resetWizard(){
        wizardCurrentStep = 1;
        currentCharacterDraft.archetype = null;
        currentCharacterDraft.style = 'default';
        currentCharacterDraft.image_url = null;
        currentCharacterDraft.storage_path = null;
        currentCharacterDraft.draft_id = null;
        showWizardStep(1);
        updateWizardStepIndicator();
        const archetypeButtons = document.querySelectorAll('[data-archetype]');
        archetypeButtons.forEach(btn => btn.classList.remove('selected'));
        const validationEl = document.querySelector('[data-wizard-validation]');
        if (validationEl) validationEl.textContent = '';
      }

      function handleArchetypeSelect(archetype){
        currentCharacterDraft.archetype = archetype;
        const archetypeButtons = document.querySelectorAll('[data-archetype]');
        archetypeButtons.forEach(btn => {
          if (btn.getAttribute('data-archetype') === archetype){
            btn.classList.add('selected');
          } else {
            btn.classList.remove('selected');
          }
        });
        const validationEl = document.querySelector('[data-wizard-validation]');
        if (validationEl) validationEl.textContent = '';
      }

      async function handleWizardContinue(){
        const validationEl = document.querySelector('[data-wizard-validation]');
        
        if (wizardCurrentStep === 1) {
          // Step 1: Validate archetype selection
          if (!currentCharacterDraft.archetype) {
            if (validationEl) {
              validationEl.textContent = 'Please select an archetype to continue.';
            }
            return;
          }
          
          // Move to Step 2
          await enterStep2();
        } else if (wizardCurrentStep === 2) {
          // Step 2: Move to Step 3 (Save)
          if (!currentCharacterDraft.image_url) {
            if (validationEl) {
              validationEl.textContent = 'Please wait for the image to generate.';
            }
            return;
          }
          
          // Move to Step 3
          wizardCurrentStep = 3;
          showWizardStep(3);
          updateWizardStepIndicator();
          
          // Copy the preview image to Step 3 (safe DOM manipulation)
          const previewStep2 = document.querySelector('[data-wizard-preview]');
          const previewStep3 = document.querySelector('[data-wizard-preview-step3]');
          if (previewStep2 && previewStep3 && currentCharacterDraft.image_url) {
            // Clear existing content
            previewStep3.textContent = '';
            // Create image element safely
            const img = document.createElement('img');
            img.src = currentCharacterDraft.image_url;
            img.alt = 'Character preview';
            previewStep3.appendChild(img);
          }
        }
      }

      async function handleRegenerateClick() {
        showWizardLoading(true, 'Regenerating character‚Ä¶');
        try {
          const result = await generateCharacterDraft(currentCharacterDraft);
          
          // Store the result in currentCharacterDraft
          currentCharacterDraft.image_url = result.image_url;
          currentCharacterDraft.storage_path = result.storage_path;
          currentCharacterDraft.draft_id = result.draft_id;
          
          updateWizardPreview(result.image_url);
        } catch (error) {
          console.error('Failed to regenerate character draft:', error);
          const previewEl = document.querySelector('[data-wizard-preview]');
          if (previewEl) {
            previewEl.innerHTML = '<div class="character-studio-wizard-loading"><span>Failed to regenerate. Please try again.</span></div>';
          }
        }
      }

      async function handleSwapStyleClick() {
        // Toggle between default (standard) and premium style
        currentCharacterDraft.style = currentCharacterDraft.style === 'default' ? 'premium' : 'default';
        showWizardLoading(true, 'Swapping style‚Ä¶');
        try {
          const result = await generateCharacterDraft(currentCharacterDraft);
          
          // Store the result in currentCharacterDraft
          currentCharacterDraft.image_url = result.image_url;
          currentCharacterDraft.storage_path = result.storage_path;
          currentCharacterDraft.draft_id = result.draft_id;
          
          updateWizardPreview(result.image_url);
        } catch (error) {
          console.error('Failed to swap style:', error);
          const previewEl = document.querySelector('[data-wizard-preview]');
          if (previewEl) {
            previewEl.innerHTML = '<div class="character-studio-wizard-loading"><span>Failed to swap style. Please try again.</span></div>';
          }
        }
      }

      function handleTryAnotherClick() {
        // Return to Step 1 and clear selection
        wizardCurrentStep = 1;
        currentCharacterDraft.archetype = null;
        currentCharacterDraft.style = 'default';
        currentCharacterDraft.image_url = null;
        currentCharacterDraft.storage_path = null;
        currentCharacterDraft.draft_id = null;
        showWizardStep(1);
        updateWizardStepIndicator();
        // Clear archetype selection
        const archetypeButtons = document.querySelectorAll('[data-archetype]');
        archetypeButtons.forEach(btn => btn.classList.remove('selected'));
      }

      // Initialize wizard event listeners
      function initializeWizard() {
        const archetypeButtons = document.querySelectorAll('[data-archetype]');
        archetypeButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            const archetype = btn.getAttribute('data-archetype');
            handleArchetypeSelect(archetype);
          });
        });

        const cancelBtn = document.querySelector('[data-wizard-cancel]');
        if (cancelBtn) {
          cancelBtn.addEventListener('click', closeWizard);
        }

        const continueBtn = document.querySelector('[data-wizard-continue]');
        if (continueBtn) {
          continueBtn.addEventListener('click', handleWizardContinue);
        }

        const regenerateBtn = document.querySelector('[data-wizard-regenerate]');
        if (regenerateBtn) {
          regenerateBtn.addEventListener('click', handleRegenerateClick);
        }

        const swapStyleBtn = document.querySelector('[data-wizard-swap-style]');
        if (swapStyleBtn) {
          swapStyleBtn.addEventListener('click', handleSwapStyleClick);
        }

        const tryAnotherBtn = document.querySelector('[data-wizard-try-another]');
        if (tryAnotherBtn) {
          tryAnotherBtn.addEventListener('click', handleTryAnotherClick);
        }

        const saveCharacterBtn = document.querySelector('[data-wizard-save-character]');
        if (saveCharacterBtn) {
          saveCharacterBtn.addEventListener('click', saveCharacterFromDraft);
        }

        const backToStep2Btn = document.querySelector('[data-wizard-back-to-step2]');
        if (backToStep2Btn) {
          backToStep2Btn.addEventListener('click', () => {
            wizardCurrentStep = 2;
            showWizardStep(2);
            updateWizardStepIndicator();
            // Clear any save status
            const saveStatusEl = document.querySelector('[data-wizard-save-status]');
            if (saveStatusEl) {
              saveStatusEl.textContent = '';
            }
          });
        }

        const overlay = document.querySelector('[data-wizard-overlay]');
        if (overlay) {
          overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
              closeWizard();
            }
          });
        }
      }

      if (typeof mobileViewportQuery.addEventListener === 'function'){
        mobileViewportQuery.addEventListener('change', handleMobileViewportChange);
      } else if (typeof mobileViewportQuery.addListener === 'function'){
        mobileViewportQuery.addListener(handleMobileViewportChange);
      }

      function addCharacter(){
        // Open the wizard instead of immediately creating a character
        openWizard();
      }

      const addButton = document.getElementById('characterStudioAddBtn');
      if (addButton){
        addButton.addEventListener('click', addCharacter);
      }

      // Initialize wizard functionality
      initializeWizard();

      const saveButton = document.getElementById('characterStudioSaveBtn');
      if (saveButton){
        saveButton.addEventListener('click', () => { handleSaveClick(); });
      }

      const initialProjectLabel = state.projectId
        ? `Story ID: ${state.projectId.slice(0, 8).toUpperCase()}`
        : 'No story selected ‚Äî open the Writer to choose a story.';
      setProjectLabel(initialProjectLabel, state.projectId ? '' : 'warning');
      setSaveStatus('', '');

      hydrateDialogDrafts();
      renderCharacterList();
      renderCharacterDetails();
      updateSaveButtonState();
      hydrateCharactersFromLocal();
      initializeSupabase();
      
      // Initialize refinement panel controls
      setupRefineControls();

      // Listen for workspace save requests
      document.addEventListener('studioorganize:save-requested', event => {
        const detail = event?.detail;
        if (!detail) return;
        
        // Mark the event as handled
        if (typeof detail.markHandled === 'function'){
          detail.markHandled();
        } else {
          detail.handled = true;
        }
        
        const action = detail.action || 'save';
        const source = detail.source || 'unknown';
        
        // Create a promise for the save operation
        const savePromise = (async () => {
          try {
            const outcome = await handleSaveClick();
            const success = Boolean(outcome?.success);
            const expectedRows = Array.isArray(outcome?.expectedRows) ? outcome.expectedRows : [];
            const canVerify = success && Boolean(state.supabase && state.projectId);
            return {
              success,
              handled: true,
              action,
              source,
              requiresVerification: Boolean(canVerify),
              verify: canVerify ? async () => {
                if (!state.supabase) throw new Error('Supabase client unavailable during verification.');
                const { data, error } = await state.supabase
                  .from('characters')
                  .select('id, owner_id, project_id, name, role, archetype, pronouns, age, summary, background, family_tree, traits, stats_scenes, stats_dialogue, stats_screen_time, arc_setup, arc_development, arc_resolution, look_portrait_url, look_turnaround_urls, look_expression_urls, base_image_url, has_pose_library, ai_prompt, ai_notes')
                  .eq('project_id', state.projectId)
                  .order('id', { ascending: true });
                if (error) throw error;
                const remoteRows = prepareCharacterRowsForVerification(Array.isArray(data) ? data : []);
                const expected = prepareCharacterRowsForVerification(expectedRows);
                const verified = JSON.stringify(remoteRows) === JSON.stringify(expected);
                if (!verified){
                  console.warn('Character Studio save verification mismatch', { expected, remote: remoteRows });
                }
                return { verified, expectedCount: expected.length, remoteCount: remoteRows.length };
              } : undefined
            };
          } catch (error){
            console.error('Workspace save failed in Character Studio', error);
            return { success: false, handled: true, action, source, error };
          }
        })();
        
        // Register the promise with the event
        if (typeof detail.waitUntil === 'function'){
          detail.waitUntil(savePromise);
        }
      });
    })();
  </script>
  <script>document.getElementById('y').textContent = new Date().getFullYear();</script>
  <script type="module" src="/assets/main.js"></script>
</body>
</html>
